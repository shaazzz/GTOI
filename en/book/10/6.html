

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Virtual Tree &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Lca" href="index.html" />
        <link rel="next" title="Advanced Tree Algorithms" href="../11/index.html" />
        <link rel="prev" title="LCA Linear Time Solution" href="5.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Lca</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Virtual Tree</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/10/6.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <blockquote>
<div><p>&lt;meta charset=&quot;UTF-8&quot;&gt;</p>
</div></blockquote>
<section id="virtual-tree">
<h1>Virtual Tree<a class="headerlink" href="#virtual-tree" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>Consider a tree <span class="math notranslate nohighlight">\(T\)</span>. An arbitrary subset of vertices of <span class="math notranslate nohighlight">\(T\)</span>, say <span class="math notranslate nohighlight">\(A\)</span>, is called a virtual tree if it is closed under <span class="math notranslate nohighlight">\(lca\)</span>. That is, the <span class="math notranslate nohighlight">\(lca\)</span> of any two arbitrary vertices from <span class="math notranslate nohighlight">\(A\)</span> must also be within <span class="math notranslate nohighlight">\(A\)</span> itself.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/virt_tree_intro.png"><img alt="This appears if the user's internet is bad" src="../../_images/virt_tree_intro.png" style="width: 80%;" /></a>
</figure>
<section id="why-is-the-virtual-tree-important-to-us">
<h2>Why is the Virtual Tree important to us?<a class="headerlink" href="#why-is-the-virtual-tree-important-to-us" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="first-problem">
<h3>First Problem<a class="headerlink" href="#first-problem" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Suppose we have colored a subset of the tree's vertices, say <span class="math notranslate nohighlight">\(B\)</span>, black. Now we want to color some uncolored vertices black such that all black vertices become connected. Additionally, we want the total number of black vertices to be minimized. Find this minimum count.</p>
<p>It's clear that to solve this problem, we must color all vertices that lie on the path between at least two black vertices. But the important question is how to find the number of these vertices such that our time complexity depends on <span class="math notranslate nohighlight">\(|B|\)</span> and is completely independent of <span class="math notranslate nohighlight">\(n\)</span>. (i.e., if the given set is small, we should answer quickly, and vice-versa).</p>
<p>Let the answer be <span class="math notranslate nohighlight">\(ans\)</span>. Note that <span class="math notranslate nohighlight">\(ans\)</span> itself might be very large and not of the order of <span class="math notranslate nohighlight">\(|B|\)</span>. For example, if our tree is a path and <span class="math notranslate nohighlight">\(B\)</span> is the set of the two endpoints of this path, then <span class="math notranslate nohighlight">\(ans=n\)</span>. Therefore, we cannot work with a time complexity of <span class="math notranslate nohighlight">\(ans\)</span>.</p>
<p>Now, pay attention to this interesting point. Consider the final state of the tree (where black vertices are connected) and suppose we define the 'black degree' of each vertex <span class="math notranslate nohighlight">\(u\)</span> as the number of black vertices adjacent to the black vertex <span class="math notranslate nohighlight">\(u\)</span>. As you probably noticed from the path example, many vertices we are forced to color black might have a black degree of 2!</p>
<p>We perform an equivalent transformation on the problem to simplify our work. Root the tree at one of the vertices in <span class="math notranslate nohighlight">\(B\)</span>. Now, for every vertex <span class="math notranslate nohighlight">\(u\)</span> in <span class="math notranslate nohighlight">\(B\)</span>, all vertices from <span class="math notranslate nohighlight">\(u\)</span> up to the root must be colored black, and this coloring is also sufficient (meaning the resulting structure satisfies the connectivity condition).</p>
<p>This is where our problem becomes somewhat similar to the virtual tree problem. Suppose we added enough vertices to set <span class="math notranslate nohighlight">\(B\)</span> such that it became closed under <span class="math notranslate nohighlight">\(lca\)</span>. That is, as long as there were two vertices <span class="math notranslate nohighlight">\(u, v\)</span> in <span class="math notranslate nohighlight">\(B\)</span> such that <span class="math notranslate nohighlight">\(lca(u, v)\)</span> was not in <span class="math notranslate nohighlight">\(B\)</span>, we had to color <span class="math notranslate nohighlight">\(lca(u, v)\)</span> black and add it to <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Now, for every non-root vertex <span class="math notranslate nohighlight">\(u\)</span>, call its lowest black ancestor its virtual parent, denoted by <span class="math notranslate nohighlight">\(p_u\)</span>. Note that the vertices between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(p_u\)</span> are precisely those we mentioned would have a black degree of 2, and there might be many of them. Now, if we count these vertices for all <span class="math notranslate nohighlight">\(u, p_u\)</span> (their count is <span class="math notranslate nohighlight">\(h_u - h_{p_u} - 1\)</span>) and add this value to the current number of black vertices, we will get the answer to the problem.</p>
<p>In this section, we didn't mention a few key points, including:</p>
<ul class="simple">
<li><p>How can we find vertices that, if added to set <span class="math notranslate nohighlight">\(B\)</span>, will form a virtual tree?</p></li>
<li><p>Why is the maximum number of vertices in the virtual tree related only to <span class="math notranslate nohighlight">\(B\)</span> and not to <span class="math notranslate nohighlight">\(n\)</span>?</p></li>
</ul>
<p>We will answer these questions next. It is also worth noting that the problem we posed in this section is just as easily solvable without re-rooting the tree. The re-rooting we performed was solely for ease of explanation!</p>
</section>
<section id="diameter-of-a-subset">
<h3>Diameter of a Subset<a class="headerlink" href="#diameter-of-a-subset" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Suppose you are given a tree <span class="math notranslate nohighlight">\(T\)</span> and a set <span class="math notranslate nohighlight">\(B\)</span>. Now you need to name two vertices within <span class="math notranslate nohighlight">\(B\)</span> whose distance from each other is maximal.</p>
<p>We discussed the DFS-based algorithm for finding the diameter of a tree in Chapter 2. Here too, if the vertices of <span class="math notranslate nohighlight">\(B\)</span> are connected, we can use the same DFS algorithm. What if they are not connected? Our current concern is similar to the previous problem. That is, for any two vertices <span class="math notranslate nohighlight">\(u,v\)</span> from <span class="math notranslate nohighlight">\(B\)</span>, we want to add all vertices present on the path <span class="math notranslate nohighlight">\(uv\)</span> to <span class="math notranslate nohighlight">\(B\)</span> and then run the DFS algorithm on the resulting graph.</p>
<p>However, in reality, this is not a good method because, as we stated in the previous problem, the number of vertices we might need to add to <span class="math notranslate nohighlight">\(B\)</span> could be very large.</p>
<p>Here, just like in the previous problem, we use the virtual tree. That is, we expand the set <span class="math notranslate nohighlight">\(B\)</span> until it becomes a virtual tree. Now, in a new graph, we draw an edge between each vertex and its virtual parent with a weight of <span class="math notranslate nohighlight">\(h_u - h_{p_u}\)</span>. The new tree we have is our virtual tree! By finding the diameter in this tree, we find the maximum distance between the original vertices of <span class="math notranslate nohighlight">\(B\)</span>.</p>
</section>
</section>
<section id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>As you probably intuited from the previous problems, a virtual tree can represent a small subtree of our original tree. The interesting point is that this subtree is not necessarily connected, but if we construct a new tree where each vertex is connected to its virtual parent, we obtain a new tree. Then, from now on, we can only consider this new tree and perform our calculations on it.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/transform_to_virt_tree.png"><img alt="This appears if the user's internet is bad" src="../../_images/transform_to_virt_tree.png" style="width: 80%;" /></a>
</figure>
<p>In this section, we assume that the set of vertices <span class="math notranslate nohighlight">\(B\)</span> is given to us, and we want to add some vertices to it to make <span class="math notranslate nohighlight">\(B\)</span> a virtual tree. Here, we call this process 'expansion'.</p>
</section>
<section id="first-attempt">
<h3>First Attempt<a class="headerlink" href="#first-attempt" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>In the first step, for any two vertices <span class="math notranslate nohighlight">\(a, b\)</span> within set <span class="math notranslate nohighlight">\(B\)</span>, we can calculate <span class="math notranslate nohighlight">\(lca(a, b)\)</span> and call this set <span class="math notranslate nohighlight">\(C\)</span>.</p>
<p>Now we claim that <span class="math notranslate nohighlight">\(D = B \cup C\)</span> is a virtual tree. For proof, note that every vertex in <span class="math notranslate nohighlight">\(D\)</span> has at least one member of <span class="math notranslate nohighlight">\(B\)</span> within its subtree. (Why?) Now suppose there are two vertices <span class="math notranslate nohighlight">\(a, b \in D\)</span> such that their <span class="math notranslate nohighlight">\(lca\)</span> is not in <span class="math notranslate nohighlight">\(D\)</span>. Let <span class="math notranslate nohighlight">\(a\prime\)</span> be a vertex from <span class="math notranslate nohighlight">\(B\)</span> in the subtree of <span class="math notranslate nohighlight">\(a\)</span>, and <span class="math notranslate nohighlight">\(b\prime\)</span> be a vertex from <span class="math notranslate nohighlight">\(B\)</span> in the subtree of <span class="math notranslate nohighlight">\(b\)</span>. If <span class="math notranslate nohighlight">\(lca(a, b)\)</span> is not in <span class="math notranslate nohighlight">\(D\)</span>, then <span class="math notranslate nohighlight">\(lca(a\prime, b\prime)\)</span> would be the same as <span class="math notranslate nohighlight">\(lca(a, b)\)</span>, which is in <span class="math notranslate nohighlight">\(C\)</span>, contradicting our initial statement.</p>
<p>Therefore, it is sufficient to perform these calculations only for every pair of vertices within <span class="math notranslate nohighlight">\(B\)</span> (and there's no need to check the <span class="math notranslate nohighlight">\(lca\)</span> of newly added vertices with the others).</p>
</section>
<section id="a-better-algorithm">
<h3>A Better Algorithm<a class="headerlink" href="#a-better-algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>The method we described earlier had high time complexity. If we consider <span class="math notranslate nohighlight">\(lca\)</span> calculations to be <span class="math notranslate nohighlight">\(O(lg(n))\)</span>, then the above method would be <span class="math notranslate nohighlight">\(O(|B|^2)\)</span>.</p>
<p>Now we try to find a better method. Consider a vertex <span class="math notranslate nohighlight">\(u\)</span> that is not in <span class="math notranslate nohighlight">\(B\)</span> but must be in the virtual tree. This means <span class="math notranslate nohighlight">\(u\)</span> has two children, say <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, such that within the subtree of each of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, there exist one or more vertices from <span class="math notranslate nohighlight">\(B\)</span> (whose <span class="math notranslate nohighlight">\(lca\)</span> will be <span class="math notranslate nohighlight">\(u\)</span>).</p>
<p>Now note that taking the <span class="math notranslate nohighlight">\(lca\)</span> of any vertex in <span class="math notranslate nohighlight">\(a\)</span>'s subtree with any vertex in <span class="math notranslate nohighlight">\(b\)</span>'s subtree will yield vertex <span class="math notranslate nohighlight">\(u\)</span>. The problem with the previous algorithm was that in these situations, it would calculate <span class="math notranslate nohighlight">\(u\)</span> many times, which we didn't need. That is, for every ordered pair of vertices from <span class="math notranslate nohighlight">\(a\)</span>'s and <span class="math notranslate nohighlight">\(b\)</span>'s subtrees, it calculated vertex <span class="math notranslate nohighlight">\(u\)</span> once, and this is precisely what increased the time complexity of the previous approach.</p>
<p>The interesting point is that if we can define an initial order for the vertices of tree <span class="math notranslate nohighlight">\(T\)</span> such that in this order, <strong>each vertex's subtree transforms into an interval</strong>, then we can use the following method and claim it works correctly.</p>
<ul class="simple">
<li><p>Sort the vertices of <span class="math notranslate nohighlight">\(B\)</span> according to the described order.</p></li>
<li><p>Now, for every two consecutive vertices in the sorted list we obtained, add their <span class="math notranslate nohighlight">\(lca\)</span> to set <span class="math notranslate nohighlight">\(C\)</span>.</p></li>
<li><p>The union of the two sets <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> forms our virtual tree.</p></li>
</ul>
<p>Why does this algorithm work correctly? We said vertex <span class="math notranslate nohighlight">\(u\)</span> has two children, and there's a vertex from <span class="math notranslate nohighlight">\(B\)</span> in each of their subtrees. In the sorted list on which we performed the algorithm, there exists <strong>an interval</strong> corresponding to the subtree of <span class="math notranslate nohighlight">\(u\)</span>. Within the vertices corresponding to this interval, there must definitely be two vertices belonging to the subtrees of different children of <span class="math notranslate nohighlight">\(u\)</span> (Why?) Therefore, when we calculate <span class="math notranslate nohighlight">\(lca\)</span>, vertex <span class="math notranslate nohighlight">\(u\)</span> is added to set <span class="math notranslate nohighlight">\(C\)</span>! Just as we wanted.</p>
</section>
<section id="optimal-order">
<h3>Optimal Order?<a class="headerlink" href="#optimal-order" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>In the above algorithm, we magically used an order that had an interesting property. But we didn't provide such an order.</p>
<p>You can construct such an order yourself. All methods for constructing such an order are rooted in the DFS algorithm. Why? Because when we want to calculate this order for the subtree of a vertex like <span class="math notranslate nohighlight">\(u\)</span>, we must first recursively find such an order for the subtrees of all of <span class="math notranslate nohighlight">\(u\)</span>'s children, and then add vertex <span class="math notranslate nohighlight">\(u\)</span> somewhere between the intervals of two of its children (or before and after all of them).</p>
<p>This is exactly what we call 'starting-time' or 'finishing-time' in DFS, and we discussed it in Chapter 2.</p>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">max_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">start_time</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">max_log</span><span class="p">],</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">par</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_log</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">sparse_table</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="mi">-1</span><span class="p">]][</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">start_time</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">par</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">u</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">lca</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="w"></span>
<span class="w">      </span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_log</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">sparse_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="w"></span>
<span class="w">          </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_log</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">sparse_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">          </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sparse_table</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">build_virtual_tree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">start_time</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">start_time</span><span class="p">[</span><span class="n">b</span><span class="p">];</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// sort on starting time</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lca</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">start_time</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">start_time</span><span class="p">[</span><span class="n">b</span><span class="p">];</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">vec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="o">-</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Also, note that if vertex <span class="math notranslate nohighlight">\(u\)</span> is in the virtual tree, and the vertex preceding it in the starting-time order is <span class="math notranslate nohighlight">\(v\)</span>, then the virtual parent of <span class="math notranslate nohighlight">\(u\)</span> is equal to <span class="math notranslate nohighlight">\(lca(u, v)\)</span>. (Why?)</p>
<p>To calculate <span class="math notranslate nohighlight">\(lca\)</span> in the code above, a method with <span class="math notranslate nohighlight">\(O(lg(n))\)</span> time complexity was used, and finally, finding the virtual tree expansion of set <span class="math notranslate nohighlight">\(B\)</span> was done in <span class="math notranslate nohighlight">\(O(|B| \times lg(n))\)</span> time.</p>
</section>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="5.html" style="float:left;" title="LCA Linear Time Solution" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="../11/index.html" style="float:right;" title="Advanced Tree Algorithms" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>