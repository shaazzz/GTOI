

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Bellman-Ford &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Shortest Path Algorithms" href="index.html" />
        <link rel="next" title="Dijkstra" href="2.html" />
        <link rel="prev" title="Shortest Path Algorithms" href="index.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Shortest Path Algorithms</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Bellman-Ford</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/6/1.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="bellman-ford">
<h1>Bellman-Ford<a class="headerlink" href="#bellman-ford" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<section id="problem-statement">
<h2>Problem Statement<a class="headerlink" href="#problem-statement" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>We are given a weighted directed graph <span class="math notranslate nohighlight">\(G\)</span>. The weights of <span class="math notranslate nohighlight">\(G\)</span>'s edges can also be negative. We know that graph <span class="math notranslate nohighlight">\(G\)</span> does not contain a cycle with a negative total weight.</p>
<p>Now, for each vertex, we want to find the length of the shortest path from vertex <span class="math notranslate nohighlight">\(sc\)</span> to all other vertices. The length of a path is the sum of its edge weights.</p>
</section>
<section id="bellman-ford-algorithm">
<h2>Bellman-Ford Algorithm<a class="headerlink" href="#bellman-ford-algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>To solve this problem, we first define a <span class="math notranslate nohighlight">\(dp\)</span> table of dimensions <span class="math notranslate nohighlight">\(|V(G)| \times |V(G)|\)</span>, where <span class="math notranslate nohighlight">\(dp_{i,j}\)</span> is the length of the shortest walk from vertex <span class="math notranslate nohighlight">\(sc\)</span> to vertex <span class="math notranslate nohighlight">\(j\)</span> using at most <span class="math notranslate nohighlight">\(i\)</span> edges.</p>
<p>We know that the length of the shortest walk between two vertices in graph <span class="math notranslate nohighlight">\(G\)</span> is also equal to the length of the shortest path, because if the shortest walk contains two repeated vertices, it implies a cycle whose length is positive (as per the problem statement, a cycle cannot have a negative length). This cycle can therefore be removed, leading to a walk with a shorter length, which is a contradiction.</p>
<p>For the base cases of this DP, we know that <span class="math notranslate nohighlight">\(dp_{i, sc} = 0\)</span> and <span class="math notranslate nohighlight">\(dp_{0, u \neq sc} = \infty\)</span>. Now, to find <span class="math notranslate nohighlight">\(dp_{i, j}\)</span>, we consider all edges entering <span class="math notranslate nohighlight">\(j\)</span>. If for each edge <span class="math notranslate nohighlight">\(e\)</span> that enters <span class="math notranslate nohighlight">\(j\)</span> from <span class="math notranslate nohighlight">\(u_e\)</span> with weight <span class="math notranslate nohighlight">\(w_e\)</span>, we calculate <span class="math notranslate nohighlight">\(dp_{i-1, u_e} + w_e\)</span>, the minimum of these values becomes the answer for <span class="math notranslate nohighlight">\(dp_{i, j}\)</span>. Consequently:</p>
<div class="math notranslate nohighlight">
\[dp_{i, j} = \displaystyle{\min_{\forall \, e \: \in \: N_{j}^{-}(j)}} dp_{i-1, u_e} + w_e`\]</div>
<p>To obtain the length of the shortest path from vertex <span class="math notranslate nohighlight">\(sc\)</span> to vertex <span class="math notranslate nohighlight">\(u\)</span>, having the value <span class="math notranslate nohighlight">\(dp_{n-1, u}\)</span> is sufficient. This is because a path from vertex <span class="math notranslate nohighlight">\(sc\)</span> to another vertex has at most <span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(n-1\)</span> edges, and according to the DP definition and the fact that the shortest walk between two vertices in <span class="math notranslate nohighlight">\(G\)</span> is necessarily a path, this value is exactly the required value.</p>
</section>
<section id="complexity-analysis">
<h2>Complexity Analysis<a class="headerlink" href="#complexity-analysis" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>To update all entries of <span class="math notranslate nohighlight">\(dp_i\)</span>, we perform operations proportional to the in-degree for each vertex. We know that the sum of in-degrees of all vertices equals <span class="math notranslate nohighlight">\(|E(G)|\)</span>. Thus, in total, we perform <span class="math notranslate nohighlight">\(\mathcal{O}\left(|V(G)|.|E(G)|\right)\)</span> operations. The space complexity used is <span class="math notranslate nohighlight">\(\mathcal{O}\left(|V(G)|^2\right)\)</span>.</p>
</section>
<section id="memory-optimization">
<h2>Memory Optimization<a class="headerlink" href="#memory-optimization" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>To optimize the memory usage, the first dimension can be removed. Consequently, the memory complexity becomes <span class="math notranslate nohighlight">\(\mathcal{O}\left(|V(G)|\right)\)</span>.</p>
<p>Then, for <span class="math notranslate nohighlight">\(|V(G)| - 1\)</span> stages, for each edge, the <span class="math notranslate nohighlight">\(dp\)</span> value of the edge's head vertex is updated. Updating means that if edge <span class="math notranslate nohighlight">\(e\)</span> goes from vertex <span class="math notranslate nohighlight">\(u_e\)</span> to <span class="math notranslate nohighlight">\(v_e\)</span> with weight <span class="math notranslate nohighlight">\(w_e\)</span>, we set <span class="math notranslate nohighlight">\(dp_{v_e} = \min(dp_{v_e}, dp_{u_e} + w_e)\)</span>.</p>
<p>Now a question arises: does performing this preserve the desired values in the <span class="math notranslate nohighlight">\(dp\)</span> table? The answer is yes.</p>
<p>If we consider the DP from the previous section as <span class="math notranslate nohighlight">\(dp^{\prime}\)</span>, after the <span class="math notranslate nohighlight">\(i\)</span>-th stage of updating <span class="math notranslate nohighlight">\(dp\)</span>, we know that <span class="math notranslate nohighlight">\(dp_u\)</span> is equal to one of <span class="math notranslate nohighlight">\(dp_{i, u}^{\prime}, dp_{i+1, u}^{\prime}, \dots, dp_{n-1, u}^{\prime}\)</span>. (Proof of this lemma is left to the reader.)</p>
<p>Now, if we check after the <span class="math notranslate nohighlight">\((n-1)\)</span>-th stage, we find that <span class="math notranslate nohighlight">\(dp_u = dp_{n-1, u}^{\prime}\)</span>. Consequently, after the <span class="math notranslate nohighlight">\((n-1)\)</span>-th stage, the values in the <span class="math notranslate nohighlight">\(dp\)</span> table are the desired ones.</p>
</section>
<section id="finding-the-shortest-path">
<h2>Finding the Shortest Path<a class="headerlink" href="#finding-the-shortest-path" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>After all this discussion, a question might come to your mind: what if we need the optimal path itself from <span class="math notranslate nohighlight">\(sc\)</span> to another vertex like <span class="math notranslate nohighlight">\(des\)</span>?</p>
<p>To answer this question, we need to slightly modify the previous algorithm. We introduce an auxiliary array of size <span class="math notranslate nohighlight">\(|V(G)|\)</span> named <span class="math notranslate nohighlight">\(par\)</span>. Initially, we set all entries of <span class="math notranslate nohighlight">\(par\)</span> to -1. Now, if when considering edge <span class="math notranslate nohighlight">\(e\)</span>, we have <span class="math notranslate nohighlight">\(dp_{v_e} &gt; dp_{u_e} + w_e\)</span>, we set <span class="math notranslate nohighlight">\(par_{v_e}\)</span> to <span class="math notranslate nohighlight">\(u_e\)</span>.</p>
<p><span class="math notranslate nohighlight">\(par_u\)</span> is effectively the previous vertex on the optimal path from <span class="math notranslate nohighlight">\(sc\)</span> to <span class="math notranslate nohighlight">\(u\)</span>. To find the path from <span class="math notranslate nohighlight">\(sc\)</span> to <span class="math notranslate nohighlight">\(des\)</span>, we maintain a variable <span class="math notranslate nohighlight">\(nw\)</span> and, as long as <span class="math notranslate nohighlight">\(nw \neq sc\)</span>, we set <span class="math notranslate nohighlight">\(nw\)</span> to <span class="math notranslate nohighlight">\(par_{nw}\)</span> and prepend <span class="math notranslate nohighlight">\(nw\)</span> to the current path.</p>
<p>To prove that we necessarily reach vertex <span class="math notranslate nohighlight">\(sc\)</span> and that the path obtained is an optimal path, we assume an array <span class="math notranslate nohighlight">\(lst\)</span>. <span class="math notranslate nohighlight">\(lst_u\)</span> is the number of the last stage where <span class="math notranslate nohighlight">\(dp_u\)</span> was updated. We know that <span class="math notranslate nohighlight">\(lst_u &gt; lst_{par_u}\)</span>. (Proof is left to the reader.) Thus, each time we set <span class="math notranslate nohighlight">\(nw\)</span> to <span class="math notranslate nohighlight">\(par_{nw}\)</span>, <span class="math notranslate nohighlight">\(lst_{nw}\)</span> decreases, so we do not enter a cycle and will definitely reach <span class="math notranslate nohighlight">\(sc\)</span>.</p>
<p>The length of the path will also be <span class="math notranslate nohighlight">\(dp_{des}\)</span> because if we add an edge with weight <span class="math notranslate nohighlight">\(w\)</span> to the path at each step, the value of <span class="math notranslate nohighlight">\(dp_{nw}\)</span> decreases exactly by <span class="math notranslate nohighlight">\(w\)</span>. Since <span class="math notranslate nohighlight">\(dp_{sc} = 0\)</span>, the length of the path will be exactly <span class="math notranslate nohighlight">\(dp_{des}\)</span>.</p>
</section>
<section id="negative-cycle">
<h2>Negative Cycle<a class="headerlink" href="#negative-cycle" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>You might wonder, if it's not guaranteed whether the graph has a negative cycle or not, how do we detect one (in the case where memory has been optimized)?</p>
<p>First, assume we run <span class="math notranslate nohighlight">\(|V(G)|\)</span> stages instead of <span class="math notranslate nohighlight">\(|V(G)| - 1\)</span> stages.
We call a stage of the algorithm &quot;good&quot; if at least one of the <span class="math notranslate nohighlight">\(dp\)</span> values changes. We know that if the <span class="math notranslate nohighlight">\(i\)</span>-th stage is not good, then subsequent stages will also not be good. (If no value changes, then subsequent stages will behave exactly like the <span class="math notranslate nohighlight">\(i\)</span>-th stage, and no value will change.)</p>
<p>Now, if we do not have a negative cycle, then according to previous arguments, the <span class="math notranslate nohighlight">\(|V(G)|\)</span>-th stage must not be good. (All values would have reached their final amounts in the previous stage and will not change).
Now, if a negative cycle exists, we know that the <span class="math notranslate nohighlight">\(dp\)</span> values of its vertices will never stabilize. The negative cycle itself can be traversed multiple times, which causes the <span class="math notranslate nohighlight">\(dp\)</span> values of the cycle's vertices to approach <span class="math notranslate nohighlight">\(-\infty\)</span>. We know that if a stage is not good, then all values have stabilized. Based on these statements, it follows that if we have a negative cycle, all stages will be good.</p>
<p>So, we know that if we don't have a negative cycle, the <span class="math notranslate nohighlight">\(|V(G)|\)</span>-th stage is not good, and if we do have a negative cycle, the <span class="math notranslate nohighlight">\(|V(G)|\)</span>-th stage must be good.
Therefore, to check for the presence of a negative cycle, it is sufficient to check if the <span class="math notranslate nohighlight">\(|V(G)|\)</span>-th stage is good.</p>
<p>To find the negative cycle itself (similar to the case without negative cycles), take an auxiliary array named <span class="math notranslate nohighlight">\(par\)</span>. Trace back from a vertex whose <span class="math notranslate nohighlight">\(dp\)</span> value changed in the <span class="math notranslate nohighlight">\(|V(G)|\)</span>-th stage; the negative cycle will necessarily be present in this path. (This section's reasoning can be used to prove this.)</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="index.html" style="float:left;" title="Shortest Path Algorithms" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="2.html" style="float:right;" title="Dijkstra" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>