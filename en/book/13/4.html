

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Applications &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Matching" href="index.html" />
        <link rel="next" title="Maximum Flow and Matching" href="5.html" />
        <link rel="prev" title="Min-Max Theorems" href="3.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Matching</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Min-Max Theorems</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Applications</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/13/4.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <p>Here's the English translation of the provided reStructuredText content:</p>
<section id="applications">
<h1>Applications<a class="headerlink" href="#applications" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<section id="directed-and-bipartite-graphs">
<h2>Directed and Bipartite Graphs<a class="headerlink" href="#directed-and-bipartite-graphs" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In this section, we will see that the two concepts of bipartite and directed graphs are interconvertible, and depending on which one provides better intuition for solving a problem, we can use either of them.</p>
<p>Consider the adjacency matrix of a bipartite graph and a directed graph. Both are <span class="math notranslate nohighlight">\(n*n\)</span> matrices with entries 0 or 1. (Not necessarily symmetric)</p>
<p>Now, to convert a directed graph to a bipartite graph, it suffices to consider the adjacency matrix of the directed graph, which we call <span class="math notranslate nohighlight">\(M\)</span>, and draw a bipartite graph whose adjacency matrix is <span class="math notranslate nohighlight">\(M\)</span>. The conversion of a bipartite graph to a directed graph is similar. To look at it more intuitively, each edge <span class="math notranslate nohighlight">\(ab\)</span> in a directed graph is equivalent to an edge between vertex <span class="math notranslate nohighlight">\(a\)</span> from the left partition and vertex <span class="math notranslate nohighlight">\(b\)</span> from the right partition. That is, the left partition represents the outputs and the right partition represents the inputs.</p>
<p>Now consider a matching in a bipartite graph. If we convert the bipartite graph to a directed graph, what will our matching transform into?</p>
<p>A number of directed cycles and paths! This is because in a bipartite graph, at most one incident edge is chosen for each vertex, which in a directed graph means that each vertex has at most one in-degree and at most one out-degree.</p>
</section>
<section id="partitioning-a-dag-into-paths">
<h2>Partitioning a DAG into Paths<a class="headerlink" href="#partitioning-a-dag-into-paths" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>We have a directed acyclic graph (DAG). What is the minimum <span class="math notranslate nohighlight">\(x\)</span> such that this graph can be partitioned into <span class="math notranslate nohighlight">\(x\)</span> directed paths?</p>
<p>Note that if in this optimal partition the number of edges in the paths is <span class="math notranslate nohighlight">\(y\)</span>, then <span class="math notranslate nohighlight">\(x+y=n\)</span>. So, to minimize <span class="math notranslate nohighlight">\(x\)</span>, it suffices to maximize <span class="math notranslate nohighlight">\(y\)</span>. Convert the directed graph to a bipartite graph. Now, <span class="math notranslate nohighlight">\(y\)</span> is equal to the maximum matching of this bipartite graph. (Why?)</p>
</section>
<section id="partitioning-a-directed-graph-into-cycles">
<h2>Partitioning a Directed Graph into Cycles<a class="headerlink" href="#partitioning-a-directed-graph-into-cycles" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose we want to find a method to partition a directed graph into cycles.</p>
<p>First, convert the graph into bipartite form. We said that a matching signifies a partition into cycles and paths. You can easily conclude that a perfect matching provides us with a partition into cycles. So, it suffices to find a perfect matching in the bipartite graph.</p>
</section>
<section id="k-regular-graph-and-partitioning-into-cycles">
<h2>2k-Regular Graph and Partitioning into Cycles<a class="headerlink" href="#k-regular-graph-and-partitioning-into-cycles" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>This time, our topic is an undirected graph. Similar to the problem above, imagine we have an <strong>undirected</strong> graph like <span class="math notranslate nohighlight">\(G\)</span> and we know it is <span class="math notranslate nohighlight">\(2k\)</span>-regular. We want to <strong>prove</strong> that there is a method to partition this graph into cycles.</p>
<p>The first idea is to replace each edge <span class="math notranslate nohighlight">\(ab\)</span> in <span class="math notranslate nohighlight">\(G\)</span> with two directed edges <span class="math notranslate nohighlight">\(ab\)</span> and <span class="math notranslate nohighlight">\(ba\)</span> in a directed graph. Then, similar to the problem above, first convert the directed graph into bipartite form and then try to find a perfect matching.</p>
<p>The problem that arises with this approach is that this partition might result in cycles of length 2 (which are essentially single edges), which is not desirable for us.</p>
<p>To prevent this problem, consider an Eulerian tour of the graph and direct each edge in the direction the Eulerian tour traverses it. (If the graph has multiple connected components, we do this for each component).
Now, the resulting graph is a directed graph where each vertex has an in-degree and out-degree equal to <span class="math notranslate nohighlight">\(k\)</span>. If we now convert this graph into bipartite form, each vertex will have degree <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>According to a theorem we previously proved, a <span class="math notranslate nohighlight">\(k\)</span>-regular bipartite graph has a perfect matching, so there is also a method to partition this directed graph into cycles.</p>
</section>
<section id="degree-sequence-of-a-tournament-and-matching">
<h2>Degree Sequence of a Tournament and Matching<a class="headerlink" href="#degree-sequence-of-a-tournament-and-matching" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose the sequence <span class="math notranslate nohighlight">\(d_1,d_2,...d_n\)</span> is given, and we know <span class="math notranslate nohighlight">\(\sum\limits_{i=1}^{n} d_i = {n \choose 2}\)</span>. We want to check if there exists a tournament where the out-degree of each vertex <span class="math notranslate nohighlight">\(u\)</span> is equal to <span class="math notranslate nohighlight">\(d_u\)</span>?</p>
<p>Construct a bipartite graph. The right partition has <span class="math notranslate nohighlight">\(n\)</span> vertices, and the left partition has <span class="math notranslate nohighlight">\(n \choose 2\)</span> vertices, where each vertex in the left partition represents an edge of the tournament. Connect the vertex representing edge <span class="math notranslate nohighlight">\(ab\)</span> to vertex <span class="math notranslate nohighlight">\(a\)</span> and vertex <span class="math notranslate nohighlight">\(b\)</span> from the right partition. Now, choose a subset of edges such that the degree of each vertex in the left partition is 1, and the degree of vertex <span class="math notranslate nohighlight">\(u\)</span> in the right partition is <span class="math notranslate nohighlight">\(d_u\)</span>. (Similar to a matching we discussed in the generalization of Hall's theorem section).</p>
<p>Intuitively, each vertex in the left partition, like the one representing <span class="math notranslate nohighlight">\(ab\)</span>, must choose one of the two vertices <span class="math notranslate nohighlight">\(a\)</span> or <span class="math notranslate nohighlight">\(b\)</span>. If it chooses <span class="math notranslate nohighlight">\(a\)</span>, it means that in the tournament, the edge between <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> will be directed from <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(b\)</span>, and vice versa. Also, the out-degree of vertex <span class="math notranslate nohighlight">\(u\)</span> in the tournament should be <span class="math notranslate nohighlight">\(d_u\)</span>, so each vertex <span class="math notranslate nohighlight">\(u\)</span> from the right partition must be chosen by exactly <span class="math notranslate nohighlight">\(d_u\)</span> vertices from the left partition!</p>
<p>So, according to the topics we discussed in the generalization of Hall's theorem section, the necessary and sufficient condition for such a tournament to exist is that for every subset of vertices in the left partition, say <span class="math notranslate nohighlight">\(S\)</span>, if the union of its neighbors in the right partition is <span class="math notranslate nohighlight">\(P\)</span>, then:
<span class="math notranslate nohighlight">\(|S| \leq \sum\limits_{u \in P} d_u\)</span>
Since we can increase the left side to <span class="math notranslate nohighlight">\(|P| \choose 2\)</span> without changing the right side of the inequality (Why?), we can also write the condition as:</p>
<p><span class="math notranslate nohighlight">\(\forall_{P \subseteq \{1,2,...,n\}} {|P| \choose 2} \leq \sum\limits_{u \in P} d_u\)</span></p>
<p>Now, since only the number of elements in the set matters on the left side of the inequality, not the set itself, it is sufficient to check the condition for the smallest <span class="math notranslate nohighlight">\(d_u\)</span> values. In other words, assuming <span class="math notranslate nohighlight">\(d_1 \leq d_2 \leq ... d_n\)</span>, the following condition is necessary and sufficient:</p>
<p><span class="math notranslate nohighlight">\(\forall_{1 \leq k \leq n} {k \choose 2} \leq \sum\limits_{i=1}^{k} d_i\)</span></p>
</section>
<section id="fixed-vertices-in-bipartite-matching">
<h2>Fixed Vertices in Bipartite Matching<a class="headerlink" href="#fixed-vertices-in-bipartite-matching" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>We have a bipartite graph. For a matching <span class="math notranslate nohighlight">\(M\)</span>, any vertex <span class="math notranslate nohighlight">\(u\)</span> incident to one of the edges in <span class="math notranslate nohighlight">\(M\)</span> is said to be <em>covered</em> by <span class="math notranslate nohighlight">\(M\)</span>. Now, for all vertices <span class="math notranslate nohighlight">\(u\)</span>, you need to determine if there exists a maximum matching such that <span class="math notranslate nohighlight">\(u\)</span> is <strong>not covered</strong> by this matching?</p>
<p>First, consider an arbitrary maximum matching, say <span class="math notranslate nohighlight">\(M\)</span>. Now, for all vertices not covered by <span class="math notranslate nohighlight">\(M\)</span>, we know the answer. We want to find the answer for each vertex <span class="math notranslate nohighlight">\(u\)</span> covered by <span class="math notranslate nohighlight">\(M\)</span>. Suppose there exists a maximum matching <span class="math notranslate nohighlight">\(M^{\prime}\)</span> such that <span class="math notranslate nohighlight">\(u\)</span> is not covered by it. Now, let the symmetric difference of <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(M^{\prime}\)</span> be <span class="math notranslate nohighlight">\(H\)</span>. In this case, <span class="math notranslate nohighlight">\(H\)</span> must consist of a number of cycles and even paths, and <span class="math notranslate nohighlight">\(u\)</span> must be an endpoint of one of these even paths (Why?)!</p>
<p>Thus, we conclude that for any vertex <span class="math notranslate nohighlight">\(u\)</span> that is covered by matching <span class="math notranslate nohighlight">\(M\)</span>, we can find a matching in which <span class="math notranslate nohighlight">\(u\)</span> is not covered if and only if there exists an alternating path from a free vertex (a vertex not covered by matching <span class="math notranslate nohighlight">\(M\)</span>) to <span class="math notranslate nohighlight">\(u\)</span>. Note that since this alternating path is not an augmenting path, its two ends are in the same partition of our bipartite graph.</p>
<p>So far, we haven't used the bipartite nature of the graph (all the statements made hold for any graph). But now, to find a maximum matching and the vertices that are the start of an alternating path, we must use the bipartite nature of the graph.</p>
<p>First, find the maximum matching <span class="math notranslate nohighlight">\(M\)</span> using the algorithm we presented in Section 12.2.</p>
<p>Now, suppose the two partitions of the graph are <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, and we want to solve the problem for partition <span class="math notranslate nohighlight">\(X\)</span>. We direct the edges of the graph such that edges belonging to <span class="math notranslate nohighlight">\(M\)</span> are directed from <span class="math notranslate nohighlight">\(Y\)</span> to <span class="math notranslate nohighlight">\(X\)</span>, and edges not belonging to <span class="math notranslate nohighlight">\(M\)</span> are directed from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. You can see that any alternating path starting from a vertex in <span class="math notranslate nohighlight">\(X\)</span> is actually equivalent to a path in our directed graph that must start from one of the free vertices in <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>So, it is enough to direct the graph as described, and then run a DFS algorithm from each free vertex in <span class="math notranslate nohighlight">\(X\)</span> to check which vertices are reachable. Ultimately, all vertices in <span class="math notranslate nohighlight">\(X\)</span> that we could reach are part of an alternating path. As we said, this implies that for each of those vertices, there exists a maximum matching in which that vertex is not covered.</p>
<p>Similarly, we can solve the problem for partition <span class="math notranslate nohighlight">\(Y\)</span> as well.</p>
</section>
<section id="finding-a-minimum-vertex-cover-in-a-bipartite-graph">
<h2>Finding a Minimum Vertex Cover in a Bipartite Graph<a class="headerlink" href="#finding-a-minimum-vertex-cover-in-a-bipartite-graph" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In Section 12.3, we learned that in a bipartite graph, the size of a minimum vertex cover is equal to the size of a maximum matching. In this section, we learn how to find a minimum vertex cover given a maximum matching.</p>
<p>First, consider the edges of the maximum matching and call it <span class="math notranslate nohighlight">\(M\)</span>. Since for each edge of the matching, one of its endpoints must be in the vertex cover, exactly one of its two endpoints must be in the minimum vertex cover (Why?). So, for each edge in <span class="math notranslate nohighlight">\(M\)</span>, it suffices to decide whether to include the vertex from the first partition or the vertex from the second partition in the vertex cover.</p>
<p>Name the two partitions of the graph <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>. Call the set of edges from <span class="math notranslate nohighlight">\(M\)</span> for which we choose the vertex from partition <span class="math notranslate nohighlight">\(X\)</span> as <span class="math notranslate nohighlight">\(MX\)</span>, and the set of edges from <span class="math notranslate nohighlight">\(M\)</span> for which we choose the vertex from partition <span class="math notranslate nohighlight">\(Y\)</span> as <span class="math notranslate nohighlight">\(MY\)</span>. Now we want to determine <span class="math notranslate nohighlight">\(MX\)</span> and <span class="math notranslate nohighlight">\(MY\)</span>.</p>
<p>Similar to the previous section, we direct the edges of the bipartite graph such that edges belonging to <span class="math notranslate nohighlight">\(M\)</span> are directed from partition <span class="math notranslate nohighlight">\(Y\)</span> to <span class="math notranslate nohighlight">\(X\)</span>, and edges not belonging to <span class="math notranslate nohighlight">\(M\)</span> are directed from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. Now, run DFS from all vertices in partition <span class="math notranslate nohighlight">\(X\)</span> that are not covered by the matching. Let <span class="math notranslate nohighlight">\(A\)</span> be all the reachable vertices, and <span class="math notranslate nohighlight">\(B\)</span> be the remaining ones. It is clear that there are no edges between <span class="math notranslate nohighlight">\(X \cap A\)</span> and <span class="math notranslate nohighlight">\(Y \cap B\)</span> (otherwise, the set <span class="math notranslate nohighlight">\(A\)</span> would change). Therefore, we can select all vertices in <span class="math notranslate nohighlight">\(Y \cap A\)</span> and <span class="math notranslate nohighlight">\(X \cap B\)</span> for the vertex cover. Since neither of these two sets contains free vertices (because <span class="math notranslate nohighlight">\(M\)</span> is maximum, so there are no augmenting paths), we can conclude that our statement is equivalent to assigning all edges seen in DFS to <span class="math notranslate nohighlight">\(MY\)</span> and the rest to <span class="math notranslate nohighlight">\(MX\)</span>. That is, <span class="math notranslate nohighlight">\(MX = M - MY\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/min_cover_finding.jpg"><img alt="If the person's internet is trash, this will appear" src="../../_images/min_cover_finding.jpg" style="width: 50%;" /></a>
</figure>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="3.html" style="float:left;" title="Min-Max Theorems" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="5.html" style="float:right;" title="Maximum Flow and Matching" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>