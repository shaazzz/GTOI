

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Poset &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Matching" href="index.html" />
        <link rel="next" title="Matching in General Graphs" href="7.html" />
        <link rel="prev" title="Maximum Flow and Matching" href="5.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Matching</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Poset</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/13/6.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="poset">
<h1>Poset<a class="headerlink" href="#poset" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>A directed graph with the following property is called a Poset (Partially ordered set):</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(ab\)</span> and <span class="math notranslate nohighlight">\(bc\)</span> are edges of this graph, then <span class="math notranslate nohighlight">\(ac\)</span> is also an edge of this graph.</p></li>
</ul>
<p>Since many mathematical concepts can be transformed into posets, studying them is useful.</p>
<section id="first-problem">
<h3>First Problem<a class="headerlink" href="#first-problem" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Suppose we have a set of natural numbers, say <span class="math notranslate nohighlight">\(A\)</span>, and we want to find its largest subset, say <span class="math notranslate nohighlight">\(B\)</span>, such that for any two members of <span class="math notranslate nohighlight">\(B\)</span> we consider, one is divisible by the other.</p>
<p>We can model this problem as a graph. For each member of <span class="math notranslate nohighlight">\(A\)</span>, place a vertex in the graph, and for two vertices <span class="math notranslate nohighlight">\(x,y\)</span> such that <span class="math notranslate nohighlight">\(x|y\)</span>, draw an edge from <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(y\)</span>. Now the problem is equivalent to finding the longest path in this graph!</p>
</section>
<section id="chain-and-antichain">
<h3>Chain and Antichain<a class="headerlink" href="#chain-and-antichain" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>A sequence of distinct vertices, such as <span class="math notranslate nohighlight">\(u_1,...,u_k\)</span>, where for every <span class="math notranslate nohighlight">\(i&lt;j\)</span>, <span class="math notranslate nohighlight">\(u_i\)</span> has an edge to <span class="math notranslate nohighlight">\(u_j\)</span>, is called a chain. Note that due to the poset property, it is sufficient that <span class="math notranslate nohighlight">\(u_1, ... u_k\)</span> form a path.</p>
<p>A subset of vertices where no two vertices have an edge between them is called an antichain.</p>
<p>In the following, we will examine the partition of a graph into chains or antichains (partition of the graph's vertices is intended).</p>
<p>Note that these definitions are used only in posets.</p>
</section>
</section>
<section id="maximum-chain-minimum-partition-into-antichains">
<h2>Maximum Chain = Minimum Partition into Antichains<a class="headerlink" href="#maximum-chain-minimum-partition-into-antichains" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose the size of the maximum chain is <span class="math notranslate nohighlight">\(L\)</span>. Consider a maximum chain, say <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Each antichain can contain at most one vertex from <span class="math notranslate nohighlight">\(A\)</span>. Therefore, the minimum partition into antichains is at least <span class="math notranslate nohighlight">\(L\)</span>. Now we will prove that an equality case also exists.</p>
<p>To each vertex <span class="math notranslate nohighlight">\(u\)</span>, we assign a number <span class="math notranslate nohighlight">\(a_u\)</span> which is equal to the size of the longest chain ending at <span class="math notranslate nohighlight">\(u\)</span>. Now you can see that if <span class="math notranslate nohighlight">\(a_i = a_j\)</span> holds, it's impossible for an edge to exist between <span class="math notranslate nohighlight">\(i,j\)</span>, because, for example, if there is an edge from <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(j\)</span>, then <span class="math notranslate nohighlight">\(a_j \geq a_i+1\)</span>.</p>
<p>For each vertex <span class="math notranslate nohighlight">\(u\)</span>, we call <span class="math notranslate nohighlight">\(a_u\)</span> the color of vertex <span class="math notranslate nohighlight">\(u\)</span>. According to the proof above, vertices with the same color form an antichain. Also, the number of colors is equal to <span class="math notranslate nohighlight">\(L\)</span> (why?). Thus, we were able to partition the graph into <span class="math notranslate nohighlight">\(L\)</span> antichains.</p>
<p>This theorem is known as Mirsky's theorem and was introduced in 1971. Interestingly, this theorem was known in 1940 by Dilworth, Galai, Fulkerson, and many others, and their only reason for not presenting it was that they considered it trivial!</p>
</section>
<section id="maximum-antichain-minimum-partition-into-chains">
<h2>Maximum Antichain = Minimum Partition into Chains<a class="headerlink" href="#maximum-antichain-minimum-partition-into-chains" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>As before, we can initially conclude that the minimum partition into chains is at least the size of the maximum antichain (because in any chain, we can use at most one vertex from the antichain). Now we want to provide an example to prove equality.</p>
<p>We discussed the problem of partitioning graph vertices into a minimum number of paths in Section 4. It was sufficient to transform the graph into a bipartite form and find the maximum matching. Now we know that in posets, each chain is equivalent to a path. So, the problem of minimum partition into chains is solved by finding the minimum partition of vertices into paths.</p>
<section id="pseudo-augmenting-path">
<h3>Pseudo-augmenting Path<a class="headerlink" href="#pseudo-augmenting-path" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Now, suppose our poset is a directed graph called <span class="math notranslate nohighlight">\(P\)</span>. Call its equivalent bipartite graph <span class="math notranslate nohighlight">\(G\)</span>. Consider a minimum partition into paths in <span class="math notranslate nohighlight">\(P\)</span>. Let <span class="math notranslate nohighlight">\(M\)</span> be the set of directed edges present in our paths. We know that the edges in <span class="math notranslate nohighlight">\(M\)</span> are equivalent to the edges of a maximum matching in <span class="math notranslate nohighlight">\(G\)</span>. The necessary and sufficient condition for a matching to be maximum was that there are no augmenting paths. We will examine what an equivalent of an augmenting path in our directed graph would look like. A free vertex in the first part of <span class="math notranslate nohighlight">\(G\)</span> corresponds to a vertex in <span class="math notranslate nohighlight">\(P\)</span> that is the end of a path. A free vertex in the second part of <span class="math notranslate nohighlight">\(G\)</span> corresponds to a vertex in <span class="math notranslate nohighlight">\(P\)</span> that is the start of a path.</p>
<p>So, we want to understand the equivalent of an augmenting path in <span class="math notranslate nohighlight">\(G\)</span> that starts from the first part and goes to the second part, in graph <span class="math notranslate nohighlight">\(P\)</span>. We define a <strong>pseudo-augmenting path</strong> in <span class="math notranslate nohighlight">\(P\)</span> as follows:</p>
<p>A sequence of vertices <span class="math notranslate nohighlight">\(u_1,u_2,...,u_{2k+1}\)</span> such that <span class="math notranslate nohighlight">\(u_1\)</span> is the start and <span class="math notranslate nohighlight">\(u_{2k+1}\)</span> is the end of a selected path in the minimum partition. Also, for <span class="math notranslate nohighlight">\(u_{2i-1},u_{2i}\)</span> in <span class="math notranslate nohighlight">\(P\)</span>, the edge <span class="math notranslate nohighlight">\(u_{2i-1}u_{2i}\)</span> must exist and not be a member of <span class="math notranslate nohighlight">\(M\)</span>, and for <span class="math notranslate nohighlight">\(u_{2i},u_{2i+1}\)</span>, the edge <span class="math notranslate nohighlight">\(u_{2i+1}u_{2i}\)</span> must be in <span class="math notranslate nohighlight">\(M\)</span>! (Pay attention to the change in order).</p>
<p>So now we can assume that we have partitioned the vertices of <span class="math notranslate nohighlight">\(P\)</span> into the minimum number of paths such that there is no pseudo-augmenting path in <span class="math notranslate nohighlight">\(P\)</span>.</p>
</section>
<section id="algorithm">
<h3>Algorithm<a class="headerlink" href="#algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Now our goal is to select exactly one vertex from each chain such that the selected vertices form an antichain. In this case, we can achieve equality.</p>
<p>Consider the following algorithm:</p>
<ul class="simple">
<li><p>Consider the first vertices of the paths. If there are no edges between them, just select them. Otherwise, there exists an edge like <span class="math notranslate nohighlight">\(uv\)</span> where both <span class="math notranslate nohighlight">\(u,v\)</span> are the first vertices of two paths in our partition.</p></li>
<li><p>Now we must remove vertex <span class="math notranslate nohighlight">\(u\)</span>. Because, given that <span class="math notranslate nohighlight">\(u\)</span> has an edge to <span class="math notranslate nohighlight">\(v\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> is the first vertex of a path, by the poset property, it can be concluded that <span class="math notranslate nohighlight">\(u\)</span> has an edge to all vertices of the path starting with <span class="math notranslate nohighlight">\(v\)</span>. So if we select <span class="math notranslate nohighlight">\(u\)</span> in the antichain, we cannot select any vertex from the path that starts with <span class="math notranslate nohighlight">\(v\)</span>, and thus we cannot achieve our goal of selecting one vertex from each path. So, remove <span class="math notranslate nohighlight">\(u\)</span>.</p></li>
</ul>
<p>Continue this process until there are no edges between the first vertices of the paths (after removals) and we find an antichain of size equal to the number of paths. The only case that would spoil our work is if a path is completely removed (in which case the antichain would not be of the size of the initial number of paths).</p>
</section>
<section id="no-path-is-completely-removed">
<h3>No Path is Completely Removed<a class="headerlink" href="#no-path-is-completely-removed" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>So we prove that none of the paths are completely removed during the algorithm. The idea of the proof is to assume, by contradiction, that a path is completely removed, and then find a pseudo-augmenting path in the original graph, which will contradict the minimality of our partition.</p>
<p>For each vertex <span class="math notranslate nohighlight">\(a\)</span>, we call a vertex <span class="math notranslate nohighlight">\(b\)</span> the parent of <span class="math notranslate nohighlight">\(a\)</span> if <span class="math notranslate nohighlight">\(a\)</span> was removed in the algorithm due to the edge <span class="math notranslate nohighlight">\(ab\)</span>. That is, at some stage of the algorithm, <span class="math notranslate nohighlight">\(a,b\)</span> are both the first vertices of two paths, and the edge <span class="math notranslate nohighlight">\(ab\)</span> is a member of <span class="math notranslate nohighlight">\(P\)</span>, and according to the algorithm above, we remove vertex <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>For each vertex <span class="math notranslate nohighlight">\(a\)</span>, consider the path it is in, and call the vertex preceding <span class="math notranslate nohighlight">\(a\)</span> in that path (e.g., <span class="math notranslate nohighlight">\(b\)</span>) the chief of <span class="math notranslate nohighlight">\(a\)</span> (meaning <span class="math notranslate nohighlight">\(ba\)</span> is an edge in <span class="math notranslate nohighlight">\(M\)</span>).</p>
<p>Note that for any vertex <span class="math notranslate nohighlight">\(a\)</span>, the time of <span class="math notranslate nohighlight">\(a\)</span>'s removal is after the time of removal of the chief of <span class="math notranslate nohighlight">\(a\)</span>'s parent. This is because when <span class="math notranslate nohighlight">\(a\)</span> is removed by its parent, it must be the first vertex of a path. This means the chief of the parent (if it exists) was removed before this.</p>
<p>Now suppose at some stage, vertex <span class="math notranslate nohighlight">\(a\)</span> is removed, which is the end of a path from our partition. Start from vertex <span class="math notranslate nohighlight">\(a\)</span> and place a marker on <span class="math notranslate nohighlight">\(a\)</span>. At each step, if the marker is on <span class="math notranslate nohighlight">\(u\)</span>, first move the marker to the parent of <span class="math notranslate nohighlight">\(u\)</span>. If the parent of <span class="math notranslate nohighlight">\(u\)</span> is the start of one of the paths, we have found our pseudo-augmenting path. Otherwise, move the marker to the chief of the parent of <span class="math notranslate nohighlight">\(u\)</span>. Note two things:</p>
<ul class="simple">
<li><p>The process terminates because, as we said, after each step, the marker is placed on a vertex whose removal time in the algorithm is earlier.</p></li>
<li><p>At each step, the vertex with the marker has a parent. This is because this vertex is removed in our algorithm (because its removal time is earlier than <span class="math notranslate nohighlight">\(a\)</span>'s, and we said <span class="math notranslate nohighlight">\(a\)</span> is also removed).</p></li>
</ul>
<p>Thus, we were able to find a pseudo-augmenting path. As we said, the resulting contradiction shows that no path is completely removed!</p>
</section>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="5.html" style="float:left;" title="Maximum Flow and Matching" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="7.html" style="float:right;" title="Matching in General Graphs" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>