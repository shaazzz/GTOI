

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>BFS &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Trees" href="index.html" />
        <link rel="next" title="Algorithm for Finding Tree Diameter" href="6.html" />
        <link rel="prev" title="DFS" href="4.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">DFS</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; BFS</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/2/5.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="bfs">
<h1>BFS<a class="headerlink" href="#bfs" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>In this section, we introduce the BFS algorithm, which is a method for graph traversal, and discuss its properties.</p>
<section id="bfs-algorithm">
<h2>BFS Algorithm<a class="headerlink" href="#bfs-algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>First, we select a vertex (let's call it <cite>root</cite>) and place it in group <span class="math notranslate nohighlight">\(A_0\)</span>. Then, we place all its neighbors in group <span class="math notranslate nohighlight">\(A_1\)</span>.
In <span class="math notranslate nohighlight">\(A_2\)</span>, we place all neighbors of vertices in groups <span class="math notranslate nohighlight">\(A_0\)</span> and <span class="math notranslate nohighlight">\(A_1\)</span> that have not yet been assigned to any group. Similarly, in group <span class="math notranslate nohighlight">\(A_i\)</span>, we place all
vertices that are neighbors of vertices in groups <span class="math notranslate nohighlight">\(A_j\)</span> where <span class="math notranslate nohighlight">\(0 \leqslant j &lt; i\)</span>, and have not yet been assigned to any group.</p>
<p>Let <span class="math notranslate nohighlight">\(Dis_i\)</span> be the group number to which vertex <span class="math notranslate nohighlight">\(i\)</span> belongs (for example, <span class="math notranslate nohighlight">\(Dis_{root} = 0\)</span>).
It is clear that by this method, all vertices in the connected component of <cite>root</cite> will be assigned to groups. For simplicity, we assume the graph is connected, but everything we state is actually true for the connected component of <cite>root</cite>.</p>
<p>First, we prove that for any two vertices <span class="math notranslate nohighlight">\(i,j\)</span> connected by an edge, <span class="math notranslate nohighlight">\(1 \leqslant |Dis_{i}-Dis_{j}|\)</span>.</p>
<p>Proof: We use proof by contradiction. Assume there are two adjacent vertices <span class="math notranslate nohighlight">\(i,j\)</span> such that <span class="math notranslate nohighlight">\(Dis_{j} - Dis_{i} &gt; 1\)</span>. Now, consider the moment we were populating group
<span class="math notranslate nohighlight">\(A_{Dis_{i}+1}\)</span>. At that instant, <span class="math notranslate nohighlight">\(j\)</span> had not been assigned to any group and was a neighbor of <span class="math notranslate nohighlight">\(i\)</span>. Therefore, <span class="math notranslate nohighlight">\(j\)</span> should have been placed in group <span class="math notranslate nohighlight">\(A_{Dis_{i}+1}\)</span>. This leads to a contradiction, thus proving the theorem.
Thus, we can assume that in group <span class="math notranslate nohighlight">\(A_i\)</span>, we place all
vertices that are neighbors of vertices in group <span class="math notranslate nohighlight">\(A_{i-1}\)</span> and have not yet been assigned to any group.</p>
<figure class="align-left">
<a class="reference internal image-reference" href="../../_images/BFS_Groups.svg"><img alt="../../_images/BFS_Groups.svg" src="../../_images/BFS_Groups.svg" width="100%" /></a>
</figure>
<figure class="align-right">
<a class="reference internal image-reference" href="../../_images/BFS_Graph.svg"><img alt="../../_images/BFS_Graph.svg" src="../../_images/BFS_Graph.svg" width="100%" /></a>
</figure>
<p>Now we prove that <span class="math notranslate nohighlight">\(Dis_{i} = dis(i,root)\)</span>.</p>
<p>Proof: We use proof by contradiction. Consider a vertex that has the minimum <cite>Dis</cite> value and for which our claim does not hold (let's call it <cite>i</cite>).
Now, consider a neighbor <cite>j</cite> of <cite>i</cite> that lies on a path from <cite>i</cite> to <cite>root</cite> with <cite>dis(root,i)</cite> edges.
Since vertex <cite>i</cite> had the minimum <cite>Dis</cite> among vertices that violated the claim, <cite>j</cite> did not violate the claim. Therefore:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Dis_{j}=dis(root,i)-1\)</span></p></li>
<li><p>And since <span class="math notranslate nohighlight">\(Dis_{i} &gt; Dis_{j}\)</span> and <span class="math notranslate nohighlight">\(1 \leqslant |Dis_{i}-Dis_{j}|\)</span>, then:</p></li>
<li><p><span class="math notranslate nohighlight">\(Dis_{i} = Dis_{j}+1\)</span></p></li>
</ul>
<p>This leads to a contradiction, thus proving the theorem.</p>
<p>Now we slightly modify the algorithm and prove that it achieves the same result:</p>
<p>We create a new group called B, initially placing the <cite>root</cite> vertex in it. Then, as long as B is not empty, we perform the following steps:</p>
<p>Consider a vertex in B with the minimum <cite>Dis</cite> value (let's call it <cite>i</cite>). We remove <cite>i</cite> from B. Then, for all its neighbors that have not yet been assigned to any A group, we place them in group <span class="math notranslate nohighlight">\(A_{Dis_i} + 1\)</span> and also add them to B.
This algorithm is similar to the previous one, but instead of considering all vertices in <span class="math notranslate nohighlight">\(A_i\)</span> together and placing all their unassigned neighbors into the next group,
we iterate through the vertices within group <span class="math notranslate nohighlight">\(A_i\)</span> in an arbitrary order. Each vertex for the next group <span class="math notranslate nohighlight">\(A_{i+1}\)</span> is added as soon as we encounter one of its neighbors in <span class="math notranslate nohighlight">\(A_i\)</span>.
It is clear that when a vertex enters B, its <cite>Dis</cite> value is greater than or equal to the <cite>Dis</cite> values of other vertices already in B. Therefore, if we maintain the vertices in B in their order of entry (i.e., using a FIFO queue), we effectively always take the vertex from the front of B, remove it, and add its unvisited neighbors to the back of B.</p>
</section>
<section id="bfs-tree">
<h2>BFS Tree<a class="headerlink" href="#bfs-tree" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Consider the moment when the BFS algorithm finishes (i.e., when each vertex has been assigned to a group). Now, for each vertex <cite>i</cite>, we arbitrarily choose <span class="math notranslate nohighlight">\(par_i\)</span> to be one of <cite>i</cite>'s neighbors, say <cite>j</cite>, such that
<span class="math notranslate nohighlight">\(Dis_{i} = Dis_{j}+1\)</span> (it's clear that <cite>par</cite> is not defined for <cite>root</cite>, but it is certainly defined for every other vertex). Then, for every vertex except <cite>root</cite>, we keep the edge between <cite>i</cite> and <span class="math notranslate nohighlight">\(par_i\)</span> and remove all other edges. The number of remaining edges is <cite>n-1</cite>, and every vertex has a path to <cite>root</cite> (why?). Thus, our new graph is connected and is therefore a tree.</p>
<figure class="align-left">
<a class="reference internal image-reference" href="../../_images/BFS_Tree.svg"><img alt="../../_images/BFS_Tree.svg" src="../../_images/BFS_Tree.svg" width="100%" /></a>
</figure>
<p>In fact, the BFS tree can be considered a spanning subtree of the graph, &quot;hanging&quot; from the <cite>root</cite>, and possessing the following two characteristics:</p>
<ul class="simple">
<li><p>For any vertex <cite>i</cite>, <span class="math notranslate nohighlight">\(dis(root,i) = h_i\)</span> (<span class="math notranslate nohighlight">\(h_i\)</span> is the height of vertex <cite>i</cite> when the tree is rooted at <cite>root</cite>).</p></li>
<li><p>For any edge in the <strong>original graph</strong>, the difference in height between its two endpoints is at most one.</p></li>
</ul>
<p>In addition to its uses in programming, where it might be helpful in certain problems, the BFS tree can also be instrumental in solving some theoretical problems, which we demonstrate in the two examples below.</p>
</section>
<section id="bfs-code">
<h2>BFS Code<a class="headerlink" href="#bfs-code" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Input format: First, two integers <cite>n</cite> and <cite>m</cite> are given, representing the number of vertices and edges in the graph, respectively. Then, in the next <cite>m</cite> lines, two integers <cite>i</cite> and <cite>j</cite> are provided,
indicating that an edge exists between <cite>i</cite> and <cite>j</cite> in the graph.</p>
<p>We need to print <cite>n</cite> numbers, where the <cite>i</cite>-th number is equal to <span class="math notranslate nohighlight">\(dis(1,i)\)</span>. The graph is guaranteed to be connected, ensuring that the distance of each vertex from vertex 1 is a valid number.</p>
<p>Solution:</p>
<p>We use a <cite>queue</cite> in the code, which is a First-In-First-Out (FIFO) data structure. A queue has many capabilities, but the ones we use are listed below:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(queue&lt;int&gt;q\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(q.size( )\)</span> returns the number of elements in <cite>q</cite>.</p></li>
<li><p><span class="math notranslate nohighlight">\(q.front( )\)</span> returns the value of the element at the front of <cite>q</cite>.</p></li>
<li><p><span class="math notranslate nohighlight">\(q.pop( )\)</span> removes the element from the front of <cite>q</cite>.</p></li>
<li><p><span class="math notranslate nohighlight">\(q.push(x)\)</span> adds <cite>x</cite> to the back of <cite>q</cite>.</p></li>
<li><p>The queue effectively plays the role of group B for us.</p></li>
</ul>
<p>We also use a <cite>Mark</cite> array, whose initial value for each vertex is zero. If a vertex enters B, its <cite>Mark</cite> value becomes 1.
And we use the <cite>Dis</cite> array to store the answer (distance) for each vertex.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="c1">// hadeaksar meghdare n</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="c1">// tedad ras ha va tedad yal ha</span>
<span class="kt">int</span><span class="w"> </span><span class="n">Dis</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//javab har ras</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">Mark</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//neshan midahad aya yek ras tabehal varede queue shode ya na</span>
<span class="n">queue</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="c1">// toozihe un neveshte shode</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">maxn</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="c1">//list hamsaye haye har ras dar un neveshte shode</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">root</span><span class="p">){</span><span class="c1">//fasele harki az root bedast khahad amad</span>
<span class="w">    </span><span class="n">Dis</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// dis(root , root) = 0</span>
<span class="w">    </span><span class="n">Mark</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span><span class="c1">//ta zamani ke dakhele q ras hast while ra edame bede</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">//rasi dar q ke kamtarin Dis ra darad</span>
<span class="w">        </span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"> </span><span class="c1">//hazfe un</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//hamsaye haye i ra negah mikonim va agar ta be hal vared q nashodan vared mikonim</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">              </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">Mark</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span><span class="w"></span>
<span class="w">                  </span><span class="n">Mark</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                  </span><span class="n">Dis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                  </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">//list hamsaye haye ras ha ra por mikonim</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">bfs</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//yani be ezaye root = 1 tabe bfs ra seda bezan</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//chupe khrooji</span>
<span class="w">       </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this algorithm, each vertex enters <cite>q</cite> at most once, and each edge is processed at most once for each of its endpoints. Therefore, our algorithm has a time complexity of <span class="math notranslate nohighlight">\(O(n+m)\)</span>.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In this section, we introduced the BFS algorithm and its properties. Some of the most important applications of BFS include:</p>
<ul class="simple">
<li><p>Finding the distance of every vertex from a specific root vertex.</p></li>
<li><p>Finding all vertices within the connected component of a specific vertex (and thus determining if the graph is connected or not).</p></li>
<li><p>Graph traversal for a specific purpose.</p></li>
<li><p>Utilizing the concepts of BFS and the BFS tree in solving theoretical problems.</p></li>
</ul>
<p>It is highly recommended to refer to the exercises in this section for a deeper understanding.</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="4.html" style="float:left;" title="DFS" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="6.html" style="float:right;" title="Algorithm for Finding Tree Diameter" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>