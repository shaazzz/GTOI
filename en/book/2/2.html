

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Distance in Tree and Graph &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Trees" href="index.html" />
        <link rel="next" title="Counting the Number of Trees" href="3.html" />
        <link rel="prev" title="Introductory Properties" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introductory Properties</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Distance in Tree and Graph</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/2/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="distance-in-tree-and-graph">
<h1>Distance in Tree and Graph<a class="headerlink" href="#distance-in-tree-and-graph" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>In this section, by introducing distance in a graph, we will examine definitions related to distance, both in its general form and in its specific form (i.e., in a tree). In trees, discussing distance is much easier than in general graphs, because, as we discussed in the previous section, the path between any two vertices in a tree is unique.</p>
<section id="what-is-distance">
<h2>What is Distance?<a class="headerlink" href="#what-is-distance" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Consider two vertices <span class="math notranslate nohighlight">\(u,v\)</span> in a graph. The distance between these two vertices is defined as the length (number of edges) of the shortest path between them.</p>
<p>Note: If two vertices are in two separate connected components, their distance is infinite.</p>
<p>The distance between two vertices <span class="math notranslate nohighlight">\(u,v\)</span> is denoted as <span class="math notranslate nohighlight">\(d(u,v)\)</span>.</p>
</section>
<section id="diameter">
<h2>Diameter<a class="headerlink" href="#diameter" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Definition: The diameter of a graph is equal to
<span class="math notranslate nohighlight">\(Max_{u,v} d(u,v)\)</span>,
or in other words, the maximum pairwise distance between vertices in the graph.</p>
<p>Note that the diameter is not the longest path; it is actually the longest <strong>distance</strong>. However, in a tree, the longest path and the diameter are the same. This is because if you take the two endpoints of the longest path, since there is exactly one path between them, and that is the longest path, its length is equal to the distance between those two vertices. Thus, the diameter is equal to the longest path.
The difference between the longest path and the diameter becomes apparent when, in the general case, finding the diameter of a graph is solvable in polynomial time, but finding the longest path is an NP-hard problem.</p>
</section>
<section id="eccentricity">
<h2>Eccentricity<a class="headerlink" href="#eccentricity" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>If we consider the vertex name as <span class="math notranslate nohighlight">\(u\)</span>, the eccentricity of <span class="math notranslate nohighlight">\(u\)</span> is equal to the maximum <span class="math notranslate nohighlight">\(d(u,v)\)</span> for all <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>If the graph is a tree and we root the tree at <span class="math notranslate nohighlight">\(u\)</span>, the eccentricity of <span class="math notranslate nohighlight">\(u\)</span> becomes the height of the vertex with the greatest height in the tree.</p>
<p>The eccentricity of vertex <span class="math notranslate nohighlight">\(u\)</span> is denoted by <span class="math notranslate nohighlight">\(\varepsilon{(u)}\)</span>.</p>
</section>
<section id="theorem-2-2-1">
<h2>Theorem 2.2.1<a class="headerlink" href="#theorem-2-2-1" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Theorem Statement: In a tree, the eccentricity of a vertex is equal to its maximum distance from the two endpoints of a diameter.</p>
<p>Proof: We use proof by contradiction. Assume our vertex is <span class="math notranslate nohighlight">\(a\)</span>, and the two endpoints of the diameter are vertices <span class="math notranslate nohighlight">\(u, v\)</span>. The vertex whose distance from <span class="math notranslate nohighlight">\(a\)</span> is equal to <span class="math notranslate nohighlight">\(\varepsilon(a)\)</span> is named <span class="math notranslate nohighlight">\(b\)</span>. It is clear that if <span class="math notranslate nohighlight">\(a\)</span> were one of the diameter's endpoints, the claim would be true, so we assume it is not.</p>
<p>We root the tree at <span class="math notranslate nohighlight">\(a\)</span>. Let <span class="math notranslate nohighlight">\(mh\)</span> be the vertex with the maximum height such that the three vertices <span class="math notranslate nohighlight">\(b,u,v\)</span> are within its subtree.
Since <span class="math notranslate nohighlight">\(mh\)</span> has the greatest height among the common ancestors of these three vertices, either <span class="math notranslate nohighlight">\(mh = b\)</span>, or a child of <span class="math notranslate nohighlight">\(mh\)</span> that is an ancestor of <span class="math notranslate nohighlight">\(b\)</span> does not have at least one of the two vertices <span class="math notranslate nohighlight">\(u, v\)</span> in its subtree. This means <span class="math notranslate nohighlight">\(mh = lca(u,b)\)</span> or <span class="math notranslate nohighlight">\(lca(v,b)\)</span>. Without loss of generality, assume <span class="math notranslate nohighlight">\(mh = lca(u,b)\)</span>. Now we prove that <span class="math notranslate nohighlight">\(d(b,u)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span>.
By proving this part, the contradiction obtained regarding the length of the diameter will prove the theorem.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(d(b,u)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(mh = lca(b,u)\)</span> <span class="math notranslate nohighlight">\(\longrightarrow\)</span>  <span class="math notranslate nohighlight">\(h(b)+h(u)-2 \times h(Mh)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span></p></li>
<li><p>Even if <span class="math notranslate nohighlight">\(mh \neq lca(u,v)\)</span>, it is still their common ancestor, so <span class="math notranslate nohighlight">\(d(u,v)\)</span> <span class="math notranslate nohighlight">\(\leqslant\)</span> <span class="math notranslate nohighlight">\(h(u)+h(v)-2 \times h(mh)\)</span></p></li>
<li><p>Consequently:
<span class="math notranslate nohighlight">\(h(B) + h(u) - 2 \times h(mh) &gt; h(u) + h(v) - 2 \times h(mh) \longrightarrow h(B) &gt; h(u)\)</span>
which is the premise of the question, so the statement is true. The theorem is proven by the obtained contradiction.</p></li>
</ul>
</section>
<section id="radius-and-center">
<h2>Radius and Center<a class="headerlink" href="#radius-and-center" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>The vertex with the minimum eccentricity among the graph's vertices is called the graph's center, and its eccentricity is called the graph's radius.</p>
</section>
<section id="theorem-2-2-2">
<h2>Theorem 2.2.2<a class="headerlink" href="#theorem-2-2-2" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li><ol class="loweralpha simple">
<li><p>In a tree, if the diameter is <span class="math notranslate nohighlight">\(Q\)</span>, the radius is <span class="math notranslate nohighlight">\(\lceil{Q/2}\rceil\)</span>.</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="2">
<li><p>In a tree, if <span class="math notranslate nohighlight">\(Q\)</span> is odd, the two middle vertices of the diameter path are centers, and if <span class="math notranslate nohighlight">\(Q\)</span> is even, the single middle vertex is the center.</p></li>
</ol>
</li>
</ul>
<p>Proof: First, we prove that a vertex not on the diameter path cannot be a center. Consider a vertex <span class="math notranslate nohighlight">\(u\)</span> that is not on the diameter path, and let <span class="math notranslate nohighlight">\(v\)</span> be a vertex on the diameter path such that its distance to <span class="math notranslate nohighlight">\(u\)</span> is minimized. According to Theorem 2.2.1, we can deduce that <span class="math notranslate nohighlight">\(\varepsilon{(u)} = \varepsilon{(v)} + d(u,v)\)</span>. Thus, <span class="math notranslate nohighlight">\(u\)</span> is certainly not a center.
Now, let's number the vertices along the diameter path from one end (i.e., from 0 to <span class="math notranslate nohighlight">\(Q\)</span>). According to Theorem 2.2.1, we know that the eccentricity of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex on the diameter path is equal to <span class="math notranslate nohighlight">\(max(i,Q-i)\)</span>.
We know that the minimum of the above expression occurs when <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(Q-i\)</span> have the smallest possible difference.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(Q\)</span> is even, the answer becomes <span class="math notranslate nohighlight">\(max(Q - Q/2 , Q/2)\)</span> = <span class="math notranslate nohighlight">\(Q/2\)</span>. So the radius is <span class="math notranslate nohighlight">\(Q/2\)</span>, and the only center is the middle vertex of the diameter (the <span class="math notranslate nohighlight">\(Q/2\)</span>-th vertex on the diameter path).</p></li>
<li><p>If <span class="math notranslate nohighlight">\(Q\)</span> is odd, the radius becomes <span class="math notranslate nohighlight">\(max((Q-1)/2 , (Q+1)/2)\)</span> = <span class="math notranslate nohighlight">\((Q+1)/2\)</span>. The only vertices on the diameter path with this property are the <span class="math notranslate nohighlight">\((Q-1)/2\)</span> and <span class="math notranslate nohighlight">\((Q+1)/2\)</span> vertices.</p></li>
</ul>
</section>
<section id="centroid">
<h2>Centroid<a class="headerlink" href="#centroid" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>A vertex in a graph whose sum of distances from other vertices is minimized is called the graph's centroid. Similar to the definitions above, the centroid in a tree also has an interesting property, as stated in the following theorem.</p>
</section>
<section id="theorem-2-2-3">
<h2>Theorem 2.2.3<a class="headerlink" href="#theorem-2-2-3" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li><ol class="loweralpha simple">
<li><p>In a tree, a vertex is a centroid if and only if, when it is removed from the tree, the size of every connected component is less than or equal to <span class="math notranslate nohighlight">\(n/2\)</span>.</p></li>
</ol>
</li>
<li><ol class="loweralpha simple" start="2">
<li><p>In a tree, there are at most two centroids. If there are two, the graph has an even number of vertices, and the two centroids are adjacent.</p></li>
</ol>
</li>
</ul>
<p>Proof: We number the vertices, and <span class="math notranslate nohighlight">\(a_i\)</span> will be the sum of distances of vertex <span class="math notranslate nohighlight">\(i\)</span> from other vertices. First, we prove the &quot;if&quot; part of (a). Assume <span class="math notranslate nohighlight">\(u\)</span> is a centroid, and when we remove it, a connected component with size greater than <span class="math notranslate nohighlight">\(n/2\)</span> is formed. Now, consider a vertex <span class="math notranslate nohighlight">\(v\)</span> from that component that is adjacent to <span class="math notranslate nohighlight">\(u\)</span>. The distance of <span class="math notranslate nohighlight">\(v\)</span> from the vertices inside this connected component is one less than the distance of <span class="math notranslate nohighlight">\(u\)</span> from them. For other vertices, its distance is one more than the distance of <span class="math notranslate nohighlight">\(u\)</span>. So,
<span class="math notranslate nohighlight">\(a_v = a_u - sz + (n-sz)\)</span>
where <span class="math notranslate nohighlight">\(sz\)</span> is the size of that connected component.
Since
<span class="math notranslate nohighlight">\(sz &gt; n/2 \longrightarrow n - 2 \times sz &lt; 0 \longrightarrow a_v &lt; a_u\)</span>
This contradicts the assumption that <span class="math notranslate nohighlight">\(u\)</span> is a centroid, thus proving the &quot;if&quot; part of (a).</p>
<p>Now, I will prove that for any two vertices <span class="math notranslate nohighlight">\(i, j\)</span> that satisfy the &quot;if&quot; part of condition (a), <span class="math notranslate nohighlight">\(a_i = a_j\)</span>. Since we know that our centroid satisfies the &quot;if&quot; part of (a), it follows that all vertices with the property from (a) are centroids.
We root the tree at vertex <span class="math notranslate nohighlight">\(i\)</span>. Now we have a variable named <span class="math notranslate nohighlight">\(A\)</span> such that when we are at vertex <span class="math notranslate nohighlight">\(z\)</span>, <span class="math notranslate nohighlight">\(A = a_z\)</span>. Initially, <span class="math notranslate nohighlight">\(A = a_i\)</span>. Now, we move from the root vertex <span class="math notranslate nohighlight">\(i\)</span> towards vertex <span class="math notranslate nohighlight">\(j\)</span> (i.e., we traverse the path between these two vertices, starting from <span class="math notranslate nohighlight">\(i\)</span>). When we move from a vertex to its child, <span class="math notranslate nohighlight">\(A\)</span> decreases by the size of the child's subtree and increases by the number of vertices minus the size of the child's subtree.
We know that the size of the subtree rooted at <span class="math notranslate nohighlight">\(j\)</span> is greater than or equal to <span class="math notranslate nohighlight">\(n/2\)</span>, because when we remove <span class="math notranslate nohighlight">\(j\)</span> from the tree, the size of the connected component containing its parent is, by assumption, less than or equal to <span class="math notranslate nohighlight">\(n/2\)</span>. Therefore, the number of vertices not in this component (including <span class="math notranslate nohighlight">\(j\)</span>) is greater than or equal to <span class="math notranslate nohighlight">\(n/2\)</span>. Thus, the size of the subtree of all ancestors of <span class="math notranslate nohighlight">\(j\)</span> that we traversed is also greater than or equal to <span class="math notranslate nohighlight">\(n/2\)</span>. From this, we can conclude that the value of <span class="math notranslate nohighlight">\(A\)</span> always either decreases or remains unchanged.
So, <span class="math notranslate nohighlight">\(a_i \geq a_j\)</span>. If we also root the tree at <span class="math notranslate nohighlight">\(j\)</span> and traverse the path between them, we would reach the conclusion <span class="math notranslate nohighlight">\(a_j \geq a_i\)</span>. Consequently, <span class="math notranslate nohighlight">\(a_i = a_j\)</span>.</p>
<p>Now, we move to proving part (b). Assume two vertices <span class="math notranslate nohighlight">\(i,j\)</span> are centroids. We root the tree at <span class="math notranslate nohighlight">\(i\)</span> and follow the algorithm described above. Now, we say that when we move from a vertex to its child, <span class="math notranslate nohighlight">\(A\)</span> does not change if and only if the size of the child's subtree is exactly <span class="math notranslate nohighlight">\(n/2\)</span>. Since the size of <span class="math notranslate nohighlight">\(j\)</span>'s subtree is greater than or equal to <span class="math notranslate nohighlight">\(\lceil{n/2}\rceil\)</span>, for <span class="math notranslate nohighlight">\(A\)</span> not to change along the entire path, <span class="math notranslate nohighlight">\(j\)</span> must be a child of <span class="math notranslate nohighlight">\(i\)</span>, and the size of its subtree must be exactly <span class="math notranslate nohighlight">\(n/2\)</span>. This implies that the tree has an even number of vertices, because the size of <span class="math notranslate nohighlight">\(j\)</span>'s subtree is greater than or equal to <span class="math notranslate nohighlight">\(\lceil{n/2}\rceil\)</span>, and the size of the subtrees of <span class="math notranslate nohighlight">\(i\)</span>'s children must be less than or equal to <span class="math notranslate nohighlight">\(\lfloor{n/2}\rfloor\)</span>. Therefore, it must be that <span class="math notranslate nohighlight">\(\lfloor{n/2}\rfloor = \lceil{n/2}\rceil\)</span>, which means <span class="math notranslate nohighlight">\(n\)</span> is even.
We also understood above that if there are two centroids, they must be adjacent. It is then clear that we can have at most two centroids, otherwise we would have a cycle.</p>
</section>
<section id="sum-of-distances">
<h2>Sum of Distances<a class="headerlink" href="#sum-of-distances" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose in a problem, the goal is to minimize or maximize the sum of distances between every two vertices. Let's call this sum the graph's density. Intuitively, the lower the graph's density, the more compact the graph, and the higher the density, the more spread out the graph.</p>
<p>Furthermore, for the distance to be defined, let's assume our discussion focuses on connected graphs.</p>
<section id="minimizing-graph-density">
<h3>Minimizing Graph Density<a class="headerlink" href="#minimizing-graph-density" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>The distance between two vertices is at least 1. In a graph <span class="math notranslate nohighlight">\(K_n\)</span>, the distance between any two vertices is exactly 1. Thus, the minimum possible density is achieved in <span class="math notranslate nohighlight">\(K_n\)</span>, which is equal to <span class="math notranslate nohighlight">\(n \choose 2\)</span>.</p>
<p>Now, if we restrict the domain of discussion to trees, the problem becomes a bit harder. However, we can still deduce the following:</p>
<ul class="simple">
<li><p>Exactly <span class="math notranslate nohighlight">\(n-1\)</span> pairs of vertices have a distance of exactly 1. This is because a tree has <span class="math notranslate nohighlight">\(n-1\)</span> edges.</p></li>
<li><p>Any pair of vertices that are not adjacent have a distance of at least 2.</p></li>
</ul>
<p>Consequently, the minimum possible density is at least <span class="math notranslate nohighlight">\(2 \times {n \choose 2} - (n-1)\)</span>. The only example that satisfies this bound is a scenario where the distance between any two vertices is <strong>at most</strong> 2. The only tree with this property is the star graph (as shown in the figure). This is because if there were two leaves in a star graph that did not share a common parent, their distance would be at least 3.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/S_7.svg"><img alt="If the user's internet connection is bad, this will appear" src="../../_images/S_7.svg" width="50%" /></a>
</figure>
</section>
<section id="maximizing-graph-density">
<h3>Maximizing Graph Density<a class="headerlink" href="#maximizing-graph-density" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>In this case, note that if we remove an edge and this removal does not disconnect the graph, we should do so. This is because removing an edge increases the density (why?). Therefore, a graph with maximum density should be sought among trees (since, as we said, all its edges must be cut edges).</p>
<p>Now consider a specific vertex, say <span class="math notranslate nohighlight">\(u\)</span>. We claim that the sum of distances from all vertices to <span class="math notranslate nohighlight">\(u\)</span> is at most <span class="math notranslate nohighlight">\(n \choose 2\)</span>.</p>
<p>To prove this, assume the tree is rooted at <span class="math notranslate nohighlight">\(u\)</span>, and for each height, we know how many vertices are at that height, with <span class="math notranslate nohighlight">\(H\)</span> being the maximum height. In this case, for every height from 0 to <span class="math notranslate nohighlight">\(H\)</span>, we must have at least one vertex at that height. Now, if we had at least two vertices at one height, one of them could be moved to a higher height, and in doing so, the sum of heights would increase. By repeating this process, we reach a state where there is exactly one vertex at each height from 0 to <span class="math notranslate nohighlight">\(n-1\)</span> (i.e., the tree has become a path). In this state, the sum of distances from <span class="math notranslate nohighlight">\(u\)</span> will be <span class="math notranslate nohighlight">\(1 + 2 + ... + (n-1) = {n \choose 2}\)</span>. Thus, we have proven that the sum of distances from any vertex <span class="math notranslate nohighlight">\(u\)</span> is at most <span class="math notranslate nohighlight">\(n \choose 2\)</span>.</p>
<p>So now, to reach a bound, at each step, remove a <strong>leaf</strong> from the tree and calculate the sum of distances from this leaf. The sum of all these values will be the graph's density, which, according to what we said, will be at most <span class="math notranslate nohighlight">\(\sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3}\)</span> (according to Chu-Shih-Chieh's identity).</p>
<p>It can be concluded that the only graph that satisfies this bound with equality is the path graph.</p>
</section>
</section>
<section id="support-tree">
<h2>Support Tree<a class="headerlink" href="#support-tree" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose we have a communication network connecting <span class="math notranslate nohighlight">\(n\)</span> cities. For assurance, we have also prepared a support communication network, to be used if there is a disruption in the main network, to prevent communication loss.</p>
<p>In graph theory terms, we have two <span class="math notranslate nohighlight">\(n\)</span>-vertex trees <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span>. We want to prove that if one of the edges of <span class="math notranslate nohighlight">\(T\)</span>, say <span class="math notranslate nohighlight">\(uv\)</span>, is cut, we can add one of the edges of <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span>, say <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span>, to tree <span class="math notranslate nohighlight">\(T\)</span> such that the structure remains connected.</p>
<p>So, assume we removed <span class="math notranslate nohighlight">\(uv\)</span> from <span class="math notranslate nohighlight">\(T\)</span>. In this case, our tree will have two connected components. Let's consider one component blue and the other red. Now, in tree <span class="math notranslate nohighlight">\(T^{\prime}\)</span>, a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> can be found.
On this path, there will be an edge that has one endpoint in the blue component and the other in the red component (why?). Now, if this edge is <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span>, we can add this edge to <span class="math notranslate nohighlight">\(T\)</span> and reconnect it!</p>
</section>
<section id="partitioning-a-tree-into-paths">
<h2>Partitioning a Tree into Paths<a class="headerlink" href="#partitioning-a-tree-into-paths" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Consider a tree <span class="math notranslate nohighlight">\(T\)</span>. In this section, our goal is to partition the edges of this tree into the minimum possible number of paths. For better intuition, imagine we remove the edges of the paths one by one from the tree until we are left with a graph without edges.</p>
<p>First of all, note that after removing each path, only the parity of the degrees of the two endpoints of the path changes. Also, at the end, the degree of all vertices will be even (zero). So, an odd-degree vertex must be selected as an endpoint an odd number of times, and an even-degree vertex an even number of times. Therefore, if the number of odd-degree vertices in the tree is <span class="math notranslate nohighlight">\(X\)</span>, then we need at least <span class="math notranslate nohighlight">\(\frac X 2\)</span> paths. (We know that the number of odd-degree vertices in any graph is even, so <span class="math notranslate nohighlight">\(X\)</span> is even).</p>
<p>Now, if we remove a path between two odd-degree vertices at each step, we can reach the optimal state! We only need to ensure that our two odd-degree vertices belong to the same connected component.</p>
<p>Now, the question that arises is: how did being a tree help us in this process?</p>
<p>Ultimately, we used the fact that if a tree has no odd-degree vertices, it has no edges (however, this theorem does not hold for graphs in general). This is because if a graph has at least two vertices, it will have a leaf with degree 1 (which is odd).</p>
</section>
<section id="covering-tree-edges-with-paths">
<h2>Covering Tree Edges with Paths<a class="headerlink" href="#covering-tree-edges-with-paths" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In this section, we want to find the minimum number of paths whose union covers all edges of <span class="math notranslate nohighlight">\(T\)</span>. This problem is similar to the previous case, with the difference that in the previous case, we partitioned the edges into paths, meaning each edge belonged to exactly one path. Here, we have the freedom for an edge to be covered by multiple paths. We can conclude that the answer to this problem is less than or equal to the answer to the previous problem.</p>
<p>At first glance, you realize that since lengthening paths does not harm us, an optimal state exists where the two endpoints of each path are leaves!</p>
<p>On the other hand, for each leaf, consider the edge that connects this leaf to its adjacent vertex. Each path covers at most 2 of these edges. So, if we have <span class="math notranslate nohighlight">\(X\)</span> leaves, we need at least <span class="math notranslate nohighlight">\(\frac X 2\)</span> paths. Now we try to meet this bound. That is, if <span class="math notranslate nohighlight">\(X\)</span> is even, we cover the edges with <span class="math notranslate nohighlight">\(\frac X 2\)</span> paths, and if <span class="math notranslate nohighlight">\(X\)</span> is odd, with <span class="math notranslate nohighlight">\(\frac {X+1} 2\)</span> paths.</p>
<p>So, at each step, after selecting a path, we try to transform our tree into a tree with two fewer leaves (of course, when <span class="math notranslate nohighlight">\(X\)</span> is odd, we cannot do this in the final step). If we can do this, the number of paths we selected will be half the number of leaves, as we wanted.</p>
<p>Consider two arbitrary leaves, say <span class="math notranslate nohighlight">\(u,v\)</span>, and root the tree from this path. First, select this path (which covers the edges between <span class="math notranslate nohighlight">\(u,v\)</span>). Assume the vertices on our path are <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span>. Now we construct a new tree that has a single vertex instead of <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span>! There is an edge between this new vertex and a vertex like <span class="math notranslate nohighlight">\(w\)</span> if and only if there is an edge between <span class="math notranslate nohighlight">\(w\)</span> and one of <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span>. (Intuitively, it's like compressing all vertices on the path into a single vertex). Now, each path in our new graph corresponds to a path in the original graph, and now we just need to cover all edges in the new tree with paths!</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_1.svg"><img alt="Initial tree" src="../../_images/Tree_to_Path_1.svg" width="50%" /></a>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_2.svg"><img alt="Tree after compressing an edge" src="../../_images/Tree_to_Path_2.svg" width="50%" /></a>
</figure>
<p>So, at each step, we compress a path whose endpoints are leaves and turn it into a single vertex. In each step, the number of leaves in our new graph decreases by two, unless the newly added compressed vertex is itself a leaf. This happens if all vertices on the path between <span class="math notranslate nohighlight">\(u,v\)</span> have degree 2, except for one of them which must have degree 3. We call a pair <span class="math notranslate nohighlight">\(u,v\)</span> an incompatible pair if the path between them has such a property.</p>
<p>So, if at each step we can choose two leaves <span class="math notranslate nohighlight">\(u,v\)</span> such that they are not an incompatible pair, we do so (which reduces the number of leaves by 2 after compression). What if we cannot do this? In this case, we claim that there is only one vertex of degree 3, and the remaining vertices have degree 1 or 2 (why?). In this situation, as you can see in the figure, our tree will have exactly 3 leaves, and we can cover it with 2 paths.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_3.svg"><img alt="Final tree" src="../../_images/Tree_to_Path_3.svg" width="50%" /></a>
</figure>
</section>
<section id="tree-embedding">
<h2>Tree Embedding<a class="headerlink" href="#tree-embedding" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Suppose we have an <span class="math notranslate nohighlight">\(n\)</span>-vertex tree called <span class="math notranslate nohighlight">\(T\)</span>. We also have a graph <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span>. We want to prove that a subset of edges of <span class="math notranslate nohighlight">\(G\)</span> exists that forms <span class="math notranslate nohighlight">\(T\)</span>. (Intuitively, a tree <span class="math notranslate nohighlight">\(T\)</span> can be found in graph <span class="math notranslate nohighlight">\(G\)</span>).</p>
<p>Consider an arbitrary leaf <span class="math notranslate nohighlight">\(u\)</span> whose only neighbor is <span class="math notranslate nohighlight">\(v\)</span>, and remove <span class="math notranslate nohighlight">\(u\)</span> from the tree! Then, inductively find the tree <span class="math notranslate nohighlight">\(T-u\)</span> in <span class="math notranslate nohighlight">\(G\)</span>. Now we want to add the edge <span class="math notranslate nohighlight">\(uv\)</span> to our tree. Assume vertex <span class="math notranslate nohighlight">\(v\)</span> in graph <span class="math notranslate nohighlight">\(G\)</span> corresponds to <span class="math notranslate nohighlight">\(v^{\prime}\)</span>. Now, it is sufficient to choose a vertex among the neighbors of <span class="math notranslate nohighlight">\(v^{\prime}\)</span> that has not been previously mapped to any vertex of the tree. Then, this vertex can be mapped to <span class="math notranslate nohighlight">\(u\)</span>, which proves our inductive hypothesis.</p>
<p>To find such a vertex, it is sufficient to use the assumption <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span>. So <span class="math notranslate nohighlight">\(v^{\prime}\)</span> has at least <span class="math notranslate nohighlight">\(n-1\)</span> neighbors, and at most <span class="math notranslate nohighlight">\(n-2\)</span> of them have previously been mapped to vertices of the tree. Therefore, at least one of <span class="math notranslate nohighlight">\(v\)</span>'s neighbors has not been mapped to any vertex of the tree yet, to which we can now map <span class="math notranslate nohighlight">\(u\)</span> as discussed.</p>
<p>This problem was presented to familiarize you with the inductive structure of trees. You saw how a leaf can be removed from a tree and the inductive hypothesis applied to the remaining tree.</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:left;" title="Introductory Properties" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="3.html" style="float:right;" title="Counting the Number of Trees" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>