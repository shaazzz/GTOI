

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Counting the Number of Trees &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Trees" href="index.html" />
        <link rel="next" title="DFS" href="4.html" />
        <link rel="prev" title="Distance in Tree and Graph" href="2.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Counting the Number of Trees</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/2/3.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="counting-the-number-of-trees">
<h1>Counting the Number of Trees<a class="headerlink" href="#counting-the-number-of-trees" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>Counting the number of <span class="math notranslate nohighlight">\(n\)</span>-vertex trees is one of the most fascinating problems in combinatorics, with diverse and creative approaches. In this section, the discussion focuses on trees with labeled vertices. (You can think of them as the number of spanning subgraphs of the complete graph <span class="math notranslate nohighlight">\(K_n\)</span> that are trees). We will, in fact, prove by several methods that the number of <span class="math notranslate nohighlight">\(n\)</span>-vertex trees is equal to <span class="math notranslate nohighlight">\(n^{n-2}\)</span>. Before reading the solution to each section, read the hints and try to devise your own solution.</p>
<section id="counting-with-degree-sequence">
<h2>Counting with Degree Sequence<a class="headerlink" href="#counting-with-degree-sequence" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="hint">
<h3>Hint<a class="headerlink" href="#hint" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Provide a formula that counts the number of trees with a degree sequence <span class="math notranslate nohighlight">\(d_1, d_2, ..., d_n\)</span>. To prove this formula, we will inductively remove leaves!</p>
</section>
<section id="solution">
<h3>Solution<a class="headerlink" href="#solution" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>The desired formula is
<span class="math notranslate nohighlight">\(\frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_n-1)!}\)</span>
. Note that
<span class="math notranslate nohighlight">\(\sum (d_i-1)\)</span>
is equal to <span class="math notranslate nohighlight">\(n-2\)</span>, so the above expression is in fact a multinomial coefficient!</p>
<p>To prove the formula, use induction on <span class="math notranslate nohighlight">\(n\)</span>. As a base case, consider that for <span class="math notranslate nohighlight">\(n \leq 2\)</span>, the formula holds. Now, it is sufficient to consider a specific leaf (a vertex like <span class="math notranslate nohighlight">\(u\)</span> where <span class="math notranslate nohighlight">\(d_u = 1\)</span>). Then, consider cases for its unique neighbor. If the unique neighbor of vertex <span class="math notranslate nohighlight">\(u\)</span> is vertex <span class="math notranslate nohighlight">\(v\)</span> (note that since <span class="math notranslate nohighlight">\(n &gt; 2\)</span>, we can conclude that <span class="math notranslate nohighlight">\(v\)</span> should not be a leaf), then the number of possible trees in this case is
<span class="math notranslate nohighlight">\(\frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_v-2)! (d_n-1)!}\)</span>
. As we said, the above expression is similar to a multinomial coefficient. According to the generalized Pascal's identity, the sum of the expressions (after considering all cases) will be
<span class="math notranslate nohighlight">\(\frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_n-1)!}\)</span>
, as desired.</p>
<p>Now, observe that the above expression actually counts the number of distinct sequences where the character <span class="math notranslate nohighlight">\(i\)</span> appears <span class="math notranslate nohighlight">\(d_i-1\)</span> times. Thus, it is as if we have mapped each tree to an <span class="math notranslate nohighlight">\(n-2\)</span>-tuple sequence of numbers from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span>. Therefore, if we sum this expression for all possible <span class="math notranslate nohighlight">\(d_1, d_2, ..., d_n\)</span>, the result will be <span class="math notranslate nohighlight">\(n^{n-2}\)</span>, which is the total number of distinct <span class="math notranslate nohighlight">\(n\)</span>-vertex trees.</p>
</section>
</section>
<section id="prufer-code">
<h2>Prüfer Code<a class="headerlink" href="#prufer-code" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="id1">
<h3>Hint<a class="headerlink" href="#id1" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We establish a one-to-one correspondence from <span class="math notranslate nohighlight">\(n\)</span>-vertex trees to <span class="math notranslate nohighlight">\(n-2\)</span>-tuple sequences of numbers from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</section>
<section id="id2">
<h3>Solution<a class="headerlink" href="#id2" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Our correspondence function operates as follows: we start with a tree <span class="math notranslate nohighlight">\(T\)</span>, and as long as its number of vertices is greater than 2, we repeatedly remove the leaf <span class="math notranslate nohighlight">\(u\)</span> with the minimum label. Then, we write down the label of the unique neighbor of <span class="math notranslate nohighlight">\(u\)</span>. Finally, consider the <span class="math notranslate nohighlight">\(n-2\)</span> numbers written down, in the order they were written. They form our <span class="math notranslate nohighlight">\(n-2\)</span>-tuple sequence.</p>
<p>To prove the one-to-one nature of the correspondence, we must demonstrate that every <span class="math notranslate nohighlight">\(n-2\)</span>-tuple sequence of numbers from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> uniquely corresponds to an <span class="math notranslate nohighlight">\(n\)</span>-vertex tree. Consider the sequence <span class="math notranslate nohighlight">\(s_1,s_2,...,s_{n-2}\)</span>. We want to find the tree that corresponds to it.</p>
<p>First, note that in our correspondence process, vertex <span class="math notranslate nohighlight">\(i\)</span> appears exactly <span class="math notranslate nohighlight">\(d_i-1\)</span> times in the sequence (why?).</p>
<p>Thus, the numbers that do not appear in <span class="math notranslate nohighlight">\(s_1,s_2,...,s_{n-2}\)</span> must be the leaves of the tree. In the correspondence process, in the first step, we removed the leaf with the minimum label. So, let <span class="math notranslate nohighlight">\(u\)</span> be the smallest number that does not appear in <span class="math notranslate nohighlight">\(s_1,s_2,...,s_{n-2}\)</span>. Initially, <span class="math notranslate nohighlight">\(u\)</span> must have been removed, and its unique neighbor is vertex <span class="math notranslate nohighlight">\(s_1\)</span>. Now, we can inductively find the tree corresponding to <span class="math notranslate nohighlight">\(s_2,...,s_{n-2}\)</span>. Then, we add the edge between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(s_1\)</span> to the tree, and the tree corresponding to <span class="math notranslate nohighlight">\(s_1,s_2,...,s_{n-2}\)</span> will be obtained.</p>
</section>
</section>
<section id="correspondence-to-functional-graph">
<h2>Correspondence to Functional Graph<a class="headerlink" href="#correspondence-to-functional-graph" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="id3">
<h3>Hint<a class="headerlink" href="#id3" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We define a two-colored tree as a tree in which vertex <span class="math notranslate nohighlight">\(A\)</span> is colored blue and vertex <span class="math notranslate nohighlight">\(B\)</span> is colored red (it is even possible that <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are the same vertex).</p>
<p>It is clear that for every <span class="math notranslate nohighlight">\(n\)</span>-vertex tree, there are exactly <span class="math notranslate nohighlight">\(n^2\)</span> two-colored trees. So, if we have <span class="math notranslate nohighlight">\(c\)</span> <span class="math notranslate nohighlight">\(n\)</span>-vertex trees, then we have <span class="math notranslate nohighlight">\(c \times n^2\)</span> two-colored <span class="math notranslate nohighlight">\(n\)</span>-vertex trees.</p>
<p>In this section, we establish a one-to-one correspondence between <span class="math notranslate nohighlight">\(n\)</span>-vertex functional graphs (of which there are <span class="math notranslate nohighlight">\(n^n\)</span>) and two-colored trees.</p>
</section>
<section id="id4">
<h3>Solution<a class="headerlink" href="#id4" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Consider a functional graph. As you know, in every functional graph, each connected component (in the underlying graph) consists of a directed cycle, with trees hanging from each of its vertices. Intuitively, to transform this functional graph into a tree, it would suffice to remove one edge from each cycle and then connect the functional graph components to form a tree. However, this process must be done in a way that ensures a one-to-one correspondence, allowing us to identify which edge was removed from the two-colored tree!</p>
<p>Suppose, for each connected component of the functional graph (in the underlying graph), we call the smallest label in its cycle the <em>beauty of the component</em>, and the vertex with this minimum label the <em>beautiful vertex</em> of the component. Now, for the correspondence, perform the following process:</p>
<ul class="simple">
<li><p>Arrange the components from left to right such that their beauties are in <strong>decreasing</strong> order.</p></li>
<li><p>In each component, assume its cycle is <span class="math notranslate nohighlight">\(p_1,p_2,...,p_k\)</span> such that <span class="math notranslate nohighlight">\(p_1\)</span> is the beautiful vertex of the component. First, remove the edge <span class="math notranslate nohighlight">\(p_kp_1\)</span>. Then, connect <span class="math notranslate nohighlight">\(p_k\)</span> to the beautiful vertex of the next component (to its right).</p></li>
<li><p>Color vertex <span class="math notranslate nohighlight">\(p_1\)</span> in the leftmost component blue, and vertex <span class="math notranslate nohighlight">\(p_k\)</span> in the rightmost component red. Then, remove the directions of the edges.</p></li>
</ul>
<p>In this way, we have constructed a two-colored tree from the functional graph we had.</p>
<p>Why did we define the beauty of the component as the <strong>smallest</strong> vertex in the cycle, and why did we arrange the components such that their beauties are <strong>decreasing</strong>? The sole reason for this was to ensure that the path from the blue vertex to the red vertex possesses a property we call the <em>attractive property</em>.</p>
<p><strong>Attractive Property</strong>: First, note that each of the cycles of the functional graph is now actually an interval of the path between the blue and red vertices. Start from the blue vertex and move towards the red vertex, observing the labels. Suppose we are currently at vertex <span class="math notranslate nohighlight">\(u\)</span>, and the minimum label <span class="math notranslate nohighlight">\(X\)</span> we have seen along the path <em>before</em> <span class="math notranslate nohighlight">\(u\)</span> is recorded. If <span class="math notranslate nohighlight">\(u&lt;X\)</span> (or, in other words, <span class="math notranslate nohighlight">\(X\)</span> decreases after this step), it means that we have entered a vertex belonging to another cycle (of the functional graph) (why?)!</p>
<p>To prove that the correspondence is reversible, we must be able to uniquely reconstruct the functional graph from a two-colored tree.</p>
<p>As we said, let <span class="math notranslate nohighlight">\(A\)</span> be the blue vertex and <span class="math notranslate nohighlight">\(B\)</span> be the red vertex.</p>
<p>We reverse the steps of the correspondence one by one to reach the functional graph. First of all, &quot;hang&quot; the tree from the path <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>. Consider vertex <span class="math notranslate nohighlight">\(A\)</span> on the left and vertex <span class="math notranslate nohighlight">\(B\)</span> on the right.</p>
<ul class="simple">
<li><p>The path <span class="math notranslate nohighlight">\(AB\)</span> must be directed from left to right.</p></li>
<li><p>Then, all trees hanging from the vertices of the path <span class="math notranslate nohighlight">\(AB\)</span> must be directed from bottom to top (each vertex has an edge to its parent).</p></li>
<li><p>Here, we use the <strong>attractive property</strong> mentioned above. By traversing the path from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span>, we can partition the path into intervals that previously belonged to a single component (in the functional graph). Now we know that each of these intervals was previously a cycle with vertices <span class="math notranslate nohighlight">\(p_1,...,p_k\)</span> in order, and the edge <span class="math notranslate nohighlight">\(p_kp_1\)</span> was removed. So, it is sufficient to draw an edge from the last vertex of the interval (which is <span class="math notranslate nohighlight">\(p_k\)</span>) to the first vertex of the interval (which is <span class="math notranslate nohighlight">\(p_1\)</span>).</p></li>
</ul>
<p>Thus, by inverting the correspondence function, we were able to obtain a functional graph from each two-colored tree. Therefore, we have proven the one-to-one nature of the correspondence.</p>
</section>
</section>
<section id="counting-arborescences">
<h2>Counting Arborescences<a class="headerlink" href="#counting-arborescences" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="id5">
<h3>Hint<a class="headerlink" href="#id5" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We attempt to count the number of arborescences (rooted trees where every vertex except the root has a directed edge to its parent). Furthermore, assume the edges of the tree are ordered, meaning we have written an <span class="math notranslate nohighlight">\(n-1\)</span>-permutation on the edges of the tree.</p>
<p>In this case, if the number of arborescences we counted (including the order of edges) is <span class="math notranslate nohighlight">\(T\)</span>, then the number of trees will be <span class="math notranslate nohighlight">\(\frac {T} {(n-1)! \times n}\)</span>. In other words, each tree is counted <span class="math notranslate nohighlight">\((n-1)! \times n\)</span> times. The factor <span class="math notranslate nohighlight">\(n\)</span> is due to the choice of the root of the tree, and <span class="math notranslate nohighlight">\((n-1)!\)</span> is due to the choice of the permutation written on the edges of the tree.</p>
</section>
<section id="id6">
<h3>Solution<a class="headerlink" href="#id6" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We attempt to calculate <span class="math notranslate nohighlight">\(T\)</span>. Consider a specific arborescence and its construction process as follows:</p>
<ul class="simple">
<li><p>First, consider an <span class="math notranslate nohighlight">\(n\)</span>-vertex graph with no edges. We add edges one by one. Thus, at each step, we will have a number of directed trees.</p></li>
<li><p>In the <span class="math notranslate nohighlight">\(i\)</span>-th step, consider the edge labeled <span class="math notranslate nohighlight">\(i\)</span>. Assume it is <span class="math notranslate nohighlight">\(uv\)</span>.</p></li>
<li><p>In this case, it is necessary and sufficient that at each step, <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> belong to two different components, and also that <span class="math notranslate nohighlight">\(v\)</span> is a vertex that is the root of one of our directed trees.</p></li>
</ul>
<p>To count the number of possible arborescences, it is sufficient to understand how many different states the arborescence construction process can have.</p>
<p>At the beginning of step <span class="math notranslate nohighlight">\(i\)</span> (counting from 1), we have exactly <span class="math notranslate nohighlight">\(n-i+1\)</span> rooted trees. If you consider cases for <span class="math notranslate nohighlight">\(u\)</span> (of which there are <span class="math notranslate nohighlight">\(n\)</span> possibilities), then for choosing <span class="math notranslate nohighlight">\(v\)</span>, there are exactly <span class="math notranslate nohighlight">\(n-i\)</span> possibilities, because <span class="math notranslate nohighlight">\(v\)</span> must be the root of one of the trees and must not be the root of the tree that <span class="math notranslate nohighlight">\(u\)</span> is in. Therefore, the <span class="math notranslate nohighlight">\(i\)</span>-th step of the graph construction process has <span class="math notranslate nohighlight">\(n \times (n-i)\)</span> states. So, finally, we have
<span class="math notranslate nohighlight">\(T = n^{n-1} \times (n-1)!\)</span></p>
<p>Thus, as we said, the number of trees must be equal to <span class="math notranslate nohighlight">\(\frac {T} {(n-1)! \times n}\)</span>, which is <span class="math notranslate nohighlight">\(n^{n-2}\)</span>. As desired!</p>
</section>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="2.html" style="float:left;" title="Distance in Tree and Graph" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="4.html" style="float:right;" title="DFS" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>