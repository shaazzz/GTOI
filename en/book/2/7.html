

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>DFS Start/Finish Time &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Trees" href="index.html" />
        <link rel="next" title="Cut Vertex and Bridge Algorithms" href="8.html" />
        <link rel="prev" title="Algorithm for Finding Tree Diameter" href="6.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">Directed Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; DFS Start/Finish Time</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/2/7.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="dfs-start-finish-time">
<h1>DFS Start/Finish Time<a class="headerlink" href="#dfs-start-finish-time" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>In this section, we want to convert a graph into an array using a trick.</p>
<p>There are various ideas to convert a graph into an array, and starting time is one of them. Using this idea, the given graph can be transformed into an array, making it easier to solve various types of problems.</p>
<p>For each vertex, we can consider the first time the DFS algorithm enters it. In this way, each vertex has a unique number, and the vertices can be sorted according to these times to form an array.</p>
<p>Suppose the array we want to create from the graph's vertices is a[i], and the time when the DFS algorithm enters vertex u is st[u]. In this case, we place vertex u at index st[u], or in other words, a[st[u]] = u.</p>
<p>It is clear that each subtree of its DFS tree corresponds to an interval in the array.</p>
<p>Finishing time is defined similarly to starting time, with the difference that it indicates the time when the DFS algorithm exits a vertex.</p>
<p>Now, let's examine a few problems.</p>
<section id="checking-ancestor-descendant-relationship-in-linear-time">
<h2>Checking Ancestor/Descendant Relationship in Linear Time<a class="headerlink" href="#checking-ancestor-descendant-relationship-in-linear-time" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>We are given an <span class="math notranslate nohighlight">\(n\)</span>-vertex tree along with <span class="math notranslate nohighlight">\(q\)</span> queries. In each query, we need to check whether vertex <span class="math notranslate nohighlight">\(u\)</span> is an ancestor of vertex <span class="math notranslate nohighlight">\(v\)</span>.
<span class="math notranslate nohighlight">\(O(n+q)\)</span></p>
<section id="solution">
<h3>Solution<a class="headerlink" href="#solution" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We use the lemma that the necessary and sufficient condition for an ancestor-descendant relationship is as follows:
<span class="math notranslate nohighlight">\(stt[u] \le stt[v]\)</span> and <span class="math notranslate nohighlight">\(fnt[v] \le fnt[u]\)</span>
or
<span class="math notranslate nohighlight">\(stt[u] \le stt[v]\)</span> and <span class="math notranslate nohighlight">\(stt[v] &lt; fnt[u]\)</span></p>
<p>The correctness of this lemma can be easily verified.
So, to solve the problem, we first perform a DFS on the tree, and then for each query, we check the given condition in <span class="math notranslate nohighlight">\(O(1)\)</span> time.</p>
</section>
</section>
<section id="finding-the-k-th-parent">
<h2>Finding the k-th Parent<a class="headerlink" href="#finding-the-k-th-parent" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>We are given an <span class="math notranslate nohighlight">\(n\)</span>-vertex tree along with <span class="math notranslate nohighlight">\(q\)</span> queries. In each query, we need to find the <span class="math notranslate nohighlight">\(k\)</span>-th parent of vertex <span class="math notranslate nohighlight">\(v\)</span>.
<span class="math notranslate nohighlight">\(O(n+q \cdot \log(n))\)</span></p>
<section id="id1">
<h3>Solution<a class="headerlink" href="#id1" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Consider all vertices with height <span class="math notranslate nohighlight">\(h[v]-k\)</span>. Using the lemma from the previous problem, we can conclude that the answer is the vertex with the maximum starting time less than the starting time of vertex <span class="math notranslate nohighlight">\(v\)</span> among vertices at height <span class="math notranslate nohighlight">\(k\)</span> levels higher. In other words,</p>
<ul class="simple">
<li><p>u with maximum stt such that h[u] = h[v] - k and stt[u] &lt;= stt[v]</p></li>
</ul>
<p>For each height, create a vector of all vertices at that height, where the vertices in each vector are sorted by their starting times.
<span class="math notranslate nohighlight">\(O(n)\)</span></p>
<p>Now, each query transforms into a binary search on one of these vectors!</p>
</section>
</section>
<section id="id2">
<h2><a class="reference external" href="https://codeforces.com/problemset/problem/208/E">Blood Cousins</a><a class="headerlink" href="#id2" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>An <span class="math notranslate nohighlight">\(n\)</span>-vertex tree with <span class="math notranslate nohighlight">\(m\)</span> queries of the form <cite>v p</cite> is given. For each query, you need to output the number of <span class="math notranslate nohighlight">\(u\)</span>'s such that the p-th parent of <cite>v</cite> and <cite>u</cite> are the same.
<span class="math notranslate nohighlight">\(O(n+q \log(n))\)</span></p>
<section id="id3">
<h3>Solution<a class="headerlink" href="#id3" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>First, find the p-th parent of vertex <cite>v</cite> similar to the previous problem.
Let's call this vertex <cite>w</cite>.
Now, the answer is the number of <cite>u</cite>'s such that <span class="math notranslate nohighlight">\(h[u] = h[v]\)</span>, <span class="math notranslate nohighlight">\(stt[w] \le stt[u]\)</span>, and <span class="math notranslate nohighlight">\(stt[u] &lt; fnt[w]\)</span>.
This means we want the count of starting times within a specific range in the vector corresponding to vertex <cite>v</cite>, which can be solved with a simple binary search.</p>
</section>
</section>
<section id="biconnecting-with-minimum-number-of-paths">
<h2>Biconnecting with Minimum Number of Paths<a class="headerlink" href="#biconnecting-with-minimum-number-of-paths" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Given an <span class="math notranslate nohighlight">\(n\)</span>-vertex tree with <span class="math notranslate nohighlight">\(2k\)</span> leaves. In each operation, we can choose two leaves and color all edges on the path between them. Find the minimum number of operations required and a method with the minimum number of operations to color all edges.
<span class="math notranslate nohighlight">\(O(n)\)</span></p>
<section id="id4">
<h3>Solution<a class="headerlink" href="#id4" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Answer = k
Next, we will present a method and demonstrate its correctness.
If n=2, the problem is trivially solved.
So assume n &gt; 2 and we have at least one non-leaf vertex.
Root the tree at a non-leaf vertex and number the leaves according to their starting times.
Now perform operations on these leaf pairs:</p>
<div class="math notranslate nohighlight">
\[(1, k+1)\]</div>
<div class="math notranslate nohighlight">
\[(2, k+2)\]</div>
<div class="math notranslate nohighlight">
\[(3, k+3)\]</div>
<div class="math notranslate nohighlight">
\[...\]</div>
<div class="math notranslate nohighlight">
\[(k, 2k)\]</div>
<p>Clearly, the complexity of this pairing is <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
<p>Now we must show that all edges are colored.
The subtree of each edge covers an interval of leaves. For an edge to be colored, we must have a pair of leaves where one end is inside this interval and the other end is outside of it.
Assume the interval for the edge in question is <span class="math notranslate nohighlight">\([l, r]\)</span>.
We consider two cases.
First, if <span class="math notranslate nohighlight">\(l \le k\)</span> and <span class="math notranslate nohighlight">\((k+1) \le r\)</span>.
In this case, if <span class="math notranslate nohighlight">\(l \ne 1\)</span>, the pair <cite>(1, k+1)</cite> falls within the interval. Otherwise, the pair <cite>(k, 2k)</cite>.</p>
<p>If the interval corresponding to the edge is not similar to the previous case, without loss of generality, we assume <span class="math notranslate nohighlight">\(l, r \le k\)</span>.
In this case, the pair <cite>(r, r+k)</cite> also colors this edge.</p>
<p>Therefore, in both cases, the desired edge is colored, and the pairs we formed are valid.</p>
</section>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="6.html" style="float:left;" title="Algorithm for Finding Tree Diameter" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="8.html" style="float:right;" title="Cut Vertex and Bridge Algorithms" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>