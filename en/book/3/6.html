

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Games and Directed Graphs &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Directed Graph" href="index.html" />
        <link rel="next" title="Functional Graphs and Permutation Graphs" href="7.html" />
        <link rel="prev" title="Detecting Cycles in a Directed Graph" href="5.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Directed Graph</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Games and Directed Graphs</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/3/6.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="games-and-directed-graphs">
<h1>Games and Directed Graphs<a class="headerlink" href="#games-and-directed-graphs" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In this section, we will explore the connection between games and directed graphs.</p>
<p>Let's start with a simple example:</p>
<p>Ali and Matin are playing a game. There is a bag containing 10 pebbles in front of them. In each turn, the player whose turn it is takes 1 or 2 pebbles from the bag. The loser of the game is the one who faces an empty bag and cannot take any pebbles.</p>
<p>Assume Matin starts the game. If both players play optimally, who will win the game?</p>
</section>
<section id="examining-an-example">
<h2>Examining an Example<a class="headerlink" href="#examining-an-example" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>In this section, we will explain the example presented in the introduction.</p>
<p>We construct an 11-vertex graph, with vertex numbers ranging from 0 to 10. A directed edge is drawn from vertex <span class="math notranslate nohighlight">\(i\)</span> to vertex <span class="math notranslate nohighlight">\(j\)</span> if it's possible to reach <span class="math notranslate nohighlight">\(j\)</span> from <span class="math notranslate nohighlight">\(i\)</span> by removing 1 or 2 pebbles.</p>
<p>Next to each vertex, we write an <span class="math notranslate nohighlight">\(L(Lose)\)</span> or <span class="math notranslate nohighlight">\(W(Win)\)</span> label (or nothing at all, meaning the status of this vertex is yet to be determined).</p>
<p>Suppose we have written the letter <span class="math notranslate nohighlight">\(L\)</span> next to vertex number <span class="math notranslate nohighlight">\(i\)</span>. This means that if the initial bag from which the two players are playing has <span class="math notranslate nohighlight">\(i\)</span> pebbles, and both players play optimally, the first player will lose that game.</p>
<p>Conversely, suppose we have written the letter <span class="math notranslate nohighlight">\(W\)</span> next to vertex number <span class="math notranslate nohighlight">\(i\)</span>. This means that if the initial bag from which the two players are playing has <span class="math notranslate nohighlight">\(i\)</span> pebbles, and both players play optimally, the first player will win that game.</p>
<p>Now, at the beginning of the game, which vertex can be assigned <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(W\)</span>?!</p>
<p>With a little thought, we realize it's vertex number 0. This means that if the initial bag contains 0 pebbles, according to the game rules, the first player loses because they cannot take any pebbles.</p>
<p>So, we assign <span class="math notranslate nohighlight">\(L\)</span> to vertex 0.</p>
<p>Now, which is the next vertex whose status is determined?</p>
<p>Consider vertex 1. If the bag only has 1 pebble, the first player can only take one pebble. Now, if we pay attention, we see that the bag remaining after the first player's move contains 0 pebbles, whose status we determined earlier.</p>
<p>We previously stated that the status of vertex 0 is <span class="math notranslate nohighlight">\(L\)</span>. Therefore, the status of vertex 1 becomes <span class="math notranslate nohighlight">\(W\)</span>. Because, as you may have noticed, when the first player took one pebble, the roles of the first and second players were swapped (because the turn changed). So, vertex 0 represents a loss for the second player (Ali) in that context.</p>
<section id="result">
<h3><strong>Result</strong><a class="headerlink" href="#result" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>We determine the status of the vertices, meaning <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(W\)</span>, in increasing order of vertex numbers.</p>
<p>To do this, if among the vertices to which vertex <span class="math notranslate nohighlight">\(v\)</span> has a directed edge, there exists a vertex <span class="math notranslate nohighlight">\(u\)</span> whose status is <span class="math notranslate nohighlight">\(L\)</span>, then the status of vertex <span class="math notranslate nohighlight">\(v\)</span> becomes <span class="math notranslate nohighlight">\(W\)</span>. And if all vertices to which <span class="math notranslate nohighlight">\(v\)</span> has edges have a status of <span class="math notranslate nohighlight">\(W\)</span>, then the status of vertex <span class="math notranslate nohighlight">\(v\)</span> becomes <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>Using this method, the status of all vertices can be determined. Now, it is sufficient to look at the initial state of the game and see if it is <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(W\)</span>. If it is <span class="math notranslate nohighlight">\(L\)</span>, it means the first player loses the game. And if the status is <span class="math notranslate nohighlight">\(W\)</span>, it means the first player wins. With this, we can figure out if Ali or Matin wins the game we specified above!</p>
</section>
</section>
<section id="moving-a-piece-on-a-graph-game">
<h2>Moving a Piece on a Graph Game<a class="headerlink" href="#moving-a-piece-on-a-graph-game" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Our game works as follows: we have a graph, and initially, a piece is on a starting vertex. Players take turns moving, and each player, on their turn, moves the piece to an adjacent vertex. The player who cannot make a move loses the game.</p>
<section id="generalization">
<h3>Generalization<a class="headerlink" href="#generalization" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>If you pay attention to the nature of most games, you will see such a graph within them! In fact, the essence of combinatorial games is that two or more players make changes to shared resources (shared resources can be a chessboard where we move pieces, or it can be a bag from which we take pebbles).</p>
<p>Now, suppose for each state of the shared resources and whose turn it is, we create a vertex, and we draw a directed edge from vertex <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> if and only if the person whose turn it is in state <span class="math notranslate nohighlight">\(A\)</span> can move to <span class="math notranslate nohighlight">\(B\)</span> in their turn. Now we have a graph! We were able to define our game on a graph.</p>
<p>So, we intuitively accept that most games can be converted into the game of moving a piece on a graph (as described above). For example, consider chess. Each state of this game is a chessboard with different arrangements of pieces.</p>
</section>
<section id="solving-the-game-on-a-graph">
<h3>Solving the Game on a Graph<a class="headerlink" href="#solving-the-game-on-a-graph" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>If we can solve the game of moving a piece on a graph, we have taken a big step in understanding how to solve most games. To solve this game, we proceed as follows. We assign each vertex a label of Win (W), Lose (L), or Draw (D). Pay attention to the following three points.</p>
<ul class="simple">
<li><p>A vertex that has no outgoing edges is definitely L.</p></li>
<li><p>A vertex that has an L-labeled neighbor is definitely W.</p></li>
<li><p>If a player has a non-losing strategy, they will never move the piece to a vertex with a W label (because in this case, their opponent can win).</p></li>
</ul>
<p>So, we implement this algorithm on our graph. As long as there is a vertex like <span class="math notranslate nohighlight">\(u\)</span> that has no outgoing edges, we label it <span class="math notranslate nohighlight">\(L\)</span>. Then, we label all vertices like <span class="math notranslate nohighlight">\(v\)</span> that have an edge to <span class="math notranslate nohighlight">\(u\)</span> with W.
Then, we remove all labeled vertices from the graph. Why? Because we are sure that if a player wants to move the piece to <span class="math notranslate nohighlight">\(v\)</span>, they must first reach a vertex labeled W, and no player wants to move the piece to W-labeled vertices.</p>
<p>Finally, a time comes when every remaining vertex in the graph has at least one outgoing edge. If we start from any of these remaining graph vertices, the game will never end, and both players can continue the game indefinitely! Thus, we were able to partition the vertices into three categories, and for each category, we know what the outcome of the game will be (win, loss, or draw) if we start from a vertex within it. So, we have algorithmically solved the game of moving a piece on a graph.</p>
</section>
<section id="some-useful-conclusions">
<h3>Some Useful Conclusions<a class="headerlink" href="#some-useful-conclusions" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>If a vertex has a self-loop, then this vertex will certainly not be L. This is because, according to the algorithm, we only label a vertex L if it has no outgoing edges. More precisely, the player whose piece is currently on this vertex can easily steal the opponent's strategy. That is, if they realize the other player can win, they can simply use the self-loop edge, and this move is as if they have swapped their turn and the next player's turn; after this, they can use the other player's strategy. Examples of stealing strategies are provided in the problems section.</p>
<p>The algorithm we discussed can be examined in another way for directed acyclic graphs (DAGs). This is due to the characteristic of DAGs, namely having a topological order. We arrange the graph vertices in topological order. Now we start from the end and remove the vertices one by one. If the vertex we are removing has an edge to an L-labeled vertex further ahead, we label it W; otherwise, we label it L. In the end, all vertices are assigned either win or loss, because such games are always finite.</p>
</section>
</section>
<section id="final-word">
<h2>Final Word<a class="headerlink" href="#final-word" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>It seems that converting games into graphs is an effective way to solve them, but in reality, this is not always the case.</p>
<p>This is because, in practice, many games, after being converted into graphs, will have a very large (or even infinite) number of vertices. And since solving games requires memory and execution time proportional to the number of vertices and edges, solving many games using this method is not feasible. (Can you estimate how many distinct vertices a chess game would have after being converted into a graph?!).</p>
<p>On the other hand, in many games, converting them into graphs can provide better intuition for solving the problem, or our graph might become very specific. So, the conclusion is that converting to a graph is a relatively powerful tool for solving games and gaining intuition, but it will not always meet our needs.</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="5.html" style="float:left;" title="Detecting Cycles in a Directed Graph" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="7.html" style="float:right;" title="Functional Graphs and Permutation Graphs" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>