

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="ltr" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>Strongly Connected Components &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-ltr.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="Directed Graph" href="index.html" />
        <link rel="next" title="Detecting Cycles in a Directed Graph" href="5.html" />
        <link rel="prev" title="Directed Acyclic Graph" href="3.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-right " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="Search">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">Basic Definitions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">Introduction to Graphs and Graph Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">Types of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">Graph Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">Walks, Trails, Paths, Extremal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">Subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">Connectivity, Cut Edge, and Cut Vertex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">Bipartite Graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">Introductory Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">Distance in Tree and Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">Counting the Number of Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">Algorithm for Finding Tree Diameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">Cut Vertex and Bridge Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">Idea Cultivation Workshop</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Directed Graph</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">Tournament</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">Directed Acyclic Graph</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><strong>Strongly Connected Components</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">Detecting Cycles in a Directed Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Games and Directed Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">Functional Graphs and Permutation Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">Proof Techniques for Graph Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">Extremal Choices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">Contracting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">Graph and Magic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">Eulerian Tour and Hamiltonian Cycle</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">Eulerian Tour in Directed and Undirected Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">Existence Theorems for Hamiltonian Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">Exponential Algorithms for Finding Hamiltonian Cycles and Paths</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">Shortest Path Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">Bellman-Ford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">Dijkstra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">Floyd-Warshall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">Matrices and Operations on Them</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">Determinants of Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">Incidence Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">Adjacency Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">Number of Walks of Length n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">Obtaining Recursive Functions Using Graphs and Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">Tree Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">Binary Search Tree (BST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">NP and NP-complete Problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">NP and NP-complete Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Proof of NP-Completeness of the SAT Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Graph NP-Complete Problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">Problem Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">O(n+q*lg(n)) Solution using Heavy-Light Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">Tarjan's Offline Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">Relationship between LCA and RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">LCA Linear Time Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">Virtual Tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">Advanced Tree Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">Minimum Spanning Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">Sack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">Centroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">Huffman Coding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">Tree Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">Heavy-Light Decomposition (HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">Connectivity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">Cuts and Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">k-connected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">Max-Flow Min-Cut</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">Matching in Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">Min-Max Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">Maximum Flow and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">Matching in General Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">Special Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">Planar Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">Degree Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">Identical Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">Ramsey Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">Independent Set and Clique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">Several Special Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">How to Use This Book?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">Introduction to Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">Cheat Sheet</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; Index</a>&nbsp;
        <a><i class="fa  fa-angle-right"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; <strong>Strongly Connected Components</strong></a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;Problems</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (Farsi)</a>
        <script>document.getElementById('lang-link').href=`${window.location.pathname.slice(3)}`;</script>
        
            <a href="../../_sources/book/3/4.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; Source</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="strongly-connected-components">
<h1><strong>Strongly Connected Components</strong><a class="headerlink" href="#strongly-connected-components" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<section id="basic-concepts">
<h2>Basic Concepts<a class="headerlink" href="#basic-concepts" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="definition-3-4-1-strongly-connected-pair-of-vertices">
<h3><strong>Definition 3.4.1 (Strongly Connected Pair of Vertices)</strong><a class="headerlink" href="#definition-3-4-1-strongly-connected-pair-of-vertices" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>In a directed graph, a pair of vertices
<span class="math notranslate nohighlight">\((v, u)\)</span>
is said to be strongly connected if and only if there exists a path from
<span class="math notranslate nohighlight">\(v\)</span>
to
<span class="math notranslate nohighlight">\(u\)</span>
and a path from
<span class="math notranslate nohighlight">\(u\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
.</p>
<p>For example, in Figure 1, vertices 2 and 4 are a strongly connected pair.</p>
</section>
<section id="definition-3-4-2-strongly-connected-graph">
<h3><strong>Definition 3.4.2 (Strongly Connected Graph)</strong><a class="headerlink" href="#definition-3-4-2-strongly-connected-graph" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>A strongly connected graph is a directed graph in which every pair of its vertices is strongly connected (Figure 1).</p>
<figure class="align-left">
<a class="reference internal image-reference" href="../../_images/scc_1.png"><img alt="This appears if the user's internet is poor" src="../../_images/scc_1.png" style="width: 50%;" /></a>
</figure>
</section>
<section id="definition-3-4-3-strongly-connected-component-or-scc">
<h3><strong>Definition 3.4.3 (Strongly Connected Component, or SCC)</strong><a class="headerlink" href="#definition-3-4-3-strongly-connected-component-or-scc" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>A strongly connected component (SCC) in a directed graph
<span class="math notranslate nohighlight">\(G\)</span>
is a subset of vertices of
<span class="math notranslate nohighlight">\(G\)</span>
such that their induced subgraph forms a strongly connected graph, and it is also maximal, meaning no other vertex can be added to it.</p>
</section>
<section id="lemma-3-4-4">
<h3><strong>Lemma 3.4.4</strong><a class="headerlink" href="#lemma-3-4-4" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p><strong>Statement:</strong> Every vertex
<span class="math notranslate nohighlight">\(v\)</span>
in a directed graph
<span class="math notranslate nohighlight">\(G\)</span>
belongs to exactly one unique strongly connected component.</p>
<p><strong>Proof:</strong> We use proof by contradiction. Assume that
<span class="math notranslate nohighlight">\(v\)</span>
belongs to two strongly connected components
<span class="math notranslate nohighlight">\(H\)</span>
and
<span class="math notranslate nohighlight">\(L\)</span>
, and
<span class="math notranslate nohighlight">\(u\)</span>
is a vertex in
<span class="math notranslate nohighlight">\(L\)</span>
that is not in
<span class="math notranslate nohighlight">\(H\)</span>
. Since
<span class="math notranslate nohighlight">\(u\)</span>
and
<span class="math notranslate nohighlight">\(v\)</span>
are in a strongly connected component, it follows that from any vertex in
<span class="math notranslate nohighlight">\(H\)</span>
one can reach
<span class="math notranslate nohighlight">\(v\)</span>
via a path, and then reach
<span class="math notranslate nohighlight">\(u\)</span>
via another path. Similarly, one can come from
<span class="math notranslate nohighlight">\(u\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
via a path, and then go to any desired vertex in
<span class="math notranslate nohighlight">\(H\)</span>
via another path. Therefore, vertex
<span class="math notranslate nohighlight">\(u\)</span>
could be added to component
<span class="math notranslate nohighlight">\(H\)</span>
, which contradicts the maximality of
<span class="math notranslate nohighlight">\(H\)</span>
. The contradiction proves the statement.</p>
</section>
<section id="corollary-3-4-5">
<h3><strong>Corollary 3.4.5</strong><a class="headerlink" href="#corollary-3-4-5" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Any directed graph
<span class="math notranslate nohighlight">\(G\)</span>
can be partitioned into strongly connected components. Figure 2 shows a directed graph with its strongly connected components highlighted.</p>
<figure class="align-left">
<a class="reference internal image-reference" href="../../_images/scc_2.png"><img alt="This appears if the user's internet is poor" src="../../_images/scc_2.png" style="width: 50%;" /></a>
</figure>
</section>
<section id="definition-3-4-6-transpose-graph">
<h3><strong>Definition 3.4.6 (Transpose Graph)</strong><a class="headerlink" href="#definition-3-4-6-transpose-graph" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>The transpose graph
<span class="math notranslate nohighlight">\(G^T\)</span>
is a graph obtained by reversing the direction of all edges in graph
<span class="math notranslate nohighlight">\(G\)</span>
. Note that a graph is strongly connected if and only if its transpose is also strongly connected.</p>
</section>
</section>
<section id="acyclicity-of-the-strongly-connected-component-graph">
<h2>Acyclicity of the Strongly Connected Component Graph<a class="headerlink" href="#acyclicity-of-the-strongly-connected-component-graph" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<section id="definition-3-4-7-condensed-graph-of-strongly-connected-components">
<h3><strong>Definition 3.4.7 (Condensed Graph of Strongly Connected Components)</strong><a class="headerlink" href="#definition-3-4-7-condensed-graph-of-strongly-connected-components" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Let
<span class="math notranslate nohighlight">\(G\)</span>
be an arbitrary directed graph, and let the directed graph
<span class="math notranslate nohighlight">\(H\)</span>
be a graph where each of its vertices corresponds to a strongly connected component in
<span class="math notranslate nohighlight">\(G\)</span>
, and each strongly connected component in
<span class="math notranslate nohighlight">\(G\)</span>
corresponds to exactly one vertex in
<span class="math notranslate nohighlight">\(H\)</span>
. If
<span class="math notranslate nohighlight">\(v\)</span>
is a vertex in
<span class="math notranslate nohighlight">\(H\)</span>
, we denote the strongly connected component corresponding to vertex
<span class="math notranslate nohighlight">\(v\)</span>
in
<span class="math notranslate nohighlight">\(G\)</span>
as
<span class="math notranslate nohighlight">\(F(v)\)</span>
. If
<span class="math notranslate nohighlight">\(v\)</span>
and
<span class="math notranslate nohighlight">\(u\)</span>
are two vertices of
<span class="math notranslate nohighlight">\(H\)</span>
, for every directed edge from a vertex in
<span class="math notranslate nohighlight">\(F(v)\)</span>
to a vertex in
<span class="math notranslate nohighlight">\(F(u)\)</span>
, there is a directed edge from
<span class="math notranslate nohighlight">\(v\)</span>
to
<span class="math notranslate nohighlight">\(u\)</span>
, and similarly, every edge from
<span class="math notranslate nohighlight">\(v\)</span>
to
<span class="math notranslate nohighlight">\(u\)</span>
corresponds to an edge from a vertex in
<span class="math notranslate nohighlight">\(F(v)\)</span>
to a vertex in
<span class="math notranslate nohighlight">\(F(u)\)</span>
. In this case,
<span class="math notranslate nohighlight">\(H\)</span>
is called the condensed graph of strongly connected components of
<span class="math notranslate nohighlight">\(G\)</span>
.</p>
</section>
<section id="theorem-3-4-8">
<h3><strong>Theorem 3.4.8</strong><a class="headerlink" href="#theorem-3-4-8" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p><strong>Statement:</strong> Every condensed graph of strongly connected components is acyclic.</p>
<p><strong>Proof:</strong> Let
<span class="math notranslate nohighlight">\(G\)</span>
be an arbitrary directed graph and
<span class="math notranslate nohighlight">\(H\)</span>
be the condensed graph of strongly connected components of
<span class="math notranslate nohighlight">\(G\)</span>
. We use proof by contradiction. Assume that
<span class="math notranslate nohighlight">\(H\)</span>
has a cycle, and two vertices, say
<span class="math notranslate nohighlight">\(v\)</span>
and
<span class="math notranslate nohighlight">\(u\)</span>
, from
<span class="math notranslate nohighlight">\(H\)</span>
are part of a cycle. Since there is a path from any vertex within a strongly connected component to any other vertex within that same component, it follows that one can go from any vertex in
<span class="math notranslate nohighlight">\(F(v)\)</span>
to any vertex in
<span class="math notranslate nohighlight">\(F(u)\)</span>
, and similarly, there exists a directed path from any vertex in
<span class="math notranslate nohighlight">\(F(u)\)</span>
to any vertex in
<span class="math notranslate nohighlight">\(F(v)\)</span>
(Why?). This implies that the vertices in
<span class="math notranslate nohighlight">\(F(v)\)</span>
and
<span class="math notranslate nohighlight">\(F(u)\)</span>
must belong to the same strongly connected component, which contradicts the assumption of maximality of the strongly connected components. Therefore,
<span class="math notranslate nohighlight">\(H\)</span>
has no cycles, and the statement is proven.</p>
</section>
<section id="corollary-3-4-9">
<h3><strong>Corollary 3.4.9</strong><a class="headerlink" href="#corollary-3-4-9" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>According to Theorem 3.3.2, the vertices of any condensed graph of strongly connected components can be topologically sorted. Consequently, the strongly connected components of any directed graph can be arranged in a topological sort order, meaning that all edges between two different components will point in a single direction (Figure 3).</p>
<figure class="align-left">
<a class="reference internal image-reference" href="../../_images/scc_3.png"><img alt="This appears if the user's internet is poor" src="../../_images/scc_3.png" style="width: 50%;" /></a>
</figure>
</section>
</section>
<section id="finding-strongly-connected-components">
<h2>Finding Strongly Connected Components<a class="headerlink" href="#finding-strongly-connected-components" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>Now, we intend to present an algorithm with suitable time complexity for finding the strongly connected components of a graph.</p>
<section id="kosaraju-s-algorithm">
<h3><strong>Kosaraju's Algorithm</strong><a class="headerlink" href="#kosaraju-s-algorithm" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p><strong>Description:</strong> First, we perform a
<span class="math notranslate nohighlight">\(DFS\)</span>
traversal on the entire graph, and each time we finish exploring a vertex, we push it onto a stack (note that the later a vertex is finished, the higher it is placed on the stack). Now, we consider the transpose graph. In each step, from all unvisited vertices, we pick the vertex that is highest in the stack (e.g.,
<span class="math notranslate nohighlight">\(v\)</span>
) and perform a
<span class="math notranslate nohighlight">\(DFS\)</span>
from it in the transpose graph. We then place
<span class="math notranslate nohighlight">\(v\)</span>
and all vertices visited (by performing
<span class="math notranslate nohighlight">\(DFS\)</span>
from vertex
<span class="math notranslate nohighlight">\(v\)</span>
) into a new component. We continue this process until all strongly connected components are found. Note that when performing
<span class="math notranslate nohighlight">\(DFS\)</span>
on the transpose graph, once a vertex is visited, it is marked as visited, and we do not perform
<span class="math notranslate nohighlight">\(DFS\)</span>
from it or enter it in subsequent traversals.</p>
<p><strong>Proof of Correctness:</strong> To prove this algorithm, first consider the following lemma, similar to one we had in the previous section.</p>
<p>Let's define
<span class="math notranslate nohighlight">\(f(v)\)</span>
as the finish time of the traversal for vertex
<span class="math notranslate nohighlight">\(v\)</span>
. In other words, we are determining a vertex's position in the stack (the greater
<span class="math notranslate nohighlight">\(f(v)\)</span>
is, the lower the vertex is placed in the stack).</p>
<p><strong>Lemma 1:</strong> If
<span class="math notranslate nohighlight">\(f(u) &gt; f(v)\)</span>
, meaning vertex
<span class="math notranslate nohighlight">\(u\)</span>
is higher in the stack than vertex
<span class="math notranslate nohighlight">\(v\)</span>
, and there is a path from
<span class="math notranslate nohighlight">\(v\)</span>
to
<span class="math notranslate nohighlight">\(u\)</span>
, then there is also a path from
<span class="math notranslate nohighlight">\(u\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
.</p>
<p><strong>Proof of Lemma 1:</strong> We use proof by contradiction. Assume there is a path from
<span class="math notranslate nohighlight">\(v\)</span>
to
<span class="math notranslate nohighlight">\(u\)</span>
, and no path from
<span class="math notranslate nohighlight">\(u\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
.</p>
<p>Then, since we initially visited vertex
<span class="math notranslate nohighlight">\(u\)</span>
during the traversal (Why?), and there is no path from
<span class="math notranslate nohighlight">\(u\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
, we will never traverse vertex
<span class="math notranslate nohighlight">\(v\)</span>
as part of
<span class="math notranslate nohighlight">\(u\)</span>
's DFS path. On the other hand, if the traversal of vertex
<span class="math notranslate nohighlight">\(u\)</span>
finishes and we still haven't visited vertex
<span class="math notranslate nohighlight">\(v\)</span>
, it implies that
<span class="math notranslate nohighlight">\(u\)</span>
is added to the stack first, and then
<span class="math notranslate nohighlight">\(v\)</span>
, meaning
<span class="math notranslate nohighlight">\(f(u) &lt; f(v)\)</span>
, which contradicts our assumption. Thus, the lemma is proven!</p>
<p>Now, note that when traversing the transpose graph, we move along the reversed edges. That is, we take the top element of the stack, which is vertex
<span class="math notranslate nohighlight">\(v\)</span>
, and traverse all vertices
<span class="math notranslate nohighlight">\(x\)</span>
such that there is a path from
<span class="math notranslate nohighlight">\(x\)</span>
to
<span class="math notranslate nohighlight">\(v\)</span>
(in the original graph). In this case, according to Lemma 1, vertex
<span class="math notranslate nohighlight">\(v\)</span>
also has a path to vertex
<span class="math notranslate nohighlight">\(x\)</span>
(in the original graph)!</p>
<p>Therefore,
<span class="math notranslate nohighlight">\(v\)</span>
and all vertices visited during the traversal of the transpose graph from
<span class="math notranslate nohighlight">\(v\)</span>
belong to a single component!</p>
<p>On the other hand, no other vertex is in this component. Otherwise, if another vertex were in this component, it would have to have at least one path to
<span class="math notranslate nohighlight">\(v\)</span>
(in <cite>G</cite>) and would have been counted among the vertices visited from
<span class="math notranslate nohighlight">\(v\)</span>
(in <cite>G^T</cite>).</p>
</section>
<section id="algorithm-complexity">
<h3><strong>Algorithm Complexity</strong><a class="headerlink" href="#algorithm-complexity" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>In the above algorithm, we used
<span class="math notranslate nohighlight">\(DFS\)</span>
only twice. Consequently, the algorithm's complexity is
<span class="math notranslate nohighlight">\(O(n + m)\)</span>
, where
<span class="math notranslate nohighlight">\(n\)</span>
and
<span class="math notranslate nohighlight">\(m\)</span>
are the number of vertices and edges, respectively.</p>
</section>
<section id="lemma-3-4-10">
<h3><strong>Lemma 3.4.10</strong><a class="headerlink" href="#lemma-3-4-10" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p><strong>Statement:</strong> Kosaraju's algorithm finds the strongly connected components in topological sort order.</p>
<p><strong>Proof:</strong> We prove the statement by induction on the number of strongly connected components. For one component, the correctness of the statement is trivial. Now, assuming the statement holds for
<span class="math notranslate nohighlight">\(n-1\)</span>
components, we prove it for
<span class="math notranslate nohighlight">\(n\)</span>
components. If an edge enters the first component we find in the algorithm (say
<span class="math notranslate nohighlight">\(H\)</span>
) from another component (say
<span class="math notranslate nohighlight">\(L\)</span>
), then in the transpose graph, there is an edge from
<span class="math notranslate nohighlight">\(H\)</span>
to
<span class="math notranslate nohighlight">\(L\)</span>
. Since in the algorithm,
<span class="math notranslate nohighlight">\(L\)</span>
is found <em>after</em>
<span class="math notranslate nohighlight">\(H\)</span>
, it implies that during the traversal of
<span class="math notranslate nohighlight">\(H\)</span>
in the transpose graph, some vertices of
<span class="math notranslate nohighlight">\(L\)</span>
should be visited and placed within
<span class="math notranslate nohighlight">\(H\)</span>
, whereas components cannot overlap. Therefore, the first component we find has no incoming edges from other components and is the first component in the topological sort. Now, by the induction hypothesis, the remaining components are also found in topological sort order (Why?), and the statement is proven.</p>
</section>
<section id="algorithm-implementation">
<h3><strong>Algorithm Implementation</strong><a class="headerlink" href="#algorithm-implementation" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>Note that at the end of the code, we output the components in their topological sort order.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5e5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="c1">/// number of vertices and edges</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gr</span><span class="p">[</span><span class="n">MX</span><span class="p">],</span><span class="w"> </span><span class="n">back_gr</span><span class="p">[</span><span class="n">MX</span><span class="p">],</span><span class="w"> </span><span class="n">comp</span><span class="p">[</span><span class="n">MX</span><span class="p">];</span><span class="w"> </span><span class="c1">/// adjacency list, adjacency list (reversed edges), strongly connected components</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="p">;</span><span class="w"> </span><span class="c1">/// sorting vertices based on DFS finish times</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">mark</span><span class="p">[</span><span class="n">MX</span><span class="p">];</span><span class="w"> </span><span class="c1">/// mark array to check visited vertices</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="w">  </span><span class="c1">/// normal DFS!</span>
<span class="w">    </span><span class="n">mark</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">gr</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">                   </span><span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">sk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">back_dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="p">){</span><span class="w">  </span><span class="c1">/// DFS on reversed edges!</span>
<span class="w">    </span><span class="n">mark</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">comp</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">back_gr</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">                    </span><span class="n">back_dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="c1">/// vertex numbers are 0-based.</span>
<span class="w">                </span><span class="n">gr</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"> </span><span class="c1">/// this vector stores edges</span>
<span class="w">                </span><span class="n">back_gr</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="c1">/// this vector stores reversed edges</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                    </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fill</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span><span class="w"> </span><span class="n">mark</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">/// since we want to start a new DFS, we reset mark to 0.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">sk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="c1">/// stack is quite slow. Here, stack is used merely for better understanding. It&#39;s better to use a vector.</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">sk</span><span class="p">.</span><span class="n">top</span><span class="p">()]){</span><span class="w"></span>
<span class="w">                        </span><span class="n">back_dfs</span><span class="p">(</span><span class="n">sk</span><span class="p">.</span><span class="n">top</span><span class="p">(),</span><span class="w"> </span><span class="n">cnt</span><span class="p">);</span><span class="w"> </span><span class="c1">/// we find one component</span>
<span class="w">                        </span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">sk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">/// we print the components in their topological sort order</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">comp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="3.html" style="float:left;" title="Directed Acyclic Graph" accesskey="p"><i class="fa fa-chevron-left"></i>&nbsp; Previous</a>
                    
                    
                    <a href="5.html" style="float:right;" title="Detecting Cycles in a Directed Graph" accesskey="n">Next &nbsp;<i class="fa fa-chevron-right"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    This book is made by
                    <a href="/contributors">
                    The Shaazzz contributors.
                    </a>
                </p>
                <p>
                    It is publicly available with
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        cc-by-sa
                    </a>
                    license.
                </p>
                    <p style="font-size: 13px;">
                        Last updated at اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        Rendered by <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) and <a href="https://github.com/saeiddrv/SphinxMinooTheme">Minoo theme</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>