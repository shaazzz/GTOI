الگوریتم پیدا کردن قطر درخت
===========================

یکی دیگر از مسائلی که در حالت کلی گراف np است اما در درخت ها به سادگی حل می شود مسئله پیدا کردن بلندترین مسیر است! از آنجایی که در درخت ها مسیر بین هر دو راس یکتا است می توان نتیجه گرفت قطر درخت همان بلندترین مسیر درخت می باشد. در این بخش روش های پیدا کردن قطر درخت را با پیچیدگی زمانی :math:`O(n)` بررسی می کنیم.

استفاده از dp
-------------------

درخت را از راس 1 ریشه دار کنید. با استفاده از برنامه نویسی پویا دو متغیر زیر را به ازای هر راس :math:`u` به دست می آوریم.

- مقدار :math:`dp_u` برابر است با بیشترین فاصله راس :math:`u` با یک راس درون زیردرخت خود :math:`u`. 
- مقدار :math:`ans_u` برابر است با اندازه قطر در زیردرخت :math:`u`.

واضح است که جواب مسئله برابر است با :math:`ans_1`. حالا تنها مسئله باقی مانده این است که چگونه این دو متغیر را به دست آوریم.

برای به دست آوردن :math:`dp_u` کافی است توجه کنید که در اولین حرکت از :math:`u` به یکی از بچه هایش می رویم. پس باید به بچه ای برویم که مقدار :math:`dp` آن بیشینه است. 

برای به دست آوردن :math:`ans_u` حالت بندی کنید که راس :math:`u` درون قطر باشد یا نباشد.

- اگر راس :math:`u` درون قطر نباشد مقدار :math:`ans_u` برابر با بیشینه :math:`ans` بچه های :math:`u` خواهد بود زیرا که قطر کاملا درون یکی از بچه ها خواهد بود.
- در غیر اینصورت اگر راس :math:`u` انتهای قطر باشد جواب برابر با :math:`dp_u` خواهد بود.
- در غیر اینصورت راس :math:`u` باید وسط یک مسیر باشد. حالت بندی کنید که دو سر آن به کدام یکی از بچه ها برود. اگر به بچه :math:`a, b` برود جواب برابر با :math:`2 + dp_a + dp_b` خواهد بود. پس کافیست :math:`a, b` را دو بچه ای انتخاب کنیم که مقدار :math:`dp` آن ها بیشینه است.

در کد زیر در :math:`mx1, mx2` به ترتیب راس های با بیشترین :math:`dp` را نگه داری می کنیم.

.. code-block:: cpp
  
  const int maxn = 1e5 + 10;

  vector<int> g[maxn];
  int dp[maxn], ans[maxn];

  void dfs(int u, int par = 0){
     int mx1 = -1, mx2 = -1;
     for(int y : g[u]){
	 if(y != par){
             dfs(y, u);
             dp[u] = max(dp[u], 1 + dp[y]);
             ans[u] = max(ans[u], ans[y]);
             if(mx1 == -1 || dp[mx1] < dp[y]){
                  mx2 = mx1;
                  mx1 = y;
             }
             else if(mx2 == -1 || dp[mx2] < dp[y]){
                  mx2 = y;
             }            
         }
     }
     ans[u] = max(ans[u], dp[u]);
     if(mx1 != -1 && mx2 != -1){
	  ans[u] = max(ans[u], 2 + dp[mx1] + dp[mx2]);
     }
  }


پس توانستیم الگوریتمی ارائه دهیم که با پیچیدگی زمانی :math:`O(n)` قطر درخت را پیدا می کند.

dfs up/down
-----------------------

گاهی هدف ما به دست آوردن یک متغیر مثل :math:`dp` به ازای هر راس درخت است اما حساب کردن مقدار :math:`dp_u` نیاز به داشتن مقدار :math:`dp` تمام مجاور های راس :math:`u` (و نه فقط بچه های :math:`u`) دارد.

ساده ترین مثال برای معرفی این تکنیک مسئله پیدا کردن بیشترین فاصله از هر راس است. فرض کنید می خواهیم به ازای هر راس :math:`u` خروج از مرکز این راس را داشته باشیم. جواب راس :math:`u` را :math:`ans_u` بگیرید. برای به دست آوردن جواب یک راس می توان به راحتی درخت را از این ارتفاع آویزان کرد و در :math:`O(n)` ارتفاع درخت را حساب کرد. اما آیا می توان مسئله را به ازای تمام راس با هم در :math:`O(n)` حل کرد؟

اولین مشکل ما این است که چون حساب کردن جواب یک راس به داشتن جواب مجاور هایش نیاز دارد نمی دانیم که محاسبه را از کجا شروع کنیم!

درخت را از راس :math:`u` ریشه دار کنید. شکاندن مسئله به دو بخش می تواند مفید باشد. فرض کنید :math:`dpDown_u` برابر است با بیشترین فاصله از راس :math:`u` به راسی درون زیردرخت راس :math:`u`. همچنین :math:`dpUp_u` برابر است با بیشترین فاصله از راس :math:`u` به راسی خارج از زیردرخت راس :math:`u` (یعنی در اولین گام باید به پدر :math:`u` برویم). واضح است که جواب راس :math:`u` برابر با بیشینه دو عدد :math:`dpDown_u` و :math:`dpUp_u` است.

همانطور که در قسمت بالا بررسی کردیم :math:`dpDown_u` را می توان از روی :math:`dpDown` بچه های راس :math:`u` حساب کرد.

برای حساب کردن :math:`dpUp_u` توجه کنید که بعد از اینکه از :math:`u` به پدر :math:`u` رفتیم می توانیم دو راه در پیش بگیریم.

- می توانیم باز هم به بالا برویم. در اینصورت جواب برابر با :math:`1 + dpUp_{par}` است(فرض کنید :math:`par` پدر راس :math:`u` است).
- می توانیم به پایین برویم یعنی به یکی از برادر های :math:`u` مثل :math:`w` بریم. سپس باید پایین برویم. در اینصورت جواب برابر با :math:`2 + dpDown_w` می باشد.

نکته کلیدی این است که نیاز نیست هر بار تمام برادر های :math:`u` را بررسی کنیم که راس با :math:`dpDown` بیشینه (همان :math:`w` را پیدا کنیم). کافی است به ازای :math:`par` تنها یک بار دو بچه ای که :math:`dpDown` آن ها بیشینه است را به دست بیاوریم. همواره راس :math:`w` یکی از دو بچه :math:`par` است که :math:`dpDown` آنها بیشینه است. (چرا؟)


پس فهمیدیم که به چه صورت باید متغیر ها را به دست بیاوریم. اما همچنان یک مشکل حل نشده باقی مانده است. به چه ترتیبی باید به دست آوردن مقادیر را انجام دهیم. برای به دست آوردن :math:`dpDown` نیاز داریم که مقادیر بچه ها و برای به دست آوردن :math:`dpUp` نیاز داریم که مقادیر پدر را داشته باشیم. پس از کدام یک باید شروع کنیم؟

جواب ساده و هوشمندانه است. می توانیم طی دومرحله مقادیر را به دست بیاوریم. یک بار :math:`dpDown` ها را با استفاده از dfsDown و سپس :math:`dpUp` ها را با استفاده از dfsUp به دست بیاوریم! نکته اینجاست که در dfsDown ابتدا مقدار بچه ها به دست می آیند سپس مقدار راس فعلی. اما در dfsUp ابتدا مقدار پدر به دست می آید سپس مقدار بچه ها از روی پدر به دست می آیند!

توجه کنید که در تابع dfsUp وقتی روی یک راس هستیم فرض کرده ایم که :math:`dpUp` آن راس به دست آمده است و سپس :math:`dpUp` بچه های آن را به دست می آوریم.

.. code-block:: cpp
  
  const int maxn = 1e5 + 10;

  vector<int> g[maxn];
  int dpUp[maxn], dpDown[maxn];

  void dfsDown(int u, int par = 0){ // aval bayad in taabe ra ejra konim
      for(int y : g[u]){
          if(y != par){
              dfsDown(y, u);
              dpDown[u] = max(dpDown[u], dpDown[y]+1);
          }
      }
  }
  void dfsUp(int u, int par = 0){
     int mx1 = -1, mx2 = -1;
     for(int y : g[u]){
	 if(y != par){
             if(mx1 == -1 || dpDown[mx1] < dpDown[y]){
                  mx2 = mx1;
                  mx1 = y;
             }
             else if(mx2 == -1 || dpDown[mx2] < dpDown[y]){
                  mx2 = y;
             }            
         }
     }
     for(int y : g[u]){
	 if(y != par){
              if(y == mx1){
                  dpUp[y] = dpUp[u]+1;
                  if(mx2 != -1)
                      dpUp[u] = max(dpUp[u], doDown[mx2]+2);
              }
              else{
                  dpUp[y] = max(dpUp[u]+1, doDown[mx1]+2);
              }
              dfsUp(y, u);
         }
     }
  }

 
خواص اکسترمالی قطر
------------------------------


یک الگوریتم ساده تر
---------------------------




