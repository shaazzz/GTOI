بلمن فورد
============

صورت مسئله
-----------

یک گراف جهت دار وزن دار 
:math:`G`
داریم. وزن یال های :math:`G` میتواند منفی نیز باشد. میدانیم گراف :math:`G` دور با مجموع وزن منفی ندارد. 

حال میخواهیم به ازای هر راس طول کوتاه ترین مسیر از راس :math:`sc` به بقیه رئوس را پیدا کنیم که طول یک مسیر برابر جمع وزن های یال های آن است.

الگوریتم بلمن فورد
-------------------

برای حل این مسئله ابتدا یک :math:`dp` با ابعاد
:math:`|V(G)| * |V(G)|`
تعریف میکنیم که :math:`dp_{i,j}` برابر طول کوتاه ترین گشت از راس :math:`sc` به راس :math:`j` است که تعداد یال های این گشت حداکثر برابر :math:`i` است.

حال میدانیم طول کوتاه ترین گشت بین 2 راس در گراف :math:`G` برابر طول کوتاه ترین مسیر نیز میباشد چون اگر کوتاه ترین گشت دارای 2 راس تکراری باشد یک دور داریم که طول آن مثبت است (طبق فرض سوال نمیتواند طول دور منفی باشد.) پس میتوان ان را حذف کرد و به یک گشت با طول کمتر رسید که تناقض است.

حال برای پایه های این دپپی میدانیم که :math:`dp_{i, sc} = 0` و
:math:`dp_{0, u \neq sc} = \infty`
است. حال برای بدست اوردن :math:`dp_{i, j}` روی تمامی یال هایی که به :math:`j` وارد میشوند حالت بندی میکنیم. اگر به ازای هر یال :math:`e` که از :math:`u_e` به :math:`j` وارد می شود و وزن آن :math:`w_e` است، مقدار
:math:`dp_{i-1, u_e} + w_e`
را حساب کنیم کمینه این مقدارها جواب 
:math:`dp_{i, j}`
می شود. در نتیجه :

   :math:`dp_{i, j} = \displaystyle{\min_{\forall \, e \: \in \: N_{j}^{-}(j)}} dp_{i-1, u_e} + w_e`

برای بدست آوردن طول کوتاه ترین مسیر از راس :math:`sc` به راس :math:`u` داشتن مقدار :math:`dp_{n-1, u}` کافی است. چون که مسیر از راس :math:`sc` به یک راس دیگر حداکثر دارای :math:`n` راس و :math:`n-1` یال است و طبق تعریف دیپی و اینکه کوتاه ترین گشت بین 2 راس در :math:`G` حتما مسیر است، این مقدار دقیقا همان مقدار مورد نیاز است.

تحلیل اردر
-----------

برای اپدیت کردن کل خانه های :math:`dp_i` به ازای هر راس به اندازه درجه ورودی آن عملیات انجام داده ایم. میدانیم که جمع درجه ورودی تمام راس ها برابر 
:math:`|E(G)|`
است. پس در کل 
:math:`\mathcal{O}\left(|V(G)|.|E(G)|\right)`
عملیات انجام داده ایم. اردر حافظه استفاده شده نیز 
:math:`\mathcal{O}\left(|V(G)|^2\right)`
است.

بهینه سازی اردر حافظه
-----------------------

برای بهینه سازی مقدار حافظه مصرفی، میتوان بعد اول را حذف کرد. در نتیجه اردر حافظه مصرفی برابر 
:math:`\mathcal{O}\left(|V(G)|\right)`
میشود.

سپس 
:math:`|V(E)| - 1`
مرحله به ازای هر یال مقدار :math:`dp` راس ته یال را اپدیت کرد. منظور از اپدیت کردن این است که اگر یال :math:`e` از راس :math:`u_e` به :math:`v_e` برود و وزن آن :math:`w_e` باشد،
:math:`dp_{v_e} = min(dp_{v_e}, dp_{u_e} + w_e)`
را قرار دهیم.

 حال یک سوال پیش می آید که آیا با انجام این کار مقدار خانه های :math:`dp` همان مقدار مورد نظر باقی می ماند یا نه؟ پاسخ این سوال بله است.
  
اگر دیپی در قسمت قبلی را 
:math:`dp^{\prime}`
در نظر بگیریم بعد از مرحله :math:`i`م اپدیت کردن :math:`dp` میدانیم :math:`dp_u` برابر یکی از 
:math:`dp_{i, u}^{\prime}, dp_{i+1, u}^{\prime}, \dots, dp_{n-1, u}^{\prime}`
است. (اثبات این لم بر عهده خواننده).

حال اگر بعد از مرحله :math:`n-1` مین بررسی کنیم میفهمیم که 
:math:`dp_u = dp_{n-1, u}^{\prime}` 
است. در نتیجه بعد از مرحله :math:`n-1` مین مرحله مقدار خانه های :math:`dp` همان مقدار های مطلوب است.

پیدا کردن کوتاه ترین مسیر
----------------------------

بعد از همه این صحبت ها، یک سوال برایتان پیش می آید و آن این است که اگر خود مسیر بهینه از :math:`sc` به یک راس دیگر مانند :math:`des` را بخواهیم، چه باید بکنیم؟

برای حل این پرسش باید کمی الگوریتم قبلی را تغییر دهیم. یک آرایه
:math:`|V(G)|`
عضوی کمکی به نام :math:`par` در نظر میگیریم. در ابتدا تمامی خانه های :math:`par` را برابر 1- قرار میدهیم. حال اگر در وقتی یال :math:`e` را در نظر گرفتیم 
:math:`dp_{v_e} > dp_{u_e} + w_e`
بود، 
:math:`par_{v_e}`
را برابر :math:`u_v` قرار میدهیم.

:math:`par_u`
عملا برابر راس قبلی در مسیر بهینه از :math:`sc` به :math:`u` است. برای بدست اوردن مسیر از :math:`sc` به :math:`des`، یک متغیر :math:`nw` نگه میداریم و تا وقتی که 
:math:`nw \neq sc`
است، :math:`nw` را برابر :math:`par_{nw}` قرار میدهیم و :math:`nw` را به ابتدا مسیر بدست امده فعلی اضافه میکنیم. 

برای اثبات اینکه اثبات کنیم که حتما به راس :math:`sc` میرسیم و مسیری که بدست می اوریم مسیری بهینه است، یک ارایه :math:`lst` فرض میکنیم. :math:`lst_u` برابر شماره اخرین مرحله ای است که :math:`dp_u` عوض شده است. میدانیم 
:math:`lst_u > lst_{par_u}`
است. (اثبات به عهده خواننده) پس هر بار که :math:`nw` را برابر 
:math:`par_{nw}`
می کنیم، :math:`lst_{nw}` کاهش میابد پس به دور نمیخوریم و حتما به :math:`sc` خواهیم رسید.

طول مسیر نیز برابر :math:`dp_{des}` خواهد بود چون هر مرحله اگر یک یال با وزن :math:`w` را به مسیر اضافه کنیم، مقدار :math:`dp_{nw}` دقیقا به انداره :math:`w` کاهش میابد. چون :math:`dp_{sc} = 0` است طول مسیر دقیقا برابر :math:`dp_{des}` میشود. 

دور منفی
---------

ممکن است برایتان سوال شود اگر تضمین نشود که گراف دور منفی دارد یا نه چگونه بفهمیم دور منفی داریم ؟ (در حالتی که حافظه را بهینه سازی کرده ایم).

ابتدا فرض کنید به جای 
:math:`|V(G)| - 1`
مرحله، 
:math:`|V(G)|`
مرحله اجرا میکنیم.
به یک مرحله از الگوریتم خوب میگوییم اگر مقدار حداقل یکی از خانه های  :math:`dp` عوض شود. حال میدانیم اگر مرحله  :math:`i` م خوب نباشد آنگاه مراحل بعدی نیز خوب نیستند. (اگر مقداری عوض نشود مراحل بعدی هم دقیقا همانند مصل مرحله  :math:`i` م میشوند و خانه ای عوض نمیشود).

حال اگر دور منفی نداشته باشیم طبق استدلال های قبلی مرحله :math:`|V(G)|`م حتما خوب نیست.(تمامی خانه ها به مقدار نهایی در مرحله قبل رسیده اند و عوض نخواهند شد).
حال اگر یک دور منفی وجود داشته باشد میدانیم مقدار  :math:`dp`  رِئوس آن هیچگاه ثابت نخواهد شد. خود دور منفی را میتوان چند بار طی کرد، که باعث میشود مقادیر  :math:`dp` رئوس دور به 
:math:`-\infty` 
نزدیک شوند. حال میدانیم اگر یک مرحله خوب نباشد انگاه تمامی مقادیر ثابت شده اند. طبق این حرف ها نتیجه میشود اگر دور منفی داشته باشیم تمامی مراحل خوب خواهند بود.

حال میدانیم اگر دور منفی نداشته باشیم مرحله :math:`|V(G)|` م خوب نیست و اگر دور منفی داشته باشیم :math:`|V(G)|` م حتما خوب است.
پس برای چک کردن داشتن دور منفی کافیست خوب بودن مرحله :math:`|V(G)|` م را بررسی کنیم.

برای پیدا کردن خود دور منفی مثل حالت بدون دور منفی یک ارایه کمکی به نام  :math:`par`  بگیرید و از یک راس که در مرحله :math:`|V(G)|` م عوض شده مسیر بهینه از  :math:`sc`  را پیدا کنید دور منفی در این مسیر حتما امده است. (این بخش با توجه به استدلال های همین بخش قابل اثبات است).

