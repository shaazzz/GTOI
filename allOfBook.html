<html>
  <head>
    <title>کتاب گراف برای المپیاد کامپیوتر</title>
    <style>
      img { display: block; text-align: center; max-width: 100%; }
    </style>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body dir="rtl">
    <h1>کتاب گراف برای المپیاد کامپیوتر</h1>
    <p>
      این نسخه پی دی اف، صرفا برای وجود شکل سنتی کتاب ساخته شده است و اکیدا توصیه
      می شود که به جای آن، از نسخه آنلاین استفاده کنید. مزایای استفاده از
      نسخه آنلاین کتاب عبارت اند از
      تصاویر رنگی، ظاهر زیبا، پیوند های درون کتاب و فهرست پیوند شده، نگه دارنده سوال
      حل شده، همواره به روز بودن آن و ... نسخه آنلاین کتاب را می توانید از
      https://gtoi.shaazzz.ir/
      مطالعه کنید. این کتاب شامل صد ها صفحه است، پس حتی المقدور سعی کنید آن را چاپ
      نکنید تا به محیط زیست احترام بگذارید و منابع محدود زمین را برای آیندگان باقی
      بگذارید.
    </p>
    <p>
      حق تکثیر این کتاب، برای شاززز محفوظ است. شما می توانید با شرایط مجوز
      کریتیو کامانز تخصیص - اشتراک همسان نسخه چهار بین الملل
      از این کتاب استفاده کنید. این به این معنی است که شما می توانید آزادانه
      این کتاب را مطالعه، تکثیر و تغییر دهید به شرط این که
      به نویسندگان و به این مجوز اشاره کنید و هر اثر مشتق شده از این کتاب را
      نیز با همین مجوز منتشر کنید، یعنی به دیگران اجازه دهید تا آن را تکثیر و تغییر
      دهند. برای جزییات بیشتر و متن حقوقی این مجوز، وبسایت کریتیو کامانز را ببینید.
    </p>
    <h1>مقدمات و مدل سازی با گراف</h1><p>گراف چیست؟ گراف یک سری نقطه (موجود) و خط (رابطه) است. در شکل ۱ یک گراف می بینید:
</p><img src="/_static/dot/Apple_Pineapple.svg"><p>به نقطه ها راس و به خط ها یال می گوییم. هر نقطه و هر خط می تواند نماد چیزی باشد.
</p><h2>چرا گراف؟</h2><p>گراف یک تعریف انتزاعی است. مثل ۲. در واقعیت چیزی به اسم ۲ وجود ندارد اما مثلا
۲ توپ یا ۲ سیب وجود دارند. توپ و سیب، چیز های پیچیده ای هستند و در مسائل
(مثلا مساله ۲ توپ با ۳ توپ می شود چند توپ)
این پیچیدگی تاثیر ندارد. پس ما این جزییات بی مصرف را حذف و تمرکزمان را روی
قسمت های مهم مساله می گذاریم.
</p><p>فرض کنید می خواهیم بین دو شهر مسافرت کنیم و در کشور ما بین بعضی از شهر ها جاده وجود
دارد. هر جاده طولی دارد و یا آسفالت و یا خاکی است و ما می خواهیم در کمترین زمان
ممکن از مبدا به مقصد برسیم. یک ذهن فعال به راحتی تشخیص می دهد که در این مساله
مهم نیست که بخواهیم از شهری به شهر دیگر برویم یا از کشوری به کشور دیگر یا از
روستایی به روستای دیگر. پس مساله را با یک تعریف انتزاعی مثل گراف مدل می کند. شهر ها
تبدیل به راس می شوند و جاده ها تبدیل به یال. برای هر یال می دانیم که آسفالت یا خاکی است
و طولش چقدر است. با کمی فکر بیشتر، او در می یابد که آسفالت بودن و طول جاده نیز به تنهایی
اهمیتی ندارد و تنها تاثیر خود را در زمان طی کردن یک جاده می گذارد. پس این را نیز
حذف می کند و در نهایت به یک گراف می رسد که روی هر یالش یک عدد زمان نوشته است.
</p><p>انتزاع علاوه بر ساده سازی مسائل، به ما کمک می کند که از راه خود در یک مساله، در مسائل
دیگر نیز استفاده کنیم. مثلا وقتی می فهمیم که ۲+۳=۵ دیگر فهم ۲ سیب با سه سیب می شود ۵ سیب
یا ۲ گلابی با ۳ گلابی می شود ۵ گلابی
برایمان ساده است. یا در مثال شهر ها، اگر بتوانیم مساله را برای مدل
انتزاعی "گرافی که روی هر یالش یک عدد زمان نوشته است" حل کنیم، می توانیم از همان راه حل
برای مسیریابی بسته ها در یک شبکه کامپیوتری مثل اینترنت استفاده کنیم. در صورتی که
اگر بدون رویکرد انتزاعی به مساله نگاه می کردیم ممکن بود به یک راه حل خاص منظوره برسیم
(مثلا اگر جاده آسفالت بود از جاده آسفالت برو وگرنه از خاکی برو)
این موضوع فایده انتزاع و گراف به عنوان یک تعریف انتزاعی را به ما نشان می دهد.
</p><h2>گراف در کجا ظاهر می شود؟</h2><p>مثال های ساده ای که به ذهن می رسد، مجموعه ای از انسان ها به عنوان راس و رابطه دوستی
بین آن ها به عنوان یال، شهر ها و جاده های بین شان یا شبکه های کامپیوتری که در بالا
بررسی شد است. اما در حقیقت هر جایی که با یک رابطه سر و کار داریم، گراف ظاهر می شود. مثلا
شجره نامه یک گراف است که در آن هر کس به پدر و مادر خود یال دارد. یک مثال پیچیده تر
که در ابتدا گراف بودنش به چشم نمی آید، نقشه است. می توان هر ناحیه در نقشه را یک راس
در نظر گرفت و هر دو ناحیه ای که با هم مرز مشترک داشتند را با یک یال به هم وصل کرد و
به این ترتیب یک گراف به وجود آورد:
</p><img src="/_static/naghshe.png"><p>یک مثال پیچیده تر، می تواند یک بازی باشد. برای مثال می خواهیم کل بازی شطرنج را
به یک گراف مدل کنیم. هر حالت ممکن از شطرنج را یک راس در نظر می گیریم و بین هر حالتی
که با یک حرکت بازیکنی که نوبتش است به حالت دیگر تبدیل می شود، یک یال می گذاریم. این
مدل سازی طیف وسیعی از بازی های موسوم به بازی فکری را پوشش می دهد. برخی از
الگوریتم های هوش مصنوعی
بازی ها، از این تعریف انتزاعی استفاده می کنند و برای همین می توان از یک الگوریتم در
بازی های زیادی استفاده کرد.
</p><h2>تعاریف ساده</h2><p>تعاریف به ما کمک می کنند تا منظور خود را واضح تر، دقیق تر و با کلمات کمتر بیان کنیم. نیازی
به حفظ کردن تعاریف نیست. شما با حل تمرین های این کتاب به مرور این تعاریف را یاد
می گیرید. اگر در ابتدای کار تعریفی را یادتان رفت، می توانید به این جا برگردید و
منظور از لغتی که یادتان رفته را ببینید. همچنین تمامی تعاریف این کتاب به طور خلاصه در
این صفحه </book/appendix/3>
آمده اند.
</p><p><b>راس و یال:</b>
در بالا اشاره شد. منظور نقاط و خطوط در گراف هستند.
</p><p><b>طوقه:</b>
اگر یک راس به خودش یال داشته باشد به آن یال طوقه می گوییم.
</p><p><b>یال چندگانه:</b>
اگر بین دو راس چند یال وجود داشته باشد به آن یال ها یال چندگانه می گوییم.
</p><p><b>گراف ساده:</b>
گرافی که طوقه و یال چندگانه نداشته باشد گراف ساده است. ما معمولا با گراف های ساده
سر و کله می زنیم پس نگران طوقه و یال چندگانه نباشید.
</p><p><b>درجه یک راس:</b>
تعداد یال های متصل به یک راس را درجه آن راس می نامیم. به دلایلی، طوقه را دو بار در
درجه حساب می کنیم. اگر خود راس را با
$ v $
نمایش دهیم درجه آن را با
$ d_v $
نمایش می دهیم.
</p><p><b>کمترین درجه گراف:</b>
کمترین درجه گراف را با حرف یونانی دلتای کوچک نمایش می دهند. اگر تنها یک گراف
مورد بحث باشد، به سادگی از
$ \delta $
و اگر چند گراف مانند
G و H
مورد بحث باشند از
$ \delta (G) $ و $ \delta (H) $
استفاده می کنیم.
</p><p><b>بیشترین درجه گراف:</b>
بیشترین درجه گراف را با حرف یونانی دلتای بزرگ نمایش می دهند. اگر تنها یک گراف
مورد بحث باشد، به سادگی از
$ \Delta $
و اگر چند گراف مانند
G و H
مورد بحث باشند از
$ \Delta (G) $ و $ \Delta (H) $
استفاده می کنیم.
</p><p><b>مکمل یک گراف ساده:</b>
منظور از مکمل یک گراف، گرافی است که راس های آن همان راس های گراف اصلی هستند اما بین
هر دو راسش یال هست اگر و تنها اگر بینشان در گراف اصلی یالی نباشد. طبق تعریف، مکمل
مکمل یک گراف، خود آن گراف است. مکمل گراف G را با
$ \overline{G} $
نمایش می دهند. در شکل زیر، دو گراف چهار راسی قرمز و آبی مکمل
یک دیگر هستند:
</p><img src="/_static/dot/Complement_Graph.svg"><h2>جمع تمامی درجات</h2><p>در این قسمت یک قضیه ساده از گراف را با هم اثبات می کنیم. خوب است قبل از خواندن جواب
کمی به راه حل آن فکر کنید. قضیه بیان می کند که جمع درجه تمامی رئوس گراف دو برابر
تعداد یال هاست یا به عبارتی دیگر
$ \sum d_v = 2e $
</p><p>برای اثبات این قضیه، تاثیر هر یال را روی جمع درجات تمامی رئوس بررسی می کنیم. یک
یال عادی درجه سر و تهش را یک واحد افزایش می دهد و یک طوقه درجه راسش را دو واحد
پس هر یال جمع درجات را دقیقا دو واحد اضافه می کند پس جمع درجات دو برابر تعداد
یال هاست.
</p><h1>انواع گراف</h1><p>در این قسمت یسری گراف های معروف و شناخته شده رو براتون لیست کردیم.
قبل از اینکه با آن ها آشنا شویم به این نکته توجه کنید که در این قسمت هرجا صحبت از
n
شده منظور تعداد راس های گراف بوده است.
آشنایی با این گراف ها به شما کمک می کند تا با گراف ها بیشتر انس بگیرید و هم چنین
در ادامه بعضا در تمارین و درس نامه و
یا حتی متون دیگر گراف به این گراف ها اشاره می شود و از توضیحشان
صرف نظر می شود. هر گاه که تعریف یکی از این گراف ها یادتان رفت می توانید
به این صفحه برگردید و آن را مرور کنید.
</p><h2>گراف کامل</h2><p>به گراف G که به ازای هر دو راس u و v یک یال بینشون وجود داشته باشه گراف کامل می گوییم که آن را با 
$ K_n $ نشان می دهند.
</p><img src="/_static/complete_graph.jpg"><h2>گراف تهی</h2><p>به گراف G که در آن هیچ یالی وجود ندارد گویند. در واقع گراف تهی مکمل گراف کامل است که آن را با 
$ \overline{K_n} $ نشان می دهند.
</p><img src="/_static/empty_graph.png"><h2>گراف مسیر</h2><p>به گراف G که در آن تعداد یال ها n - 1 و درجه راس ها حداکثر ۲ باشد گویند.
گراف مسیر را با 
$ P_n $ نشان می دهند.
</p><img src="/_static/path_graph.png"><h2>گراف دور</h2><p>به گراف G که در آن درجه تمامی راس ها ۲ است و می توان با پیمودن چند یال از هر راسی به راس دیگری رفت.
گراف دور را با 
$ C_n $ نشان می دهند.
</p><img src="/_static/cycle_graph.png"><h2>گراف منتظم</h2><p>به گرافی که درجه تمامی رئوسش برابر باشد، گراف متنظم می گوییم. اگر درجه تمامی رئوس برابر و برابر با k باشد به آن گراف k-منتظم می گوییم.
</p><img src="/_static/regular_graphs.png"><h2>گراف پیترسن ( Petersen )</h2><p>در این بخش بر خلاف بخش های دیگر که گراف های زیادی رو شامل میشدن، فقط یک گراف را شامل می شود.
نحوه ساخت گراف :
</p><p>یک مجموعه ۵ عضوی در نظر بگیرید و به ازای هر زیرمجموعه ۳ عضوی آن یک راس در گراف قرار می دهیم.
بین دو راس یال قرار می دهیم اگر و تنها اگر دو مجموعه متناظر آنها دقیقا در یک عضو مشترک باشند.
</p><p>گراف پیترسن ۱۰ راس و ۱۵ یال دارد که درجه هر راس آن ۳ است.
</p><img src="/_static/petersen_graph.png"><h2>گراف k بخشی</h2><p>به گرافی که بتوان راس های آن را به k بخش تقسیم کرد به طوری که به ازای هر دو راس u و v در یک بخش، به هم یال نداشته باشند.
</p><img src="/_static/dot/K_2_2_2.svg"><p>به کوچک ترین
k
ای که گراف
k بخشی
باشد، عدد رنگی آن گراف می گویند و آن را با حرف یونانی خی به صورت
$ \chi $
یا
$ \chi (G) $
نمایش می دهند.
</p><h2>گراف k بخشی کامل</h2><p>همانند گراف k بخشی که در بخش قبل تعریف شد می باشد با این تفاوت کرد که بین هر دو راس
u و v
که در یک بخش نیستند، یال وجود دارد. گراف های
k بخشی کامل را به صورت
$ K_{a_1,a_2,...,a_k} $
نمایش می دهند. برای مثال گراف
$ K_{a,b,c} $
یک گراف سه بخشی کامل است که بخش های آن
a و b و c
راس و در کل
$ a+b+c $
راس دارد.
</p><p>گراف
$ K_{3,5} $
</p><img src="/_static/dot/K_3_5.svg"><p>گراف
$ K_{2,2,2} $
</p><img src="/_static/dot/K_2_2_2.svg"><h2>گراف ستاره ( Star )</h2><p>به گراف G که یک راس u به تمامی راس های دیگر یال دارد و راس های دیگر فقط به
u
یال دارند، استار گویند.
گراف استار چون حالت خاصی از گراف دو بخشی کامل است، به شکل
$ K_{1,n} $
نمایش داده می شود که
$ n $
یال و
$ n+1 $
راس دارد.
</p><img src="/_static/star_graph.png"><h2>گراف مکعب k بعدی (Cube)</h2><p>تمام رشته باینری های به اندازه k را در نظر بگیرید. هر راس گراف را متناظر با یکی از این رشته ها می کنیم به طوری که هر رشته دقیقا یک بار متناظر شده باشد.
حال بین دو راس یال می گذاریم اگر و تنها اگر در رشته های متناظرشون دقیقا در یک رقم تفاوت داشته باشند.
برای مثال اگر k = 3 باشد گراف به شکل زیر می شود.
</p><img src="/_static/dot/Q_3.svg"><p>این گراف ها را به صورت 
$ Q_k $ نشان می دهند.
$ Q_1 $
شبیه یک خط و
$ Q_2 $
شبیه یک مربع و
$ Q_3 $
شبیه یک مکعب است. گراف
$ Q_k $
را می توان با دو کپی از
$ Q_{k-1} $
و قرار دادن یال بین رئوس متناظر این دو، ایجاد کرد. این خاصیت می تواند
به اثبات خاصیت های این گراف کمک کند. اگر کد باینری را به عنوان مختصات
k بعدی
در نظر بگیرید، گراف
$ Q_k $
تشکیل یک مکعب
k بعدی
به حجم (به معنای تعمیم یافته آن) واحد می دهد که کنج آن منطبق
با محور های مختصات است.
</p><h1>پیاده سازی گراف</h1><p>در این قسمت سعی می کنیم گراف را درون کامپیوتر ورودی بگیریم و ذخیره کنیم. مدل سازی
گراف در کامپیوتر به ما کمک می کند تا از قدرت پردازشی عظیم آن برای اجرای روش ها
و الگوریتم هایی که به صورت تئوری پیدا می کنیم استفاده کنیم. در المپیاد کامپیوتر، بسیاری
از مسائل برنامه نویسی به گراف ها مربوط هستند و باید برای حل آن ها گراف را به روش مناسبی
ورودی گرفت و ذخیره کرد.
</p><h2>گراف را چگونه به ما ورودی می دهند؟</h2><p>یک روش استاندارد ورودی دادن گراف که در سوال های المپیاد معمولا از آن استفاده می کنند، به
این صورت است که در خط اول تعداد راس ها و تعداد یال ها را به شما ورودی می دهند و در ادامه
به تعداد یال ها، در هر خط شماره دو راس سر و ته آن یال را می نویسند. برای مثال
</p><pre dir="ltr">cpp
5 6
1 2
1 3
1 4
2 5
4 5
3 4</pre><p>یک گراف ۵ راسی و ۶ یالی است و مثلا درجه راس شماره ۴ برابر ۳ است. با استفاده از برنامه وب
https://csacademy.com/app/graph_editor/
می توانید گراف بالا را به صورت گرافیکی مشاهده کنید.
</p><h2>لیست پیوندی</h2><p>اگر چه می توانیم گراف را به صورت آرایه ای از یال ها ذخیره کنیم، اما این ذخیره سازی
مناسب نیست. زیرا اگر بخواهیم به همسایه های یک راس دسترسی داشته باشیم، باید تمام
یال ها را پیمایش کنیم و این در بسیاری از استفاده ها، قابل قبول نیست.
</p><p>یک روش بهتر، لیست پیوندی است. منظور از لیست پیوندی، لیستی است که پیوند ها (راس های
همسایه که با یال به این راس پیوند دارند) را نگه می دارد.
در این روش ما برای هر راس یک آرایه با اندازه متغیر
یا همان وکتور در سی پلاس پلاس نگه می داریم و لیست همسایه های هر راس را درون آن می ریزیم. کد
این روش به شکل زیر خواهد شد:
</p><pre dir="ltr">cpp
const int M = 1e5 + 5; // bishine tedad rase momken ke dar soal maloom mishavad
vector&lt;int&gt; list_peyvandi[M];
int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; i += 1) {
    int u, v;
    cin &gt;&gt; u &gt;&gt; v;
    list_peyvandi[u].push_back(v);
    list_peyvandi[v].push_back(u);
  }
}</pre><p>مزایای این روش این است که اولا می شود با مرتبه زمانی درجه یک راس، همسایه های آن
را پیمود و دوم این که حافظه و زمان اجرای آن از
$ O(N+E) $
است. (دقت کنید که در فصل قبل خواندیم که جمع درجات تمامی رئوس دو برابر تعداد
یال ها است) این زمان خطی بهترین پیچیدگی ای است که می توان به دست آورد چون خود
عملیات ورودی گرفتن همین قدر طول می کشد.
</p><h2>به دست آوردن اطلاعات مفید از گراف</h2><p>در این قسمت می خواهیم مقادیری که در بخش قبل تعیین کردیم را برای گراف ورودی به دست
آوریم. این اطلاعات شامل درجه هر راس، همسایه های هر راس و ماکسیمم و مینیمم درجات
است. خوب است قبل از خواندن کد، خودتان سعی کنید تا آن را پیاده سازی کنید.
</p><pre dir="ltr">cpp
const int M = 1e5 + 5; // bishine tedad rase momken ke dar soal maloom mishavad
vector &lt;int&gt; list_peyvandi[M];
int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= m; i += 1) {
    int u, v;
    cin &gt;&gt; u &gt;&gt; v;
    list_peyvandi[u].push_back(v);
    list_peyvandi[v].push_back(u);
  }
  int dmin = M + 5;
  int dmax = -1;
  for (int u = 1; u &lt;= n; u += 1) {
    cout &lt;&lt; &quot;Rase shomare: &quot; &lt;&lt; u &lt;&lt; &quot;\n&quot;;
    int d = list_peyvandi[u].size();
    cout &lt;&lt; &quot;Daraje: &quot; &lt;&lt; d &lt;&lt; &quot;\n&quot;;
    if (dmin &gt; d) dmin = d;
    if (dmax &lt; d) dmax = d;
    cout &lt;&lt; &quot;Hamsaye ha: &quot;;
    for (int v: list_peyvandi[u]) {
      cout &lt;&lt; v &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; &quot;\n&quot;;
  }
  cout &lt;&lt; &quot;Delta koochak: &quot; &lt;&lt; dmin &lt;&lt; &quot;\n&quot;;
  cout &lt;&lt; &quot;Delta bozorg: &quot; &lt;&lt; dmax &lt;&lt; &quot;\n&quot;;
}</pre><h2>اطلاعات جانبی</h2><p>این مساله را در نظر بگیرید: یک باغ داریم که چند درخت دارد و درخت ها هر کدام با جاده
به درخت های دیگر وصل هستند. (در فضای خالی علف هست و فقط از جاده ها می شود رفت) زمان
پیموده شدن هر جاده و تعداد سیب های هر درخت را می دانیم. می خواهیم در
k
دقیقه بیشترین سیب ممکن را بچینیم. ورودی به صورت گراف، می تواند به شکل زیر باشد. اول
تعداد رئوس (n)، یال ها (m) و وقتی که داریم (k)
در خط اول داده می شود. در خط بعدی
n
عدد که تعداد سیب های هر درخت و در
m
خط بعد در هر خط سه عدد که به ترتیب شماره ابتدا، انتها و زمان مورد نیاز جاده است. پس
یک مثال می تواند مثال زیر باشد:
</p><pre dir="ltr">cpp
5 6 43.2
1 2 100 5 3
1 2 20
1 3 3.5
1 4 7.1
2 5 100.2
4 5 31
3 4 1.1</pre><p>ما در این قسمت به راه حل بهینه این مساله نمی پردازیم، بلکه هدف ما بررسی نحوه ورودی
گرفتن این گراف و ذخیره آن در یک لیست پیوندی است. روشی که در بالا گفتیم، یک ایراد دارد
و آن این است که زمان هر یال را از دست می دهد و نمی تواند در جایی ذخیره کند. برای
رفع این مشکل، به جای ذخیره راس های همسایه در لیست پیوندی، شماره یال را نگه داریم
و برای هر یال، دو سر آن و زمان آن را در آرایه نگه داریم. تنها نکته ای که باید به آن
توجه کرد، این است که به ازای هر راس نمی دانیم که این راس به عنوان سر یال ذخیره شده
است یا به عنوان ته یال و این به دست آوردن سر دیگر یال را کمی سخت می کند. یک راه
حل این است که دو سر یال را جمع بزنیم و از راس فعلی کم کنیم. چون یکی از آن ها همان
راس فعلی است، سر دیگر یال به دست می آید. یک راه دیگر این است که دو سر یال و راس
فعلی را با هم ایکس اور کنیم که چون ایکس اور
هر عددی با خودش برابر صفر است، مثل حالت چمع و تفریق، سر دیگر به دست می آید. ایکس اور در
کامپیوتر ها اندکی سریع تر است اما اگر عملیات های بیتی را بلد نیستید یا با آن ها
حال نمی کنید، از همان روش جمع و تفریق استفاده کنید. در کد زیر از ایکس اور استفاده
کرده ایم.
</p><pre dir="ltr">cpp
const int Mras = 1e5 + 5; // bishine tedad rase momken ke dar soal maloom mishavad
const int Myal = 3e5 + 5; // bishine tedad yale momken ke dar soal maloom mishavad
vector&lt;int&gt; list_peyvandi[Mras];
int sib[Mras];
int u[Myal], v[Myal];
double zaman[Myal];
int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  for (int e = 1; e &lt;= m; e += 1) { // e shomare yal ast
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    list_peyvandi[x].push_back(e); // deghat konid ke ba bala fargh darad
    list_peyvandi[y].push_back(e); // shomare yal rikhte shode
  }
  // dar edame hamsaye haye har ras raa chap mikonim
  for (int x = 1; x &lt;= n; x += 1) {
    cout &lt;&lt; &quot;Rase shomare: &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; &quot;Hamsaye ha: \n&quot;;
    for (int e: list_peyvandi[x]) {
      int y = u[e] ^ v[e] ^ x; // be dast avardane sare digar
      //  y = u[e] + v[e] - x; ham mishod
      //  y = u[e] == x ? v[e] : u[e]; ham mishod
      cout &lt;&lt; &quot;  hamsaye = &quot; &lt;&lt; y &lt;&lt; &quot;, zaman = &quot; &lt;&lt; zaman[e] &lt;&lt; &quot;\n&quot;;
    }
  }
}</pre><h2>یک الگوریتم واقعی</h2><p>به عنوان پایان این بخش می خواهیم از چیزی که یاد گرفتیم استفاده کنیم. این راه
حل برای مساله بالا را در نظر بگیرید: هر مرحله کوتاه ترین یالی که سیب هایش را نچیده
ایم را می پیماییم تا زمانی که وقتمان تمام شود یا به یک راس برسیم که همه سیب های
همسایه هایش چیده شده باشند. خوب است قبل از دیدن کد، خودتان تلاش کنید تا آن را پیاده
کنید.
</p><pre dir="ltr">cpp
const int Mras = 1e5 + 5; // bishine tedad rase momken ke dar soal maloom mishavad
const int Myal = 3e5 + 5; // bishine tedad yale momken ke dar soal maloom mishavad
vector &lt;int&gt; list_peyvandi[Mras];
int sib[Mras];
int u[Myal], v[Myal];
double zaman[Myal];
bool chide[Mras];
int main() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  for (int e = 1; e &lt;= m; e += 1) { // e shomare yal ast
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    list_peyvandi[x].push_back(e); // deghat konid ke ba bala fargh darad
    list_peyvandi[y].push_back(e); // shomare yal rikhte shode
  }
  // liste peyvandi ra bar hasbe zaman moratab mikonim
  for (int x = 1; x &lt;= n; x += 1) {
    // sort yeki az por karbord tarin tabe haye c++ ast. agar
    // balad nistid beravid yaad begirid
    sort(list_peyvandi[x].begin(), list_peyvandi[x].end(), [](int a, int b) {
      // in yek lambda function ast ke jozve ghabeliat haye c++14 ast.
      // agar balad nistid, mitavaanid be saadegi in taabe raa
      // baalaa tarif konid yaa in ke beravid yaad begirid
      return zaman[a] &lt; zaman[b];
    });
  }
  int cur = 1; // rase mabda raa ras 1 dar nazar migirim
  int score = 0; // sib haye chide shode in ja zakhire mishavand
  while (k &gt; 0) {
    chide[cur] = true;
    score += sib[cur];
    bool berim = false;
    int koja = -1;
    for (int e: list_peyvandi[cur]) {
      int nxt = u[e] ^ v[e] ^ cur;
      if (chide[nxt]) continue;
      if (zaman[e] &gt; k) break;
      berim = true;
      koja = nxt;
      k -= zaman[e];
      break;
    }
    if (!berim) break;
    cur = koja;
  }
  cout &lt;&lt; score;
}</pre><p>توجه کنید که این راه حل صرفا یک راه حل حریصانه است و یک راه حل بهینه نیست. برای
تمرین می توانید خودتان یک مثال بزنید که این کد رفتار بهینه ای نشان نمی دهد و
بهترین جواب را به دست نمی آورد.
</p><p>اما به هر حال، این کد قدرت لیست پیوندی را نشان می دهد. پیچیدگی زمانی کد بالا
$ O(n+mlg(m)) $
است اما بدون لیست پیوندی به سختی می توانستید با زمان بهتر از
$ O(nm) $
این الگوریتم را پیاده سازی کنید.
</p><h1>گشت، گذر، مسیر، اکسترمال</h1><p>تا کنون هر چه که از گراف دیدیم تفاوت خاصی با ساختار های معمول در ریاضیات مانند لیست ها
و مجموعه ها نداشت. اما با تعاریف این بخش می توانیم قضایایی را ثابت کنیم که بدون استفاده
از گراف، بسیار پیچیده به نظر می رسند.
</p><h2>گشت</h2><p>به یک دنباله مانند دنباله
$ v_1e_1v_2e_2...v_{k-1}e_{k-1}v_k $
گشت می گوییم اگر و تنها اگر v ها راس و e ها یال باشند و هر یال
بین دو راس مربوط به خودش قرار گرفته باشد. اگر گراف را مانند یک شهر در نظر بگیریم
که جاده های آن یال های گراف هستند، حرکت یک موجود در این شهر یک گشت است.
</p><p>اگر راس سر و ته گشت یکی باشند (موجود به نقطه ابتدایی اش برگشته باشد)
به این گشت یک گشت بسته می گوییم.
</p><img src="/_static/dot/Simple_Weighted_Graph.svg"><p>در گراف بالا،
$ a1b4d6d $
و
$ b1a1b2a1b3c $
و
$ a1b4d5c3b4d4b2a $
مثال هایی از گشت هستند. گشت آخر، یک گشت بسته است. طول یک گشت را تعداد یال های
آن تعریف می کنیم. گشت های بالا به ترتیب به طول ۳ و ۵ و ۷ می باشند. اگر گراف ساده
بود، ذکر دنباله رئوس کافی بود و نیازی نبود یال ها را نام گذاری کنیم و آن
ها را درون گشت معین کنیم.
</p><h2>گذر</h2><p>گذر گشتی است که یال تکراری نداشته باشد. به یک گذر که راس ابتدا و انتهای آن یکی باشد، مشابه
قسمت قبل، یک گذر بسته می گوییم.
</p><img src="/_static/dot/Simple_Weighted_Graph.svg"><p>در گراف بالا،
$ a1b4d6d $
و
$ a1b4d5c3b2a $
مثال هایی از گذر هستند. گذر آخر، یک گذر بسته است.
</p><h2>دور و مسیر</h2><p>مسیر، گشتی است که راس تکراری نداشته باشد. واضح است که هر مسیری یک گذر نیز هست. طبق تعریف،
مسیری که راس ابتدا و انتهای آن یکی باشد وجود ندارد.
(به استثنای مسیر های یک راسی یا به طول صفر)
اما اگر در گشتی، تنها راس ابتدا
و انتها یکی بودند، به آن گشت یک دور می گوییم.
گشت های یک راسی (صفر یالی یا به طول صفر) دور حساب نمی شوند.
اگر یک گراف ساده باشد، دور به طول یک و دو نیز ندارد.
</p><img src="/_static/dot/Simple_Weighted_Graph.svg"><p>در گراف بالا،
$ a1b3c5d $
یک مسیر و
$ a1b2a $
و
$ d6d $
و
$ b3c5d4b $
دور های این گراف هستند.
</p><h2>چند مثال</h2><p>تعاریف بالا اگر چه تعاریف ساده ای هستند اما در اثبات قضایای گراف کمک بسیاری به ما خواهند
کرد. در زیر چند مثال با هم می بینیم.
</p><h3>اگر گشتی بین دو راس وجود داشته باشد، مسیری بین آن دو وجود دارد</h3><p>منظور از گشت بین دو راس u و v
،گشتی است که راس ابتدای آن 
u و راس انتهای آن v
باشد. برای اثبات گزاره، کافیست که بین تمام گشت های بین این دو، گشتی را در نظر بگیریم
که کمترین یال را دارد. این گشت، یک مسیر است چون اگر راس تکراری داشته باشد، یعنی
گشت به صورت
</p>$$ v_1e_1 .. e_{i-1} x e_i ... x e_j .... e_{k-1}v_k $$<p>باشد، گشتی با یال کمتر وجود دارد (گشت زیر)
</p>$$ v_1e_1 .. e_{i-1} x e_j .... e_{k-1}v_k $$<p>که با فرض ما در تناقض است.
</p><h3>اگر درجه تمام رئوس حداقل ۲ باشد، در گراف دور وجود دارد</h3><p>گراف های بدون دور خواص جالبی دارند که آن ها را به طور گسترده در فصل ۲ بررسی
خواهیم کرد. اما اکنون به این قضیه که در گراف بدون دور حتما راسی با درجه کمتر از ۲
وجود دارد، بسنده می کنیم.
</p><p>برای اثبات، بلند ترین مسیر (یعنی مسیری که بیشترین یال ممکن را دارد) را در نظر می گیریم.
توجه کنید که اگر در استدلال مان بلند ترین گشت را در نظر می گرفتیم، استدلال ما معتبر نبود
و ممکن بود به نتایج نادرستی برسد زیرا بلند ترین گشت ممکن است وجود نداشته باشد. اما
چون هر مسیر حداکثر
n راس و بنابراین n-1
یال دارد، می توان بلند ترین مسیر موجود در گراف را در نظر گرفت.
</p><p>راس ابتدای این مسیر، نمی تواند به راسی خارج از این مسیر (مثلا راس قرمز) یال داشته باشد چون در این صورت
مسیری بزرگتر وجود داشت. پس تمام یال های این راس درون همین مسیر هستند. و چون درجه این راس
حداقل ۲ است، به جز راس مجاورش در مسیر حتما به یک راس دیگر نیز یال دارد (یال خط چین) و این یعنی
دور وجود دارد.
</p><img src="/_static/dot/Deg_2.svg"><h3>یال های هر گرافی که تمام درجاتش زوج باشد را می توان به دور ها افراز کرد</h3><p>اگر گراف بدون یال باشد که حکم اثبات شده است. در غیر این صورت، اگر راس های درجه صفر را در
نظر نگیریم طبق گزاره بالا در گراف یک دور وجود دارد. آن دور را به عنوان یک مجموعه
از افراز در نظر می گیریم و آن را حذف می کنیم. از درجه رئوس داخل دور دقیقا دو واحد کم می شود
و بنابراین درجه های گراف حاصل نیز هم چنان زوج می ماند. آن قدر این کار را ادامه می دهیم
تا گراف خالی از یال شود و به این ترتیب افراز مورد نظر به دست آمده است.
</p><h2>چند تعریف دیگر</h2><p><b>طول یک گشت:</b>
به تعداد یال های یک گشت، همانطور که اشاره شد، طول آن گشت می گوییم. این تعریف به گذر و مسیر
نیز تعمیم داده می شود. مثلا همانطور که خواندیم
$ P_n $
گراف مسیر است. طول این مسیر،
$ n-1 $
است.
</p><p><b>فاصله بین دو راس:</b>
طول کوتاه ترین مسیر بین دو راس را فاصله بین آن دو می گویند. اگر مسیری وجود نداشته
باشد، فاصله را بی نهایت تعریف می کنیم.
</p><p><b>کمر گراف:</b>
کوتاه ترین دور گراف که بیش از ۲ راس داشته باشد. اگر گراف دور نداشته باشد، کمر
آن را بی نهایت تعریف می کنیم.
</p><p><b>مسیر و دور همیلتونی:</b>
منظور مسیر یا دوری است که تمام رئوس گراف را شامل شود.
</p><h1>زیرگراف ها</h1><p>زیرگراف یک گراف، زیر مجموعه ای از رئوس و زیر مجموعه ای از یال های بین آن رئوس را
داشته باشد.
</p><h2>زیر گراف القایی</h2><p>زیرگراف القایی یک زیر گراف است که رئوسش یک زیر مجموعه از رئوس گراف اصلی و یال
هایش تمام یال های میان آن رئوس است. هر گراف
$ n $
راسی،
$ 2^n $
زیرگراف القایی دارد.
</p><h2>زیرگراف فراگیر</h2><p>زیرگراف فراگیر یک زیرگراف است که رئوسش تمام رئوس گراف و یال هایش یک زیر مجموعه دلخواه
از یال ها باشد. هر گراف
$ m $
یالی،
$ 2^m $
زیرگراف فراگیر دارد.
</p><h2>چند نکته</h2><ul><li><p>تنها زیرگراف فراگیر القایی، خود گراف است.
</p></li><li><p>تعداد زیرگراف های یک گراف بستگی به شکل گراف دارد
</p></li></ul><h2>افراز گراف</h2><p>منظور از افراز گراف، ارائه چند زیرگراف است به طوری که یال های این زیر گراف ها
اشتراک نداشته باشند و همه یال های گراف پوشانده شده باشند. به عبارت دیگر
هر یال از گراف دقیقا در یک زیرگراف آمده باشد. به افراز می توانید مانند دسته بندی یا
رنگ آمیزی یال ها نگاه کنید. شکل زیر، افراز گراف
$ K_4 $
به دو گراف
$ P_4 $
است:
</p><img src="/_static/dot/K_4_to_P_4.svg"><h2>عدد استقلال و عدد خوشه ای</h2><p>بزرگ ترین زیر گراف القایی که هیچ یالی نداشته باشد، بزرگترین مجموعه مستقل نامیده می شود
و به اندازه راس های آن، عدد استقلال گراف می گویند و آن را با
$ \alpha $
یا
$ \alpha (G) $
نمایش می دهند. (حرف یونانی آلفا خوانده می شود)
</p><p>بزرگ ترین زیر گراف القایی که بین هر دو راسش یال باشد و به عبارتی دیگر یک گراف
کامل باشد، بزرگترین خوشه‌ی گراف نامیده می شود
و به اندازه راس های آن، عدد خوشه ای گراف می گویند و آن را با
$ \omega $
یا
$ \omega (G) $
نمایش می دهند.
(حرف یونانی اومگا خوانده می شود)
</p><p>این دو تعریف تعاریف مهمی هستند و مسائل جالبی حول آن ها مطرح می شود.
</p><h1>همبندی، یال برشی و راس برشی</h1><h2>همبندی</h2><p>گراف 
G
همبند است اگر به ازای هر دو راس 
u
و 
v یک مسیر از 
u به 
v وجود داشته باشد.
در غیر این صورت ناهمبند است. هر گراف ناهمبند اجتماعی از چند گراف همبند است که به هر کدام از آن ها <b>مولفه</b> نیز میگویند. 
واضح است که یک گراف همبند دارای یک مولفه است.
</p><p>اگر راس ها را مثل یک توپ و یال ها را مثل یک نخ در نظر بگیرید، مولفه های گراف را می توان
با دست از هم جدا کرد اما راس های هر مولفه با نخ به هم متصل هستند.
</p><h2>راس برشی </h2><p>در گراف 
G به راس 
v 
برشی گفته می شود اگر با حذف آن به تعداد مولفه های همبندی اضافه شود.
</p><h2>یال برشی </h2><p>در گراف 
G به یال 
e برشی گفته می شود اگر با حذف آن به تعداد مولفه های همبندی اضافه شود.
</p><h2>گراف k همبند</h2><p>به گراف 
k 
Gهمبند میگویند اگر بیش از 
k راس داشته باشد و با حذف 
x 
(x<k)
راس نتوان آن را ناهمبند کرد. 
به این ترتیب 
$ \kappa (G) $ تعریف می شود ماکسیمم 
k که 
G را 
k همبند می کند، به عبارت دیگر کمترین تعداد راسی که نیاز است تا با حذف آن ها گراف ناهمبند و یا راس تنها شود.
</p><h2>بلوک</h2><p>به یک زیرگراف ماکسیمال از 
G که راس برشی نداشته باشد گویند.
</p><h1>گراف دو بخشی</h1><p>همان طور که در قسمت های قبل خواندیم،
گراف دو بخشی که حالت خاصی از گراف k بخشی است،
گرافی است که بتوان رئوس آن را به دو دسته افراز کرد، به طوری که درون هر دسته
هیچ یالی نباشد و تمام یال ها بین دسته ها باشند.
</p><h2>ارتباط با دور فرد</h2><p>یک گراف دوبخشی است اگر و تنها اگر دور فرد نداشته باشد. یک طرف این قضیه واضح است
چون اگر یک گراف دور فرد داشته باشد، آن گاه در هر افراز به دو دسته، یک دسته بیش از
نیمی از رئوس این دور را خواهد داشت و در نتیجه درون آن دسته یال پیدا می شود و یعنی
گراف دو بخشی نیست.
</p><p>پس به سراغ قسمت دوم می رویم. اگر دور فرد نداشته باشد، می دانیم زوجیت طول مسیر های بین دو راس
همواره ثابت است، برای اثبات این مطلب، فرض کنید بین دو راس هم مسیر زوج یالی و هم
مسیر فرد یالی وجود داشته باشد. با چسباندن این دو مسیر به هم یک گشت بسته فرد یالی به دست می آید
و در قسمت قبل دیدیم که اگر گشت بسته فرد یالی در گراف وجود داشته باشد، دور فرد نیز وجود دارد
که این مطلب با فرض در تناقض است.
</p><p>در ادامه فرض می کنیم که گراف همبند است، زیرا اگر همبند نباشد، می توان حکم را برای
مولفه های آن ثابت کرد و نتیجه گرفت که هر مولفه دو بخشی است و سپس بخش اول هر مولفه
را به عنوان بخش یک و بخش دوم را به عنوان بخش دو معرفی می کنیم.
</p><p>یک راس دلخواه را در نظر بگیرید. چون گراف همبند است، این راس یا به هر کسی مسیر فرد یالی
دارد و یا مسیر زوج یالی. رئوس با مسیر فرد را درون دسته یک و رئوس با مسیر زوج را
درون دسته دو قرار می دهیم. برای این که نشان دهیم گراف با این دسته ها دو بخشی است، برهان
خلف می زنیم و فرض می کنیم که درون یک دسته یال وجود داشته باشد. در آن صورت
هم مسیر فرد از راس اولیه به راس ها وجود خواهد داشت و هم مسیر زوج، که تناقض است.
</p><h2>وجود زیرگراف دوبخشی با نیمی از یال ها</h2><p>هر گراف
$ m $
یالی، زیر گرافی دارد که بیش از
$ \frac{m}{2} $
یال دارد. برای اثبات، بزرگ ترین زیر گراف فراگیر دو بخشی را در نظر بگیرید. یک راس
را در نظر بگیرید که بیش از نیمی از یال هایش در سمت خودش باشند. اگر چنین
راسی وجود نداشته باشد جمع درجات رئوس در زیر گراف بیش تر مساوی نصف جمع در حالت
عادی یعنی بیشتری مساوی
m
است که از این مطلب حکم نتیجه می شود.
</p><p>اما اگر چنین راسی وجود داشته باشد، آن راس را به بخش دیگر می بریم و یال های سمت خودش
که بیش از نصف درجه اش و در نتیجه بیش از حالت قبل است، که با فرض اکسترمال
در تناقض است.
</p><h1>شرح مساله</h1><p>در این فصل با یک درخت ریشه دار سر و کار داریم و دو مساله زیر را روی این درخت بررسی می‌کنیم.
</p><h2>مساله جد در ارتفاع خاص</h2><p>در این مساله یک درخت ریشه دار
n
راسی ورودی داده می‌شود و سپس
q
پرسش از ما انجام می‌شود. در هر پرسش یک راس مانند v و یک عدد مانند
h
داده می‌شود. تضمین می‌شود که ارتفاع راس از
h
بیشتر است و از ما جد راس
v
که در ارتفاع
h
قرار دارد
(و یکتاست)
از ما خواسته می‌شود.
</p><h2>مساله پایین ترین جد مشترک</h2><p>در این مساله یک درخت ریشه دار
n
راسی ورودی داده می‌شود و سپس
q
پرسش از ما انجام می‌شود. در هر پرسش دو راس مانند
v و u
به ما داده می‌شود و از ما پایین ترین جد مشترک
این دو راس خواسته می‌شود.
به پایین ترین جد مشترک دو راس عموما
LCA
می گویند که مخفف
Lowest Common Ansector
است.
</p><h2>ارتباط این دو مساله</h2><p>اگر برای مساله اول یک راه حل داشته باشیم که هر پرسش را از
$ O(x) $
پاسخ دهد، می‌توانیم هر پرسش از مساله دوم را با
$ O(x*lg(n)) $
پاسخ دهیم.
</p><p>LCA
این دو راس را در نظر بگیرید. جدهایی که از ارتفاع آن راس
بالاتر هستند مشترک هستند و جدهای پایین‌تر متفاوت هستند. پس می‌توانیم
روی ارتفاع باینری سرچ بزنیم. برای این که چک کنیم جد ارتفاع x این دو راس
مشترک است یا خیر کافیست که جد ارتفاع
x
هر دو راس را به کمک راه اول به دست آوریم و مقایسه کنیم که آیا یکی هستند یا خیر.</p><h1>راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</h1><p>در این بخش برای مساله‌های گفته شده یک راه حل
$ O(n+q*lg(n)) $
را بیان می‌کنیم.
</p><h2>جداسازی سبک-سنگین</h2><p>این جداسازی یک جداسازی پرکاربرد در درخت هاست. این جداسازی یال‌های
درخت را به دو دسته <b>سبک</b> و <b>سنگین</b> تقسیم می کند.
یال های سنگین یال هایی هستند که اندازه زیردرخت فرزند مربوط به آن از یال های
فرزند های دیگر بیشتر است. تنها یک فرزند می‌تواند یال سنگین داشته باشد و اگر
چند فرزند ماکسیمم بودند، یال یکی را به دلخواه به عنوان سنگین انتخاب می‌کنیم.
</p><h3>تعداد یال های سبک در مسیر به ریشه</h3><p>تعداد یال‌های سبک در مسیر هر راس به ریشه، حداکثر
$ O(lg(n)) $
است. زیرا
از راس دلخواهی شروع کرده و به سمت ریشه بالا میرویم. متغیر
$ X $
را هم سایز زیردرخت راس فعلی تعریف میکنیم. هر بار که به سمت ریشه بالا میرویم
(از ‍‍‍‍‍v به u)
و از روی یک یال سبک رد میشویم,
$ X $
حداقل دوبرابر میشود. وگرنه
$ 2sz_v>sz_u $
که به این معنی است که این راس، بیش از نیمی از زیر درخت پدرش را در اختیار دارد
و در نتیجه یالش حتما باید سنگین باشد. حال چون
$ X $
در نهایت برابر
$ n $
خواهد شد، تعداد یال های سبک حداکثر
$ lg(n) $
می باشد.
</p><h2>حل مساله جد در ارتفاع خاص</h2><p>حداکثر یک فرزند یک راس می تواند سنگین باشد پس می توانیم در
DFS
اول به سراغ راس با یال سنگین برویم تا زمان ورود فرزند سنگین دقیقا یک واحد بیشتر از
پدرش باشد. به این ترتیب اگر راس ها را بر اساس زمان ورود مرتب کنیم، هر کس که یال
به پدرش سنگین است، دقیقا بعد پدرش قرار می‌گیرد.
</p><p>این ترتیب را به دست بیاورید و هم‌چنین برای هر راس به دست بیاورید چند پدرش
دقیقا به ترتیب پشت سرش قرار گرفته‌اند یا به عبارت دیگر به دست بیاورید که
اولین یال سبک در مسیر این راس به ریشه متعلق به کدام راس است.
</p><p>حال برای اینکه جد یک راس در ارتفاع خاصی را به دست بیاوریم، اگر تعداد پدر هایی
که پشت این راس آمده اند از ارتفاع مطلوب بیشتر باشد، یا به عبارت دیگر همه یال ها
به جد مطلوب، یال سنگین باشند. در این حالت می‌توانیم در زمان
$ O(1) $
جد مطلوب را به دست بیاوریم. اما اگر یال سبکی این وسط بود باید به جدی که یال به پدرش سبک
است برویم، سپس پدر آن را بدست آوریم و از آن پدر کار را ادامه دهیم. چون حداکثر
$ O(lg(n)) $
یال سبک در مسیر هر راس به ریشه وجود دارد، این کار در نهایت
$ O(lg(n)) $
به ازای هر پرسش طول می‌کشد و بنابراین پیچیدگی زمانی کل،
$ O(n+q*lg(n)) $
است.
</p><pre dir="ltr">cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int M = 1e5+5;
int edge_counter = 1;
int st[M], stp[M], hld[M], par[M], h[M];
vector&lt;int&gt; g[M];
int time = 0;
int dfsz(int x, int p = 0) {
  int sz = 1, mxsz = -2;
  if (p == g[x][0]) swap(g[x][0], g[x][g[x].size()-1]);
  for (int i = 0; i &lt; g[x].size(); i++) {
    if (g[x][i] == p) continue;
    int szy = dfsz(g[x][i], x);
    sz += szy;
    if (szy &gt; mxsz) {
      mxsz = szy;
      swap(g[x][0], g[x][i]); // enteghale yal sangin be g[x][0]
    }
  }
  return sz;
}
void dfst(int stpx, int p = 0) {
  int x = st[stpx] = time++; // shomare ras ha ra joori avaz mikonim ke yal haye sangin
  stp[x] = stpx; // motevali bashand. in jayghasht ra dar st[x] va barakse aan ra dar stp[x] mirizim
  for (int stpy: g[stpx]) {
    if (stpy == p) continue;
    dfst(stpy, stpx);
    par[st[stpy]] = x;
  }
}
int parat(int stpx, int hgoal) { // jadi az rase voroodi ke ertefae hadaf ra darad ra mikhahim
  int x = hld[st[stpx]];
  while (h[x] &gt; hgoal) x = hld[par[x]];
  return stp[x + hgoal - h[x]];
}
int main(){
  // derakht ra voroodi begirid va yal ha ra dar g berizid
  dfsz(0);
  dfst(0);
  for (int x = 1; x &lt; n; x++) {
    h[x] = h[par[x]] + 1;
    hld[x] = par[x] == x - 1 ? hld[x-1] : x; // hld[x] bala tarin jadi ast ke be aan yale sangin darim
  }
  // sepas porsesh ha ra ba parat pasokh dahid
}</pre><h2>حل مساله LCA</h2><p>طبق چیزی که در قسمت قبل گفتیم با راه بالا می توان یک راه
$ O(n+q*lg^2(n)) $
برای مساله پایین ترین جد مشترک ارائه داد. اما به سادگی می‌توانیم راه حل را بهینه‌تر
کنیم. پایین ترین جد مشترک را در نظر بگیرید. مسیر یکی از راس ها به این راس یالش
حتما سبک است
(هر دو یال نمی‌توانند سنگین باشند)
بنابراین با الگوریتم زیر می توانیم پایین ترین جد مشترک را پیدا کنیم.
بدست بیاورید که یال سبک کدام راس پایین‌تر است. آن راس را بدست آورید و جد هم ارتفاع
متناظرش با راس دیگر را به دست آورید. سپس پدر هر دو راس را حساب کنید.
اگر مساوی بودند که ما جد مشترک را پیدا کرده‌ایم و در غیر این صورت با دو راس جدیدی که پیدا کردیم
کار را ادامه می‌دهیم. چون حداکثر دو برابر لاگ رئوس درخت یال سبک در مسیر وجود خواهد داشت
این الگوریتم پیچیدگی زمانی
$ O(n+q*lg(n)) $
دارد.
</p><pre dir="ltr">cpp
const int M = 1e5+5;
int edge_counter = 1;
int st[M], stp[M], hld[M], par[M], h[M];
vector &lt;int&gt; g[M];
int time = 0;
int dfsz(int x, int p = 0) {
  int sz = 1, mxsz = -2;
  if (p == g[x][0]) swap(g[x][0], g[x][g[x].size() - 1]);
  for (int i = 0; i &lt; g[x].size(); i++) {
    if (g[x][i] == p) continue;
    int szy = dfsz(g[x][i], x);
    sz += szy;
    if (szy &gt; mxsz) {
      mxsz = szy;
      swap(g[x][0], g[x][i]); // enteghale yal sangin be g[x][0]
    }
  }
  return sz;
}
void dfst(int stpx, int p = 0) {
  int x = st[stpx] = time++; // shomare ras ha ra joori avaz mikonim ke yal haye sangin
  stp[x] = stpx; // motevali bashand. in jayghasht ra dar st[x] va barakse aan ra dar stp[x] mirizim
  for (int stpy: g[stpx]) {
    if (stpy == p) continue;
    dfst(stpy, stpx);
    par[st[stpy]] = x;
  }
}
int parat(int x, int hgoal) { // jadi az rase voroodi ke ertefae hadaf ra darad ra mikhahim
  int x = hld[x];
  while (h[x] &gt; hgoal) x = hld[par[x]];
  return x + hgoal - h[x];
}
int lca(int stpx, int stpy) {
  int x = st[stpx], y = st[stpy];
  if (h[x] &lt; h[y]) swap(x,y);
  x = parat(x, h[y]); // do ras ra ham ertefa mikonim ta kod sade tar shavad  
  while (x != y) {
    x = hld[x];
    y = hld[y];
    if (h[x] &lt; h[y]) swap(x, y);
    y += h[x] - h[y];
    x = par[x];
    y = par[y];  
  }
  return stp[x];
}
int main(){
  // derakht ra voroodi begirid va yal ha ra dar g berizid
  dfsz(0);
  dfst(0);
  for (int x = 1; x &lt; n; x++) {
    h[x] = h[par[x]] + 1;
    hld[x] = par[x] == x - 1 ? hld[x-1] : x; // hld[x] bala tarin jadi ast ke be aan yale sangin darim
  }
  // sepas porsesh ha ra ba parat pasokh dahid
}</pre><h1>الگوریتم برون‌خط تارجان</h1><p>مسائلی که در آن ها تعدادی پرسش مطرح می شوند دو نوع راه حل دارند. راه برخط
(online)
و راه برون‌خط
(offline).
در راه برخط شما مجبورید هر سوال را در لحظه پاسخ دهید و تا به پرسش فعلی پاسخ
ندهید نمی‌توانید پرسش بعدی را دریافت کنید. اما در راه برون خط می توانید همه پرسش ها
را دریافت کرده و سپس شروع به پاسخ دادن کنید.
</p><p>در این بخش با یک راه برون خط برای مسائلی که مطرح شد ارائه می‌کنیم. چون برخط بودن یک
محدودیت است، راه های برون خط پیچیدگی کمتری دارند.
</p><h2>راه مساله پدر در ارتفاع خاص</h2><p>این مساله ساده است. کافیست همه پرسش ها را دریافت کرده و سپس از ریشه درخت
DFS
بزنیم. هنگامی که وارد یک راس شدیم، آن را در یک وکتور پوش می‌کنیم و هنگام خارج
شدن آن را پاپ می‌کنیم. به این ترتیب هنگامی که در یک راس هستیم، خودش و تمام
اجدادش درون وکتور هستند و به ترتیب ارتفاع چیده شده‌اند. پس هنگامی که به یک
راس رسیدیم می‌توانیم تمامی پرسش های مربوط به آن را از
$ O(1) $
پاسخ دهیم. به این ترتیب راهی خطی در اختیار داریم.
</p><h2>راه مساله LCA</h2><p>ابتدا تمام پرسش ها را دریافت می کنیم و برای هر راس، لیستی از پرسش های
مربوط به آن را تهیه می کنیم. این کار در زمان خطی نسبت به ورودی قابل انجام است.
</p><p>سپس روی درخت
DFS
می‌زنیم. هنگامی که به یک راس می رسیم، یک دسته ایجاد می کنیم و این راس را
درون آن می‌گذاریم. و هنگامی که از این راس خارج می شویم، دسته ای که این راس
درون آن است را با دسته پدر این راس ترکیب می‌کنیم. به این ترتیب اگر روی یک راس مانند
u
باشیم، هر راس دیگر مانند
v
در دسته‌ای قرار دارد که سر دسته آن، جد مشترک بین آن دو است. عملیات های ترکیب را می‌توان با
DSU
انجام داد و بنابراین پیچیدگی این الگوریتم برابر است با:
$ O((n+q)*a(n)) $
که در آن
$ a(n) $
همان تابع معکوس آکرمان است.</p><h1>ارتباط LCA و RMQ</h1><p>در ادامه به بررسی یک مساله دیگر می‌پردازیم که در ظاهر به موضوع بحث نامربوط است اما
ارتباط نزدیکی به مساله
‌LCA
دارد. سپس به کمک حل این مساله یک راه حل از اردر
$ O(n*lg(n)+q) $
ارائه می‌کنیم که در صورت زیاد بودن تعداد پرسش ها نسبت به رئوس درخت، از
راه قبل بهتر عمل می‌کند.
</p><p>در این مساله ابتدا یک آرایه
n
راسی به شما داده می‌شود و سپس از شما
q
پرسش انجام می‌شود که در هر پرسش، دو سر یک بازه به شما داده می‌شود و از شما کمینه
اعضای این بازه خواسته می‌شود. شما به کمک درخت بازه‌ای که در قبل خواندید می‌توانید
این مساله را از
$ O(n+q*lg(n)) $
حل کنید. اگر به جای کمینه اعضا، جمع اعضا خواسته می‌شد نیز می‌توانستید به راحتی و از
$ O(n+q) $
مساله را حل کنید. به این مساله
RMQ
می‌گویند که مخفف پرسش کمینه در بازه است.
</p><h2>تبدیل RMQ به LCA</h2><p>در این جا از روی آرایه ورودی، یک درخت دکارتی می‌سازیم. درخت دکارتی یک درخت دودویی است
که هر عضو آرایه متناظر با یک راس از درخت است. راس متناظر با عضو کمینه آرایه در ریشه
قرار دارد، زیردرخت فرزند چپ معادل درخت دکارتی بازه ابتدا تا عضو کمینه و زیردرخت
فرزند راست معادل درخت دکارتی بازه عضو کمینه تا انتها است. در شکل زیر
یک درخت دکارتی را می‌بینید.
</p><img src="/_static/dot/Cartesian_Tree.svg"><p>به کمک این مطلب که کوچکترین جد مشترک درون بازه بین این دو راس قرار دارد، ثابت کنید که
برای پیدا کردن مینیمم در بازه، می توان پایین ترین جد مشترک در درخت دکارتی را پیدا کرد.
در ادامه با ارائه یک راه از
$ O(n) $
برای ساخت درخت دکارتی نشان می دهیم که اگر راهی برای
RMQ
وجود داشته باشد، راهی با همان پیچیدگی برای
LCA
وجود خواهد داشت.
</p><h3>ساخت درخت دکارتی در زمان خطی</h3><p>درخت دکارتی را می‌توان به کمک یک استک ساخت. درون استک رئوسی که از پدرشان مطمئن نیستیم
را به صورت مرتب
(هم از لحاظ مقدار و هم از لحاظ مکان)
نگه می‌داریم. ابتدا با استک خالی شروع کرده و شروع به پیمایش آرایه می کنیم. هر
عضوی که می‌بینیم، تا جایی که از سر استک کوچک تر باشد را از استک حذف می کنیم. پدر همه
آنها معلوم است. زیرا دیگر ممکن نیست کسی از جلوی آرایه پدر این رئوس باشد. پدر هر کدام
راس قبلی در استک و پدر آخرین راس حذف شده همین راسی است که ورودی گرفته ایم. سپس این راس
را درون استک اضافه می‌کنیم و به راس بعدی می‌رویم. در انتها یک جنگل به دست می آید که
ریشه های آن درون استک است. این رئوس نیز به ترتیب هر کدام پدر راس قبلی است
(چون دیگر راس جدیدی در کار نیست)
و ریشه درخت نیز آخرین عضو استک است که کمینه آرایه نیز هست.
</p><h2>تبدیل LCA به RMQ</h2><p>روی درخت
DFS
می‌زنیم. موقع ورود به هر راس، آن را در آرایه اضافه می کنیم و مقدار
آن را برابر ارتفاع آن قرار می‌دهیم. موقع خروج از هر راس نیز پدر آن را
به همین ترتیب به آرایه اضافه می‌کنیم. هر راس به تعداد فرزندانش به علاوه یک عضو
متناظر در آرایه دارد. برای پیدا کردن پایین ترین جد مشترک، تنها کافیست که عضو کمینه
بین اعضای متناظر دو راسی که می خواهیم
LCA
آن را به دست آوریم را محاسبه کرده و ببینیم که متناظر با چه راسی است. اثبات این
مطلب به خواننده واگذار می‌شود. بنابراین اگر راهی برای یکی از مسائل
LCA یا RMQ
وجود داشته باشد برای دیگری نیز راهی با همان پیچیدگی وجود دارد.
</p><h2>حل مساله RMQ با جدول پراکنده</h2><p>جدول پراکنده نوع خاصی از برنامه نویسی پویا است که در آن بعد دوم نسبت به بعد
اول سایز لگاریتمی دارد. این جدول در مسائل مختلفی به کار می‌رود و در این جا به کمک
آن این مساله را حل می‌کنیم.
$ dp_{i,j} $
را برابر عضو کمینه در بازه
$ [i,i+2^j) $
باشد. اگر این dp را داشته باشیم به کمک آن می توان پرسش ها را در
$ O(1) $
پاسخ داد. به این صورت که
j
را پیدا می کنیم که طول بازه مورد نظر بین
$ 2^j $
و
$ 2^{j+1} $
باشد. سپس جواب مساله برابر است با
</p>$$ min(dp_{l,j},dp_{r-2^j,j}) $$<p>محاسبه این جدول نیز از
$ O(n*lg(n)) $
امکان پذیر است. کافیست از
j=۰
شروع کرده و تا لگاریتم طول آرایه جلو برویم. هر
j
به این صورت از
j
قبلی به دست می آید
</p>$$ dp_{i,j}=min(dp_{i,j-1},dp_{i+2^{j-1},j-1}) $$<p>به این ترتیب برای
RMQ و LCA
الگوریتمی از پیچیدگی زمانی
$ O(n*lg(n)+q) $
داریم که در شرایطی که
n از q
کمتر باشد از الگوریتم قبلی
$ O(n+q*lg(n)) $
بهتر عمل می‌کند.</p><h1>راه خطی برای LCA</h1><p>در بخش قبل دیدیم که چگونه می توان مسائل
LCA و RMQ
را به هم تبدیل کرد. اگر توجه کنید وقتی که
LCA را به RMQ
تبدیل می کنیم، آرایه ای ساخته می شود که اختلاف اعضایش دقیقا یک واحد است. این مساله خاص
را در زمان خطی حل می کنیم که از آن نتیجه می شود که
LCA و RMQ
نیز در زمان
$ O(n+q) $
حل می شوند. توجه کنید که این راه ارزش تئوری دارد و با توجه به پیچیدگی پیاده سازی
و ضریب بالا، در عمل استفاده نمی شود.
</p><p>در این راه آرایه را به دسته های
$ \frac{lg(n)}{2} $
تایی تقسیم می کنیم. چون اختلاف هر دو عضو متوالی دقیقا ۱ است، این آرایه از لحاظ
ساختار در کل
$ 2^{\frac{lg(n)}{2}} = \sqrt{n} $
حالت ممکن می تواند داشته باشد. برای هر کدام از زیر بازه های
این حالات عضو مینیمم را به دست می آوریم که با پیاده سازی خوب پیچیدگی زمانی و حافظه ای
$ O(\sqrt{n} * lg^2(n)) $
خواهد داشت.
برای هر بازه نیز به دست بیاورید که شبیه کدام یک از رادیکال حالت ممکن است. این کار
نیز در زمان خطی قابل اجراست.
سپس هر دسته را یک عضو از یک آرایه جدید بگیرید و روی آن یک جدول پراکنده مشابه آن چه
در بخش قبل بررسی کردیم بسازید. این کار نیز در زمان
$ O(\frac{2*n}{lg(n)}*lg(\frac{2*n}{lg(n)})) = O(n) $
قابل اجراست.
</p><p>حال می خواهیم به پرسش ها پاسخ دهیم. یک بازه را در نظر بگیرید. یا کاملا
درون یکی از دسته های کوچک می افتد که جواب آن را از قبل حساب کرده ایم.
و یا سر آن درون یک بازه و ته آن درون بازه ای دیگر است. دسته های وسط که کامل
درون بازه افتاده اند را به کمک جدول پراکنده ای که حساب کردیم عضو کمینه اش را حساب کنید.
دو بازه سر و ته را نیز مانند حالت اول عمل کنید. سپس عضو کمینه بین این سه کاندید
را حساب کنید. این عضو جواب شماست.
</p><h1>درخت مجازی</h1><p>یک درخت مثل $ T`‍
 $
مثل
$ A $
نسبت را درخت مجازی گوییم اگر نسبت به 
$ lca $
بسته باشد. یعنی
$ lca $
هر دو راس دلخواه از
$ A $
درون خود
$ A $
باشد.
</p><img src="/_static/virt_tree_intro.png"><h2>چرا درخت مجازی برای ما مهم است؟</h2><h3>اولین مسئله</h3><p>فرض کنید زیرمجموعه ای از راس های درخت مثل
$ B $
را سیاه کرده ایم. حالا می خواهیم تعدادی از راس هایی که سیاه نیستند را نیز سیاه کنیم به طوریکه کل راس های سیاه همبند باشند. 
همچنین می خواهیم تعداد راس های سیاه در نهایت کمینه شوند. این کمینه تعداد را بیابید.
</p><p>واضح است که برای حل این سوال باید تمام راس هایی که بر روی مسیر حداقل دو راس سیاه هستند را سیاه کنیم. اما سوال مهم این است که چطور تعداد این راس ها را بیابیم
به طوریکه پیچیدگی زمانی ما به
$ |B| $
مربوط باشد و کاملا مستقل از
$ n $
باشد. (یعنی اگر مجموعه‌ای که به ما دادند کوچک بود ما هم سریع جواب بدهیم و برعکس)
</p><p>فرض کنید عدد جواب
$ ans $
باشد. توجه کنید که خود 
$ ans $
ممکن است خیلی زیاد باشد و از مرتبه
$ |B| $
نباشد. مثلا اگر درخت ما یک مسیر باشد و
$ B $
مجموعه دو راس ابتدا و انتهای این مسیر باشد
$ ans=n $
می شود. پس نمی توانیم از مرتبه زمانی
$ ans $
هم کار کنیم.
</p><p>حالا به این نکته جالب توجه کنید. حالت نهایی درخت را (که در آن راس های سیاه همبند هستند) را در نظر بگیرید و فرض کنید
درجه سیاهی هر راس مثل
$ u $
را تعداد راس های سیاه مجاور راس سیاه
$ u $
تعریف می کنیم. همانطور که احتمالا از مثالی که برای مسیر زدیم متوجه شدید، ممکن است تعداد زیادی از راس هایی که مجبور به سیاه کردنشان هستیم درجه سیاهی ۲
داشته باشند!
</p><p>یک معادل سازی روی مسئله انجام می دهیم تا کارمان راحت تر شود. درخت را از یکی از راس های
$ B $
آویزان کنید. حالا به ازای هر راس
$ u $
درون
$ B $
تمام راس های از
$ u $
تا ریشه باید سیاه شوند و همچنین این سیاه بودن کافی نیز هست (یعنی ساختار به دست آمده شرط همبند بودن را دارد).
</p><p>در اینجا هست که مسئله ما کمی شبیه مسئله درخت مجازی می شود.فرض کنید آنقدر به مجموعه 
$ B $
راس اضافه کردیم که نسبت به
$ lca $
بسته شد. یعنی تا زمانی که دو راس 
$ u, v $
درون 
$ B $
بودند که
$ lca(u, v) $
درون
$ B $
نبود ما باید 
$ lca(u, v) $
را سیاه کنیم و به
$ B $
اضافه کنیم.
</p><p>حالا به ازای هر راس غیر از ریشه مثل 
$ u $
پایین ترین جد سیاهش را پدر مجازی این راس بنامید که آن را با
$ p_u $
نشان می دهیم. توجه کنید که حالا راس های بین
$ u, p_u $
همان راس هایی بودند که گفتیم درجه سیاهی آنها ۲ می شود و ممکن است تعداد آنها زیاد باشد. حالا اگر به ازای تمام
$ u, p_u $
هااین راس ها را بشماریم (که تعداد آن ها 
$ h_u - h_{p_u} - 1 $
است) و این مقدار را با تعداد راس های سیاه فعلی جمع کنیم جواب مسئله به دست خواهد آمد.
</p><p>در این قسمت به چند نکته کلیدی اشاره نکردیم. از جمله اینکه:
</p><ul><li><p>چطور می توانیم راس هایی را پیدا کنیم که اگر به مجموعه $ B $ اضافه شوند درخت مجازی می سازند؟
</p></li><li><p>چرا تعداد حداکثر تعداد راس های درخت مجازی تنها به $ B $ مربوط است و ربطی به $ n $ ندارد؟
</p></li></ul><p>در ادامه به این سوال ها جواب می دهیم. همچنین لازم به ذکر است که سوالی که در این قسمت مطرح کردیم بدون عوض کردن ریشه هم به همان راحتی قایل حل است.
عوض کردن ریشه ای که انجام دادیم صرفا به دلیل راحت تر کردن توضیحات بود!
</p><h3>قطر یک زیرمجموعه</h3><p>فرض کنید یک درخت 
$ T $
و یک مجموعه 
$ B $
به شما داده اند. حالا شما باید دو تا از راس های درون 
$ B $
را نام ببرید که فاصله آن دو از یکدیگر بیشینه است.
</p><p>الگوریتم پیدا کردن قطر درخت با 
dfs 
را در فصل ۲ بررسی کردیم. در اینجا هم اگر راس های 
$ B $
همبند باشند می توانیم از همان الگوریتم 
dfs 
استفاده کنیم.
اگر همبند نبود چطور؟ دغدغه فعلی ما مشابه مسئله قبلی است. یعنی می خواهیم به ازای هر دو راس 
$ u,v $
از 
$ B $
تمام راس های حاظر در مسیر
$ uv $
را به 
$ B $
اضافه کنیم و سپس روی گراف حاصل الگوریتم 
dfs 
را اجرا کنیم.
</p><p>اما در حقیقت این کار روش خوبی نیست چون همانطور که در مسئله قبل بیان کردیم ممکن است تعداد راس هایی که نیاز داریم به 
$ B $
خیلی زیاد باشد.
</p><p>در اینجا هم مثل مسئله قبل از درخت مجازی استفاده می کنیم. یعنی مجموعه 
$ B $
را آنقدر بسط می دهیم تا به یک درخت مجازی برسیم.
حالا بین در یک گراف جدید بین هر راس و پدر مجازی خودش یالی با وزن  
$ h_u - h_{p_u} $
می کشیم.
حالا درخت جدیدی که داریم همان درخت مجازی ما
است! با پیدا کردن قطر در این درخت، بیشینه فاصله بین راس های
$ B $
اولیه را پیدا می کنیم.
</p><h2>الگوریتم</h2><h3>مقدمه</h3><p>همانطور که احتمالا از مسائل قبلی شهود
گرفتید، درخت مجازی می تواند نماینده یک زیردرخت کوچک از درخت ما باشد.
نکته جالب توجه این است که این زیردرخت لزوما همبند نیست اما اگر درخت جدیدی بسازیم که
در آن هر کس به پدر مجازی اش وصل شده باشد درخت جدیدی به دست می آوریم.
سپس می توانیم از این به
بعد تنها درخت جدید را در نظر بگیریم و محاسبات خود را روی آن انجام دهیم.
</p><img src="/_static/transform_to_virt_tree.png"><p>در این قسمت فرض می کنیم که مجموعه راس های
$ B $
به ما داده شده است و ما می خواهیم تعدادی راس به آن اضافه کنیم تا
$ B $
یک درخت مجازی شود. در اینجا این کار را بسط دادن می نامیم.
</p><h3>اولین تلاش</h3><p>در گام اول می توانیم به ازای هر دو راس درون مجموعه 
$ B $
مثل
$ a, b $
،
$ lca(a, b) $
را محاسبه کرده و آن را مجموعه 
$ C $
بنامیم.
</p><p>حالا ادعا می کنیم  
$ D = B \cup C $
یک درخت مجازی است. برای اثبات توجه کنید که هر راس عضو 
$ D $
درون زیردرختش یک عضو از 
$ B $
موجود است. (چرا؟) حالا فرض کنید که دو راس 
$ a, b \in D $
باشند که 
$ lca $
آن دو درون 
$ D $
نباشد.
راس های عضو 
$ B $
که درون زیردرخت
$ a, b $
بودند را به ترتیب 
$ a\prime, a\prime $
بنامید. 
اگر
$ lca(a, b) $
در
$ D $
نیامده باشد آنگاه 
$ lca(a\prime, b\prime) $
همان 
$ lca(a, b) $
خواهد بود که در 
$ C $
است که با حرف اولیه ما تناقض دارد.
</p><p>پس تنها کافیست به ازای هر دو راس درون 
$ B $
این محاسبات را انجام دهیم (و نیازی نیست که
$ lca $
راس هایی که جدید اضافه می شوند را با بقیه بررسی کنیم)
</p><h3>یک الگوریتم بهتر</h3><p>روشی که قبل از این گفتیم پیچیدگی زمانی بالایی داشت. اگر محسبات مربوط به
$ lca $
را
$ O(lg(n)) $
در نظر بگیریم آنگاه روش بالا از 
$ O(|B|^2) $
خواهد بود.
</p><p>حالا تلاش می کنیم که یک روش بهتر پیدا کنیم. یک راس به نام 
$ u $
را در نظر بگیرید که در 
$ B $
نیست اما باید در درخت مجازی باشد. یعنی دو راس 
$ u $
دو بچه 
$ a, b $
دارد که درون زبردرخت هر یک از 
$ a, b $
یک یا چند راس از 
$ B $
وجود دارد (که
$ lca $
آن ها 
$ u $
خواهد شد)
</p><p>حالا توجه کنید که از 
$ lca $
گرفتن هر کدام از راس های درون زیردرخت
$ a $
با هر کدام از راس های درون زیردرخت
$ b $
راس 
$ u $
به دست خواهد آمد. مشکل الگوریتم قبلی این بود که در این شرایط 
$ u $
را تعداد زیادی بار حساب می کرد که به این نیازی نداشتیم. یعنی به ازای هر زوج مرتب از راس های زیردرخت 
$ a, b $
یک بار راس 
$ u $
را حساب می کرد که دقیقا همین موضوع پیچیدگی زمانی راه قبل را زیاد می کرد.
</p><p>نکته جالب این است که اگر بتوانیم برای راس های درخت 
$ T $
ترتیب اولیه ای قائل شویم که در این ترتیب <b>زیردرخت هر راس به یک بازه تبدیل شود</b> آنگاه می توانیم از روش زیراستفاده کنیم و ادعا کنیم به درستی عمل می کند.
</p><ul><li><p>راس های $ B $ را بر حسب این ترتیب گفته شده مرتب کنید.
</p></li><li><p>حالا به ازای هر دو راس متوالی در لیست مرتب شده ای که به دست آوردیم $ lca $ این دو راس را به مجموعه $ C $ اضافه کنید.
</p></li><li><p>اجتماع دو مجموعه 
$ B, C $
درخت مجازی ما را تشکیل می دهند.
</p></li></ul><p>چرا این الگوریتم درست کار می کند؟ گفتیم راس 
$ u $
دو بچه دارد که در زیردرخت هر کدام راسی از 
$ B $
وجود دارد. در لیستی مرتب شده ای که الگوریتم را روی آن انجام دادیم <b>یک بازه</b> مربوط به زیر درخت 
$ u $
وجود دارد. در راس های مربوط به این بازه قطعا دو راس وجود داند که مربوط به زیردرخت بچه های متفاوتی از
$ u $
هستند (چرا؟) بنابراین هنگامی که 
$ lca $
حساب می کنیم راس
$ u $
به مجموعه 
$ C $
اضافه می شود! همانطور که می خواستیم.
</p><h3>ترتیب بهینه؟</h3><p>در الگوریتم بالا به طور جادویی از یک ترتیب استفاده کردیم که ویژگی جالبی داشت. اما چنین ترتیبی ارائه ندادیم.
</p><p>می توانید خودتان چنین ترتیبی بسازید. تمام روش های ساختن چنین ترتیبی ریشه در الگوریتم 
dfs 
دارند. چرا؟ چون هنگامی که می خواهیم این ترتیب را برای زیردرخت راسی مثل 
$ u $
محاسبه کنیم باید ابتدا به صورت بازگشتی چنین ترتیبی برای زیردرخت تمام بچه های 
$ u $
پیدا کنیم و راس
$ u $
را هم جایی بین فاصله بازه های دو تا از بچه ها (یا قبل و بعد از همه) اضافه کنیم.
</p><p>این دقیقا کاری است که 
در 
dfs
آن را
starting-time
یا 
finishing-time
می نامیم و آن را در فصل ۲ بررسی کردیم.
</p><h3>پیاده سازی</h3><pre dir="ltr">cpp
const int maxn = 1e5 + 10, max_log = 20;
int start_time[maxn], sparse_table[maxn][max_log], h[maxn];
vector&lt;int&gt; g[maxn];
int Counter = 0;
void dfs(int v, int par = 0){
  h[v] = h[par] + 1;
  sparse_table[v][0] = par;
  for(int i = 1; i &lt; max_log; i++){
      sparse_table[v][i] = sparse_table[sparse_table[v][i-1]][i-1];
  }
  start_time[v] = Counter;
  Counter = Counter + 1;
  for(int u : g[v]){
      if(par != u){
          dfs(u, v);
      }
  }
}
int lca(int a, int b){
  if(h[a] &lt; h[b])
      swap(a, b);
  for(int i = max_log-1; i &gt;= 0; i--){
      if(h[sparse_table[a][i]] &gt;= h[b])
          a = sparse_table[a][i];
  }
  if(a == b)
      return a;
  for(int i = max_log-1; i &gt;= 0; i--){
      if(sparse_table[a][i] != sparse_table[b][i])
          a = sparse_table[a][i], b = sparse_table[b][i];
  }
  return sparse_table[a][0];
}
vector&lt;int&gt; build_virtual_tree(vector&lt;int&gt; vec){
  sort(vec.begin(), vec.end(), [](int a, int b){ return start_time[a] &lt; start_time[b]; }); // sort on starting time
  for(int i = vec.size()-1; i &gt; 0; i--){
      vec.push_back(lca(vec[i], vec[i-1]));
  }
  sort(vec.begin(), vec.end(), [](int a, int b){ return start_time[a] &lt; start_time[b]; });
  vec.resize(unique(vec.begin(), vec.end())-vec.begin());
  return vec;
}</pre><p>همچنین توجه کنید که اگر راس 
$ u $
درون درخت مجازی باشد و راس قبل از آن در ترتیب
starting-time
راس 
$ v $
باشد در اینصورت پدر مجازی راس 
$ u $
برابر با
$ lca(u, v) $
می باشد. (چرا؟)
</p><p>برای محاسبه 
$ lca $
در کد بالا از روشی با پیچیدگی زمانی
$ O(lg(n)) $
استفاده شد و در نهایت پیدا کردن بسط درخت مجازی مجموعه
$ B $
با زمان 
$ O(|B| \times lg(n)) $
انجام شد.
</p><h1>درخت پوشای کمینه</h1><h2>شرح مساله</h2><p>فرض کنید به ما یک گراف وزن دار داده شده و از ما خواسته شده زیردرخت فراگیری از آن را پیدا کنیم که مجموع وزن یال های آن کمینه باشد.
در این صورت ما به دنبال زیر درخت پوشای کمینه (Minimum Spanning Tree) آن هستیم.
</p><p>چهار الگوریتم زیر را برای حل این مسئله معرفی می کنیم.
</p><h2>الگوریتم ها</h2><h3>کروسکال (Kruskal)</h3><p>یال های گراف را بر حسب وزنشان به صورت صعودی مرتب می کنیم راس های گراف را بدون هیچ یالی درون MST نهایی اضافه می کنیم(فرض کنید داریم قدم به قدم MST را می سازیم و در ابتدای کار این MST بدون هیچ یالی است و قرار است یال های آن را اضافه کنیم).
الگوریتم از اولین یال مرتب شده شروع می کند و در هر مرحله یال انتخاب شده را به MST اضافه می کند اگر در MST با یال های انتخاب شده قبلی دور درست نکند.
برای فهمیدن اینکه یال انتخاب شده دور تشکیل می دهد یا نه می توانیم از DSU استفاده کنیم.
اثبات درستی این الگوریتم به کمک برهان خلف است. فرض کنید MST بدست آمده توسط الگوریتم G باشد و MST اصلی H باشد. کم وزن ترین یالی که در H بکار رفته و در G بکار نرفته را در نظر بگیرید. در الگوریتم کروسکال حتماً از روی این یال رد شدیم و این یال باعث ایجاد دور شده بنابراین H دور دارد و این با فرض H متناقض است.
اردر این الگوریتم $ O(mlgn + n) $ است.
</p><h3>پریم (Prim)</h3><p>به طور کل الگوریتم پریم یک مجموعه از رئوس داریم که در هر مرحله یک راس به آن ها با یک یال اضافه می شود و در آخر مجموعه رئوس با مجموعه رئوس اصلی گراف یکسان می شود.
برای آشنایی بیشتر با این الگوریتم به دقت به مراحل آن توجه کنید.
</p><ul><li><p>یک مجموعه ایجاد می کنیم که نمایانگر رئوس موجود در MST در هر مرحله این الگوریتم است.
</p></li><li><p>یک مقدار کمترین فاصله برای تمامی راس های گراف ایجاد می کنیم و مقدار تمامی آن ها را برابر بی نهایت می گذاریم(عددی بزرگ) و برای یک راس دلخواه که اولین راس ما در این الگوریتم است مقدار صفر می گذاریم.
</p></li><li><p>تا موقعی که مجموعه ما با مجموعه رئوس گراف یکسان نشده این سه کار را انجام می دهیم. در ابتدا یک راس u را انتخاب می کنیم که در مجموعه ما نباشد و کمترین مقدار فاصله را داشته باشد. u را به مجموعه خود اضافه می کنیم و بعد از آن مقدار فاصله تمامی راس های همسایه u را بروز رسانی می کنیم. به این شکل که اگر راس w با یال z به راس u متصل بود و فاصله u به علاوه z کمتر از فاصله w بود فاصله w را برابر فاصله u به علاوه z می کنیم.
</p></li></ul>$$ Dis [u] + z < Dis [w] => Dis [w] = Dis [u] + z $$<p>توضیح آخر درباره ایده الگوریتم پریم این است که در هر مرحله بین مجموعه راسی که ما انتخاب کردیم و مجموعه رئوس دیگر گراف یالی را انتخاب می کنیم که کمترین وزن را داشته باشد.
اثبات الگوریتم به این شکل است که در هر مرحله ما یالی را بین مجموعه خودمان و مجموعه دیگر رئوس انتخاب می کنیم. اگر این یال انتخاب نشود MST همبند نمی شود که تناقض است و اگر دو یال انتخاب شود MST دور پیدا می کند و باز هم تناقض ایجاد می شود. بنابراین باید یک یال انتخاب شود و برای اینکه کمترین وزن را MST داشته باشد باید کمترین یال انتخاب شود که این همان چیزیست که ما انجام می دهیم.
اردر این الگوریتم $ O(mlgn + n) $ است.
</p><h1>گونی</h1><p>گونی یکی از الگوریتم های زیبا و کاربردی در درخت است که طیف وسیعی از مسائل را
حل می کند. در این مساله، ما یک گونی (یک داده ساختار دلخواه) داریم که در یک
عملیات می توان یکی از
رئوس درخت را از آن حذف کرد یا یکی از رئوس را به آن اضافه کرد. درخت ما
ریشه دار است و هدف این است که هر کدام از
$ n $
زیر درخت از درخت، هر کدام حداقل یک بار در گونی به تنهایی قرار گرفته باشند و
مجموع تعداد عملیات ها از
$ O(nlg(n)) $
باشد.
</p><h2>کاربرد</h2><p>در مسائل زیادی می توان از گونی استفاده کرد که تعدادی در تمرین های این فصل آمده
اند. اما برای این که بیشتر این مساله و اهمیت آن برای شما روشن شود، یک مثال با هم
حل خواهیم کرد. در این مساله یک درخت ریشه دار داریم که هر راس آن یک رنگی دارد. به
ازای هر زیر درخت می خواهیم تعداد رنگ های متفاوت آن را به دست بیاوریم و خروجی دهیم. فرض
کنید که راه حل مساله گونی را بلدید و به کمک آن سعی کنید که مساله را حل کنید.
</p><p>برای حل این مساله، از یک داده ساختار استفاده می کنیم که بتوان به آن یک راس اضافه کرد
یا یک راس حذف کرد و یا تعداد رنگ های متمایز آن را دریافت کرد. این داده ساختار می تواند
یک آرایه ساده باشد که هنگام اضافه کردن خانه مربوط به آن رنگ را یک واحد زیاد می کنیم
و هنگام حذف کردن خانه را یک واحد کم می کنیم و همزمان تعداد رنگ های متفاوت را نگه می داریم
یعنی اگر یک رنگ قبل از اضافه کردن صفر بود و الآن یک می شد آن متغیر را یک واحد زیاد
و هنگام حذف نیز اگر آن رنگ صفر می شد متغیر را یک واحد کم می کنیم. هر سه عملیات در
این داده ساختار در زمان
$ O(1) $
انجام می شود.
</p><p>حال از الگوریتم گونی (که هم اکنون جزییات پیاده سازی آن را نمی دانیم) استفاده می کنیم. همه
زیر درخت ها را یک بار در این داده ساختار می آوریم و پاسخشان را یادداشت می کنیم. سپس
جواب ها را چاپ می کنیم.
</p><h2>الگوریتم</h2><p>ایده گونی مشابه ایده جدا سازی سبک سنگین است که در فصل پایین ترین جد مشترک با آن
آشنا شدیم. (برای یادآوری، می توانید به بخش 10.2 نگاهی بیاندازید) هدف
ما این است که روی هر راس، به اندازه ضریبی از تعداد یال های سبکش در مسیر به ریشه عملیات
انجام دهیم. یعنی تعداد حذف کردن و اضافه کردن های راس
$ v $
به گونی در کل عملیات، از
$ O(light_v) $
باشد. و از قسمت 10.2 به خاطر می آوریم که
$ light_v \le lg(n) $
و بنابراین اگر موفق به این کار شویم، جمع عملیات ها روی تمام رئوس از
$ O(nlg(n)) $
خواهد بود.
</p><p>الگوریتم را به صورت یک تابع بازگشتی پیاده سازی می کنیم. این تابع
یک راس ورودی می گیرد، با گونی خالی شروع می کند، تمام
زیردرخت هایی که ریشه شان در زیردرخت این راس
است را در گونی یک بار قرار می دهد، سپس گونی را به طوری که تمام رئوس زیردرختش
درون آن باشند تحویل می دهد. پیاده سازی این تابع، برای یک برگ بدیهی است و
در زمان ثابت اجرا می شود. برای رئوس غیر برگ، آن را به طور بازگشتی پیاده می کنیم. ابتدا
روی همه یال های سبک فرزند این تابع را اجرا می کنیم و بعد از اجرا، گونی را خالی
می کنیم. سپس روی فرزند این راس که یال سنگین دارد، این تابع را اجرا می کنیم
اما <b>دیگر گونی را خالی نمی کنیم</b> و بعد بچه های با یال سبک را مجددا به گونی
اضافه می کنیم. حال کل زیردرخت درون گونی آمده است. پاسخ راس ورودی تابع را از
داده ساختار دریافت می کنیم و سپس به اجرای تابع خاتمه می دهیم.
</p><p>در هنگام اجرای این تابع، همه فرزندان راس سنگین تنها به اندازه ای که تابع بازگشتی
نیاز داشت از گونی اضافه و حذف شده اند و فرزندان راس های سبک، به جز آن، یک بار توسط
تابع اصلی حذف و یک بار نیز اضافه شده اند. خود راس ورودی نیز در آخر یک بار اضافه
شد. می توان دید که تعداد اضافه شدن و حذف شدن های هر راس مثل
$ v $
دقیقا برابر
$ 2light_v+1 $
خواهد شد. هم چنین می توان دریافت که زمان اجرای برنامه، ضریبی از تعداد عملیات های
روی گونی است و هر دو طبق چیزی که در بالا مطرح شد از
$ O(nlg(n)) $
می باشند.
</p><h2>پیاده سازی</h2><pre dir="ltr">cpp
const int M = 1e5 + 5;
vector&lt;int&gt; g[M];
int sz[M]; // andaaze zirderakht har ras, baraaye tashkhis yaal haaye sabok va sangin
void add_to_gooni(int v) {
  // piade sazi motenaseb ba masale raa injaa gharaar dahid
}
void remove_from_gooni(int v) {
  // piade sazi motenaseb ba masale raa injaa gharaar dahid
}
void compute_answer() {
  // piade sazi motenaseb ba masale raa injaa gharaar dahid
}
void add_subtree(int v, int p){
    add_to_gooni(v);
    for(int u: g[v])
        if(u != p)
            add_subtree(u, v);
}
void remove_subtree(int v, int p){
    remove_from_gooni(v);
    for(int u: g[v])
        if(u != p)
            add_subtree(u, v);
}
void dfs(int v, int p){
    int mx = -1, bigChild = -1;
    for(int u : g[v]) {
      if(u != p &amp;&amp; sz[u] &gt; mx) {
        mx = sz[u];
        bigChild = u;
      }
    }
    for(int u : g[v]) {
      if(u != p &amp;&amp; u != bigChild) {
        dfs(u, v); // javaabe farzand haye sabok ra mohaasebe mikonim
        remove_subtree(v, p); // sepas aan haa raa paak mikonim
      }
    }
    if(bigChild != -1)
        dfs(bigChild, v);  // farzande sangin raa paak nemikonim
    for(auto u : g[v]) {
      if(u != p &amp;&amp; u != bigChild)
        add_subtree(u, v); // farzand haye sabok ra mojadadan bar migardaanim
    }
    compute_answer(); // hame zirderakht v dar gooni ast, javabash ra hesab mikonim
}</pre><p>توجه کنید که در این پیاده سازی، باید گراف را ورودی بگیرید و مقادیر آرایه
sz
را با یک دی اف اس دیگر پر کنید که در این جا به آن اشاره نکردیم.
</p><h1>﻿سنتروید</h1><h2>تعریف</h2><p>در درخت به راسی که با حذف آن تعداد راس های بزرگترین مولفه حداکثر $ n/2 $ باشد سنتروید می گوییم.
</p><h2>اثبات وجود و یافتن سنتروید</h2><p>ابتدا درخت را از راس یک ریشه دار می کنیم حال از ریشه شروع می کنیم و هر مرحله اگر راسی که در آن هستیم فرزندی داشت که اندازه اش از $ n/2 $ بیشتر بود به آن راس می رویم حال در نهایت به سنتروید می رسیم.
راسی که پیدا کردیم سنتروید است چون سایز زیر درختش از $ n/2 $ بیشتر است که یعنی مولفه ی پدرش کمتر از $ n/2 $ است و هیچ فرزندی هم با اندازه بیشتر از $ n/2 $ ندارد.
پیاده سازی الگوریتم را در ادامه ببینید
</p><pre dir="ltr">cpp
const int N = 100000 + 77;
int n , sz[N];
vector &lt; int &gt; adj[N];
void dfs(int v ,int prev = -1) {
   sz[v] = 1;  
   for(int u : adj[v])
      if(u != prev){
         dfs(u , v);
         sz[v] += sz[u];
       }
}
int FindCentroid(int v , int prev = -1) {
   for(int u : adj[v])
      if(u != prev &amp;&amp; sz[u] * 2 &gt; n)
         return FindCentroid(u, v);
   return v;
}
int main() {
   scanf(&quot;%d&quot; , &amp; n);
   for(int v, u, i = 1; i &lt; n; ++i){
      scanf(&quot;%d %d&quot; ,&amp; v ,&amp; u);
      adj[v].push_back(u);
      adj[u].push_back(v);
    }
   dfs(1);
   printf(&quot;%d\n&quot; , FindCentroid(1));
   return 0;
}</pre><h2>Centroid Decomposition</h2><p>فرض کنید می خواهیم روی درخت الگوریتم تقسیم و حل را پیاده سازی کنیم سنتروید درخت کمک بسیاری به ما خواهد کرد چون می توانیم با حذف آن و حل زیر درخت های باقی مانده به پیچیدگی $ O(n log n) $ برسیم .
اگر دقت کنید با این تکنیک روی هر راس حداکثر $ lg n $ بار پیمایش کرده ایم چون با هر بار پیمایش روی آن رای اندازه مولفه اش کمتر از نصف می شود پس در کل پیچیدگی زمانی اش $ O(n log n) $ خواهد شد
پیاده سازی این روش به این صورت است که ابتدا centroid درست را پیدا می کنیم حال هر کدام از مولفه ها را جداگانه حل می کنیم که همانند روش تقسیم و حل است.
پیاده سازی الگوریتم را در ادامه ببینید
</p><pre dir="ltr">cpp
const int N = 100000 + 77;
int n, sz[N];
bool M[N]; // che rass haee centroid shodeand ta be hal
vector &lt; int &gt; adj[N];
void dfs(int v, int prev = -1) {
   sz[v] = 1;
   for(int u : adj[v])
      if(u != prev &amp;&amp; ! M[u]){
         dfs(u, v);
         sz[v] += sz[u];
       }
}
int FindCentroid(int v, int prev = -1) {
   for(int u : adj[v])
      if(u != prev &amp;&amp; sz[u] * 2 &gt; n)
         return FindCentroid(u, v);
   return v;
}
void Decompose(int v) {
   dfs(v);
   int c = FindCentroid(v);
   M[c] = 1;
   for(int u : adj[c])
      if(! M[u])
         Decompose(u);
}
int main() {
   scanf(&quot;%d&quot;, &amp; n);
   for(int v, u, i = 1; i &lt; n; ++i){
      scanf(&quot;%d %d&quot; , &amp; v , &amp; u);
      adj[v].push_back(u);
      adj[u].push_back(v);
    }
   Decompose(1);
   return 0;
}</pre><h2>Centroid Tree</h2><p>فرض کنید درختی جدید از درختی که داریم میسازیم الگوریتم Centroid Decomposition را در نظر بگیرید حال در هر مرحله که سنتروید یک زیر درخت را پیدا می کنیم پدر آن را در این درختی که می سازیم سنتروید مولفه قبلی که این راس را داشته می گذاریم به این درخت جدید Centroid Tree می گوییم
</p><img src="/_static/dot/Centroid_Clusters.svg"><img src="/_static/dot/Centroid_Tree.svg"><p>در بسیاری از سوال ها Centroid Tree کمک بسیاری در محاسبات می کند
</p><h1>هافمن کدینگ</h1><p>فرض کنید یک دنباله از حروف داریم که تشکیل یک متن داده است. حالا می خواهیم هر حرف را به دنباله ای از 0,1 ها تبدیل کنیم به طوریکه دوباره قابل بازیابی به حروف باشد. به طور معمول این کار با کد اسکی (ascii code) انجام می شود که هر حرف را به دنباله ای 8 تایی از 0,1 ها تناظر می دهد. اما در حقیقت ما در متن از همه حروف به یک اندازه استفاده نمی کنیم (مثلا در کلمات انگلیسی از حرف s به دفعات بیشتر از حرف z استفاده می شود). به همین دلیل اگر بخواهیم طول رشته 0,1 حاصل را کم کنیم استفاده از کد اسکی ایده خوبی نخواهد بود. به طور شهودی باید به حروف پرتکرار رشته دودویی با طول کم و با حروفی که کمتر ظاهر می شوند رشته دودویی با طول بیشتر نسبت بدهیم.
</p><h2>تناظر حروف به 0,1</h2><p>به فرایند تبدیل دنباله ای از حروف به دنباله ای از 0,1 ها رمزگذاری می گوییم و به برعکس این فرایند (یعنی تبدیل دنباله 0,1 ها به دنباله حروف) رمزگشایی می گوییم.
</p><p>اولین سوالی که در ذهنمان پیش می آید این است که چگونه هر حرف را به یک دنباله دودویی تناظر دهیم تا عملیات رمزگشایی به صورت یکتا و درست انجام شود؟ یک ایده هوشمندانه در اینجا استفاده از درخت ها است. یک درخت ریشه دودویی تعریف می کنیم و به آن درخت رمزگذاری می گوییم که خاصیت های زیر را دارد.
</p><ul><li><p>هر راس این درخت حداکثر دو بچه دارد. به ازای هر راس روی یال های این راس که به بچه هایش می رود عدد 0,1 نوشته ایم (0 برای بچه چپ و 1 برای بچه راست).
</p></li><li><p>هر برگ این درخت (ریشه هیچگاه برگ محسوب نمی شود) متناظر با یکی از حروف الفبای ما  خواهد بود.
</p></li></ul><p>در اینصورت به ازای هر حرف $ x $ الفبا فرض کنید $ u $ برگ متناظر با $ x $ باشد. در اینصورت دنباله 0,1 هایی که از ریشه تا راس $ u $ می بینیم را متناظر با حرف $ x $ قرار دهید.
</p><p>حالا چگونه می توان یک متن دودویی را رمزگشایی کرد؟ کافی است ابتدا یک مهره را روی راس ریشه قرار دهید و شروع به خواندن متن دودویی کنید. سپس اگر 0 دیدید به یال سمت چپ بروید و اگر 1 دیدید به یال سمت راست بروید تا زمانی که به یک برگ برسید که به یک حرف متناظر شده است. و به این معنی است که حرف اول متنمان همان حرفی است که به آن رسیدیم. (دقت کنید که هیچ راس غیربرگی به حروف متناظر نشده پس اولین حرف متن نمی توانسته هیچ حرف دیگری باشد). سپس دوباره مهره را به ریشه برگردانید و دوباره شروع به خواندن رشته دودویی کنید تا حرف دوم رشته اصلی را متوجه شوید. با ادامه این فرایند می توان رشته را رمزگشایی کرد. اگر در این فرایند ها مهره می خواست به یالی برود که وجود ندارد‌ (مثلا اگر 0 نوشته شده بود ولی یال سمت چپ نداشتیم) یا اگر در آخر کار مهره روی ریشه نباشد به این معنی است که متن دودویی ما اشتباه است و هیچ متنی وجود ندارد که بعد از رمزگذاری به این رشته تبدیل شود.
</p><img src="/_static/derakht_ramz.png"><h2>یک درخت کمینه</h2><p>حال با دانستن اینکه می توان تناظر حروف به رشته های دودویی را با ساختن یک درخت رمزگذاری انجام داد، به مسئله اصلی بر می گردیم. حالا هدف ما این است که یک درخت رمزگذاری ارائه دهیم که طول رشته دودویی رمزشده مان را کمینه کند.
</p><p>به صورت دقیق تر فرض کنید می خواهیم درخت رمزگذاری ارائه دهیم که متن $ s $ را به دنباله دودویی $ p $ تبدیل کند به طوریکه طول $ p $ کمینه شود. فرض کنید از حرف $ i $ ام $ c_i $ تا در رشته $ s $ داشته باشیم. حالا طول $ p $ برابر با $ \sum h_i \times c_i $ خواهد بود پس می خواهیم این مقدار را کمینه کنیم.
</p><p>فرض کنید درخت رمزگذاری مورد نظر $ T $ باشد. به چند نکته زیر توجه کنید :
</p><ul><li><p>اگر حرف ها را بر اساس تعداد تکرار های آن ها ($ c_i $) از کم به زیاد مرتب کنیم $ h_i $ ها از زیاد به کم مرتب خواهند بود. (در غیر اینصورت می توانیم راس متناظر به دو حرف را جا به جا کنیم تا طول $ p $ کم تر شود). 
</p></li><li><p>تمام برگ ها برادر دارند (مگر اینکه تنها یک برگ داشته باشیم). در غیراینصورت می توان آن برگ را حدف کرد حرفی که به آن نسبت داده شده را به پدرش نسبت دهیم. در اینصورت طول $ p $ کم می شود.
</p></li><li><p>اگر دو برگ $ a $ و $ b $ در یک ارتفاع باشند می توان حرف هایی که به $ a,b $ نسبت داده شده را با هم جا به جا کرد و تغییری در اندازه $ p $ ایجاد نمی شود.
</p></li></ul><p>پس می توان نتیجه گرفت اگر دو حرفی که تعداد تکرار های آن ها کمینه است را $ x,y $ در نظر بگیریم آن ها در پایین ترین ارتفاع درخت هستند.همچنین می توان راس های نسبت داده شده به آن ها را طوری جا به جا کرد که آن دو برادر باشند!
</p><p>پس حالت بهینه ای وجود دارد که برگ های متناظر با $ x,y $ دو برادر در پایین ترین ارتفاع درخت باشند. فرض کنید ارتفاع راس متناظر با $ x,y $ برابر با $ h $ باشد. از آنجایی که رشته دودویی متناظر به $ x,y $ تنها در یک رقم آخر (یعنی رقم $ h $ ام) با هم تفاوت دارند پس می توان فهمید رقم $ h $ ام آن دو روی هم $ c_x + c_y $ بار آمده است.
</p><p>در ادامه می توان دو حرف $ x $ و $ y $ را حذف کرد و یک حرف جدید مثلا $ z $ تعریف کرد که به جای $ x,y $ می آید و قرار است راس متناظر با $ z $ همان پدر مشترک $ x,y $ باشد پس حالا از تعداد حروف الفبا ای که داشتیم یکی کم کردیم و می توان مسئله را بازگشتی برای آن ها حل کرد. اگر جواب مسئله جدید (مینیمم طول $ p $) را $ ans ^ {\prime} $ فرض کنید جواب مسئله فعلی ما $ ans = ans ^ {\prime} + c_x + c_y $ خواهد بود. 
</p><p>همچنین می توانید ببینید که درخت بهینه $ T $ که به صورت وجودی آن را فرض کرده بودیم در طی مراحل الگوریتم خود به خود ساخته خواهد شد!
</p><img src="/_static/huffman.png"><p>پس الگوریتم به اینصورت است که در هر مرحله دو حرفی که کمترین تعداد تکرار را دارند (مثلا $ x,y $) با هم ترکیب کرده و یک حرف جدید جایگزین آن می کنیم که تعداد تکرار های آن $ c_x + c_y $ است و سپس $ c_x + c_y $ را به جواب اضافه می کنیم.
</p><p>پیاده سازی این الگوریتم را می توانید در ادامه ببینید. 
</p><pre dir="ltr">cpp
typedef pair&lt;int, int&gt; pii;
const int maxn = 1e5 + 10;
vector&lt;int&gt; Tree[maxn]; // bache haye har raas dar derakht ramz gozari
int c[maxn]; // tedad tekrar haye har harf
int Counter; // kamtarin id raasi ke nadarim ra negah midarad
priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq; // yek heap minimum
int main(){
    int n; // tedad horoof alephba
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++){
     cin &gt;&gt; c[i];
      pq.push({c[i], i});
    }
    Counter = n;
    int ans = 0;
    while(pq.size() &gt; 1){
       int x = pq.top().second, y = pq.top().second;
       pq.pop(), pq.pop();
       int z = Counter;
       Counter++;
       Tree[z].push_back(x);
       Tree[z].push_back(y);	    
       c[z] = c[x] + c[y];
       ans+= c[x] + c[y];
       pq.push({c[z], z});
    }
    // dar inja ans kamine tool p mibashad va dar Tree yek derakht ramzgozari behine sakhtim.
}</pre><h1>هش درخت</h1><p>در این قسمت چک کردن تساوی دو درخت را بررسی می کنیم. فرض کنید دو درخت $ T_1 $ و $ T_2 $ به ما داده شده است و می خواهیم الگوریتمی خطی ارائه دهیم که بررسی کند $ T_1,T_2 $ با هم برابر هستند یا خیر. منظور از برابری در اینجا این است که اگر شماره راس ها را در نظر نگیریم بتوان دو درخت را طوری کشید که شکل آن ها عینا یکسان شود.
</p><h2>تبدیل به برابری دو درخت ریشه دار</h2><p>فرض کنید می دانیم راس $ u_1 $ از درخت $ T_1 $ قرار است برابر با راس $ u_2 $ از درخت $ T_2 $ شود. آنگاه می توانیم برابر بودن دو درخت ریشه دار را بررسی کنیم که به نظر می رسد ساده تر از مسئله فعلی باشد.
</p><p>پس حالا اگر بتوانیم مسئله برابری دو درخت ریشه دار $ n $ راسی را در $ O(f(n)) $ حل کنیم راه حلی داریم که مسئله فعلی را در $ O(n \times f(n)) $ حل می کند. تنها کافیست $ u_1 $ را یک راس ثابت در نظر بگیریم و روی $ u_2 $ حالت بندی کنیم.
</p><p>ایده کلیدی در اینجا این است که $ u_1,u_2 $ را با ویژگی خاصی انتخاب کنیم که تعداد راس های درخت با این ویژگی کم باشد. مثلا اگر $ u_1 $ را یک برگ در نظر بگیریم آنگاه $ u_2 $ نیز باید برگ باشد پس به جای $ n $ بار حالت بندی روی $ u_2 $ کافی است به تعداد برگ های $ T_2 $ بار حالت بندی کنیم.
</p><p>در قسمت های قبل یاد گرفتیم که هر درخت حداکثر 2 سنتروید دارد. در نتیجه اگر ویژگی مورد نظر را سنتروید بودن در نظر بگیریم کافی است $ u_1 $ را یکی از سنتروید های درخت $ T_1 $ در نظر بگیریم و برای $ u_2 $ روی تمام سنتروید های درخت $ T_2 $ حالت بندی کنیم (که حداکثر 2 تا هستند). پس توانستیم مسئله را در $ O(f(n)) $ حل کنیم.
</p><h2>حل مسئله برابری دو درخت ریشه دار</h2><p>فرض کنید $ r_1 $ ریشه درخت $ T_1 $ و $ r_2 $ ریشه درخت $ T_2 $ باشد و حالا می خواهیم برابری این دو درخت را بررسی کنیم. در ابتدا اگر تعداد بچه های $ r_1,r_2 $ مساوی نباشند که دو درخت به وضوح نابرابرند. در صورت مساوی بودن تعداد بچه ها باید بفهمیم که هر کدام از بچه های $ r_1 $ به کدام یک از بچه های $ r_2 $ متناظر شده است. اگر این موضوع را بفهمیم می توان به صورت بازگشتی مسئله را حل کرد به اینصورت که به ازای تمام بچه های $ r_1 $ باید برابری زیردرخت آن با زیردرخت راس متناظرش در درخت $ T_2 $ را بررسی کنیم.
</p><p>به عبارتی باید دنباله بچه های $ r_1,r_2 $ را به طریقی جایگشت بدهیم سپس به ازای هر $ i $ برابری زیردرخت بچه $ i $ ام $ r_1,r_2 $ را بررسی می کنیم.
</p><p>حالا از این ایده استفاده می کنیم که ترتیب بچه های هر راس را بر حسب ویژگی خاصی مرتب کنیم. در اینصورت دیگر نیاز نیست تمام جایگشت های بچه های $ r_1,r_2 $ را بررسی کنیم و تنها کافیست ترتیب فعلی را بررسی کنیم.
</p><p>به هر درخت ریشه دار مثل $ T $ با ریشه $ r $ یک دنباله از پرانتزگذاری ها را نسبت می دهیم. به اینصورت که ابتدا زیردرخت مربوط به بچه های $ r $ را به صورت بازگشتی حساب می کنیم سپس بچه های $ r $ را بر اساس ترتیب کتابخانه ای (lexicographical order) رشته آن ها مرتب می کنیم. <b>این همان ترتیب ثابتی است که می خواستیم به بچه های هر راس نسبت بدهیم.</b> در نهایت دنباله پرانتز گذاری $ T $ به صورت $ S = (S_1S_2...S_k) $ می باشد که $ S_i $ ها دنباله پرانتزگذاری مربوط به زیردرخت بچه $ i $ ام $ r $ است.
</p><p>می توانید بررسی کنید که دو درخت ریشه دار با هم برابر هستند اگر و تنها اگر دنباله پرانتزگذاری نسبت داده شده به آن دو با هم برابر باشند.
</p><img src="/_static/dot/Hash_Tree.svg"><h2>محاسبه هش درخت ریشه دار</h2><p>از آنجایی که کار کردن با یک رشته (چسباندن دو رشته به هم یا چک کردن تساوی دو رشته) نیاز به $ O(n) $ عملیات دارد ما را به فکر می اندازد تا به جای اینکه به هر راس یک رشته نسبت دهیم، به هر راس یک عدد نسبت دهیم که هر عدد نماینده یک رشته باشد!
</p><p>پس از منطق بالا استفاده می کنیم و به عدد مربوط به هر راس را به اینصورت به دست خواهیم آورد. ابتدا اعداد بچه ها را به دست می آوریم سپس آن ها را مرتب کرده و با فرض اینکه $ H_1,...,H_k $ باشند عدد ما برابر با  $ H = 1 + \sum H_i \times P^i $ به پیمانه $ M $ خواهد بود که $ M, P $ دو عدد اول تصادفی هستند. به این تکنیک هش کردن (hash) می گویند. از آنجایی که $ M,P $ اعداد تصادفی هستند می توان فرض کرد اعداد به دست آمده تصادفی هستند و احتمال اینکه به دو درخت متفاوت اعداد یکسان نسبت دهیم بسیار ناچیز خواهد بود. (برای اطمینان می توان با $ M,P $ های بیشتر این کار را انجام داد تا احتمال خراب شدن کار کم و کمتر شود).
</p><p>پیاده سازی الگوریتمی که بیان کردیم به این صورت می باشد :
</p><pre dir="ltr">cpp
const int maxn = 1e5 + 10, P = 101, M = 1e9 + 9;
vector &lt;int&gt; v[maxn];
int calc(int u, int par = -1){
    vector&lt;int&gt; vec;
    for(int y : v[u]){
       if(y != par)
       vec.push_back(calc(y, u));
    }
    sort(vec.begin(), vec.end());
    int H = 0;
    for(int x : vec)
   H = (1ll * H * P + x) % M;
    H = (1 + H) % M;
    return H;
}
int main(){
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n - 1; i++){
 int a, b;
 cin &gt;&gt; a &gt;&gt; b;
 v[a].push_back(b);
 v[b].push_back(a);
    }
    cout &lt;&lt; calc(1) &lt;&lt; &quot;\n&quot;; // hash derakht rishe dar az 1
    return 0;
}</pre><h1>﻿تجزیه سبک سنگین(HLD)</h1><h2>تعریف</h2><p>یک روش کلاسیک مشابه گونی برای جواب دادن پرسمان های مربوط به مسیر در درخت است. مساله اصلی HLD در درخت ریشه دار افراز راس های درخت به تعدادی مسیر(chain) رو به بالا است به طوری که از هر برگی به سمت ریشه حرکت کنیم راس های حداکثر  $ O(lg(n)) $ مسیر را ببینیم.
</p><h2>الگوریتم تجزیه</h2><p>ابتدا درخت را از راس یک ریشه دار می کنیم و اندازه زیردرخت هر راس($ sz[i] $) را در زمان خطی حساب میکنیم. حال از ریشه $ dfs $ میزنیم و chain ها را طوری پیدا میکنیم که راس های هر $ chain $ یک بازه متوالی از راس هایی که میبینیم بسازند. اگر راسی که در آن هستیم(v) فرزندی داشت که اندازه اش از $ sz[v]/2 $ بیشتر یا مساوی بود به آن راس رفته و chain راس v را از ان فرزند ادامه میدهیم.(اگر هم چنین راسی وجود نداشت chain راس v را همان جا پایان میدهیم.) سپس از بقیه فرزندان راس فعلی dfs زده و هر کدام از انها را شروع chain ی جدید قرار میدهیم. 
</p><h2>اثبات درستی</h2><p>از راس دلخواهی شروع کرده و به سمت ریشه بالا میرویم. متغیر $ X $ را هم سایز زیردرخت راس فعلی تعریف میکنیم. هر بار که به سمت ریشه بالا میرویم(از ‍‍‍‍‍v به u) و وارد مسیر جدیدی میشویم, $ X $ حداقل دوبرابر میشود. وگرنه $ sz[v]*2>sz[u] $ که این یعنی راس v در ادامه chain راس u است و هنگام بالا رفتن وارد زنجیر جدیدی نمیشدیم.
یک بهینه سازی در افراز وجود دارد که لزومن زمان اجرا را بهتر نمیکند ولی از روی اثبات به وضوح می توان نتیجه گرفت زمان اجرا را بدتر نمیکند. هنگام افراز در حالتی که راس v هیچ فرزندی با سایز حداقل نصف v ندارد و اینکه راس v برگ نیست(حداقل یک فرزند دارد) به جای اینکه از زنجیر این راس را تمام کنیم انرا از بزرگترین فرزندش ادامه دهیم.(یعنی فرض کنیم سایز بزرگترین فرزندش حداقل نصف $ sz[v] $ است). 
</p><h2>پیاده سازی الگوریتم</h2><pre dir="ltr">cpp
const int MAXN = 100010;
int n, m, k, u, v, x, y;
int par[MAXN], sz[MAXN], h[MAXN], head[MAXN];
int stt[MAXN], fnt[MAXN], timer = 1;
int dfs1(int node){ // finding subtree sizes
h[node] = h[par[node]] + 1;
for(int v: G[node])
if(v != par[node]){
par[v] = node;
sz[node] += dfs1(v);
}
return ++sz[node];
}
void dfs2(int node, int hd){
head[node] = hd;
stt[node] = timer++;
int big = 0;
for(int v: G[node]) if(v != par[node] &amp;&amp; sz[big] &lt; sz[v]) big = v;
if(big) dfs2(big, hd);
for(int v: G[node]) if(v != par[node] &amp;&amp; v != big) dfs2(v, v);
fnt[node] = timer;
}
int main(){
cin &gt;&gt; n;
for (int i = 1; i &lt; n; i++){
cin &gt;&gt; u &gt;&gt; v;
G[u].push_back(v);
G[v].push_back(u);
}
dfs1(1);
dfs2(1, 1);
return 0;
}</pre><p>در اینجا هر chain یک بازه از راس ها بر حسب starting time را تشکیل میدهد. پس میتوانیم برای مسایل مختلف داده ساختاری مانند segment tree روی این ترتیب بسازیم و پرسمان مسیر را به $ O(lg(n)) $ از ان داده ساختار تبدیل کرد.(در اکثر درخت ها این مقدار خیلی کمتر از $ lg(n) $ است)
همچنین در این روش از پیاده سازی میتوانیم پرسمان های مربوط به زیردرخت را هم جواب دهیم!
</p><h1>برش ها و همبندی</h1><p>همبندی یکی از مباحث پر کاربرد در گراف است که در برنامه نویسی هم مورد استفاده قرار می گیرد.
بدون مقدمه سازی بیشتر به سمت تعاریف و قضایا می رویم تا بیشتر با همبندی آشنا شویم.
</p><h2>همبندی</h2><p>همبند بودن یک گراف به این معناست که بین هر دو راس گراف مسیر وجود داشته باشد.
</p><img src="/_static/ConnectedGraph1.png"><img src="/_static/S37.png"><img src="/_static/ConnectedGraph2.png"><h3>مولفه همبندی</h3><p>به هر قسمت همبند گراف مولفه همبندی می گویند. هر گرافی که بیش از یک مولفه داشته باشد، گراف <b>ناهمبند</b> گویند. برای مثال در یک جنگل به هر درخت موجود مولفه می گویند و تعداد مولفه های جنگل برابر تعداد درخت های موجود در آن است.
در جنگل زیر هر مولفه با رنگ متفاوت نشان داده شده است.
</p><img src="/_static/ForrestP1.png"><img src="/_static/ForrestP2.png"><img src="/_static/ForrestP3.png"><h2>همبندی در گراف های جهت دار</h2><h3>ضعیفاً همبند</h3><p>یال های گراف جهت دار را با یال های بی جهت عوض می کنیم در این صورت اگر گراف همبند باشد گوییم گراف اصلی (با یال های جهت دار) ضعیفاً همبند است.
</p><img src="/_static/WeaklyConnected.png"><h3>قویاً همبند</h3><p>به گراف جهت داری که بین هر دو راس u و v آن، مسیری جهت دار از u به v و مسیری جهت دار از v به u وجود داشته باشد، قویاً همبند گویند.
</p><p>برای حل مسائل $ 2-SAT $ از الگوریتم های موجود برای پیدا کردن اجزای قویاً همبند استفاده می شود.
</p><img src="/_static/StronglyConnected.png"><h3>مولفه قوی</h3><p>مولفه قوی زیر گراف های قویاً همبند ماکسیمال گراف هستند.
</p><h2>برش ها</h2><h3>راس برشی</h3><p>به راسی برشی گفته می شود که بعد از حذف آن از گراف به تعداد مولفه های آن اضافه شود.
</p><h3>یال برشی</h3><p>یال برشی به یالی گفته می شود که با حذف آن تعداد مولفه های همبندی افزایش پیدا کند. همچنین به آن یال برشی نیز گفته می شود.
یال uv که در دوری از گراف وجود دارد نمی تواند برشی باشد، چرا که با حذف آن دو راس u و v همچنان یه گشت به هم دارند پس مولفه ای به گراف اضافه نمی شود.</p><h1>گراف k همبند</h1><p>اولین سوالی که این بخش رو معنی دار کرد این بود که حداقل نیاز است چند راس را از گرافی حذف کنیم تا آن ناهمبند شود؟
</p><h2>گراف k همبند</h2><p>به گرافی k همبند گویند اگر بیش از k راس داشته باشد و هرگاه کمتر از k راس از گراف حذف کنیم گراف ناهمبند نشود و همینطور k بیشترین مقدار ممکن باشد و آن را به شکل $ \kappa (G) $ هم نشان می دهند.
تعریف دیگری هم برای این مفهوم موجود است و آن به این صورت است که "کمترین تعداد راسی که با حذف آن ها از گراف، گراف ناهمبند شود" که البته این تعریف یک مشکل دارد و آن هم گراف های کامل است. اگر توجه کنید هیچگاه با حذف هر تعدادی راس از گراف های کامل نمی توانید آن ها را ناهمبند کنید و در نهایت می توانید آن را راس تنها کنید که با این اوصاف با یک تغییر در تعریف دوم می توانیم آن را درست کنیم.
بنابراین می توانیم بگوییم
- کمترین تعداد راسی که با حذف آن ها از گراف، گراف ناهمبند یا راس تنها شود.
$ \kappa (u,v) $ تعریف می شود کمترین تعداد راسی که با حذف آن ارتباط بین u و v قطع می شود(یا به عبارتی در دو مولفه جدا قرار می گیرند).
</p><h2>گراف k همبند یالی</h2><p>همانند گراف k همبند تعریف می شود فقط این تعریف بجای راس ها برای یال ها صدق می کند.
بنابراین گراف k همبند یالی گرافی است که با حذف حداقل k یال بتوان آن را ناهمبند یا راس تنها کرد که آن را با $ \kappa^{\prime}(G) $ نشان می دهیم. توجه کنید که این مقدار می تواند صفر هم باشد. اگر همبند باشد و گراف یال برشی داشته باشد یک شود.
همچنین $ \kappa^{\prime}(u,v) $ تعریف می شود کمترین تعداد یالی که با حذف آن ها ارتباط بین u و v قطع می شود و آن ها را در دو مولفه جدا قرار می دهد.
</p><h2>قضیه منجر (Menger)</h2><p>چند مسیر بین راس های u و v را مجزا می نامیم اگر این چند مسیر بجز دو راس u و v راس مشترک دیگری نداشته باشند. حال می توان گفت که کمترین تعداد راسی که با حذف آن ها ارتباط بین دو راس u و v قطع می شود برابر بیشترین تعداد مسیر مجزا بین این دو راس است.
</p><p>همین قضیه برای یال ها هم استفاده می شود و به این شکل است که کمترین تعداد یال که با حذفشان ارتباط دو راس را قطع می کنند برابر بیشترین تعداد مسیر مجزا بین دو راس است.</p><h1>برش کمینه و جریان بیشینه</h1><p>در این بخش به بررسی مساله مهمی در حوزه الگوریتم ها می پردازیم که بسیاری از مسائل
را ( از جمله مساله تطابق ) می توان به کمک آن حل کرد.
</p><p>در این مساله ما یک شبکه آب داریم که چند نقطه دارد که به وسیله لوله ( یال ) های جهتدار
به هم متصل شده اند. هر لوله یک ظرفیتی دارد که به این معنی است که حداکثر جریان آبی
که می تواند از این لوله رد شود، چقدر است. دو نقطه خاص از این شبکه برای ما مهم هستند.
نقطه مبدا و مقصد، و هدف اندازه گیری بیشترین مقدار جریان آبی است که می توان از نقطه
مبدا به مقصد انتقال داد.
</p><h2>برابری با برش کمینه</h2><p>همان گراف مساله بالا را در نظر بگیرید. می‌خواهیم مجموعه ای از یال ها را حذف کنیم
که راس مبدا به مقصد مسیر جهتدار نداشته باشد. هدف این است که جمع ظرفیت یال های حذف
شده کمینه شود. به این مساله، مساله برش کمینه می‌گویند. در ادامه ثابت می‌کنیم که
در هر گراف جریان بیشینه با برش کمینه برابر است.
</p><h3>اثبات</h3><p>ابتدا واضح است که اندازه هر برشی از اندازه هر جریانی بیشتر است. زیرا حذف هر یال حداکثر
به اندازه ظرفیتش از میزان جریان کم می کند و تا زمانی که جریان وجود داشته باشد
ما به یک برش نرسیده ایم. برای اثبات اینکه جریان بیشینه با برش کمینه برابر است
یک جریان بیشینه را در نظر می گیریم و یک برش به اندازه آن به دست می آوریم.
</p><p>جریان بیشینه را در نظر بگیرید. یک مسیر افزایش دهنده مسیری است با این شرط که اگر
از یک یال در جهت خودش در مسیر استفاده کرده ایم، نباید از تمام ظرفیتش استفاده شده باشد
و اگر در جهت برعکس از آن استفاده می کنیم، باید حتما جریانی از آن رد شده باشد، برای
مثال مسیر زیر یک مسیر افزایش دهنده است:
</p><img src="/_static/flow_path.png"><p>در یک جریان بیشینه، مسیر افزایش دهنده از مبدا به مقصد وجود ندارد. زیرا اگر وجود داشته
باشد می توان جریان گذرنده را بیشتر کرد، کافیست که جریان یال هایی که در جهت مسیر هستند
(یال های آبی)
را یک واحد زیاد و جریان بقیه یال ها را یک واحد کم کنیم. با این کار جریان یک واحد بیشتر
می شود.
</p><p>حال برای پیدا کردن یک برش به اندازه جریان بیشینه = f، می توانید رئوسی را در نظر بگیرید که
از راس مبدا به آن مسیر افزایش دهنده وجود دارد. طبق مطلب بالا راس مقصد در این مجموعه
نیست. جریان ورودی این مجموعه ۰ است زیرا اگر یالی از خارج این مجموعه وجود داشته باشد
که از آن جریان گذشته باشد و به داخل این مجموعه باشد، آنگاه راس خارج مجموعه این یال نیز
باید داخل این مجموعه باشد چون مسیر افزایش دهنده به آن وجود دارد. جمع جریان ورودی و خروجی
هر مجموعه برابر جمع جریان ورودی و خروجی هر راس در آن مجموعه است. و جمع جریان ورودی و خروجی
هر راس دقیقا ۰ است به جز راس ورودی و خروجی. راس ورودی
f
واحد جریان خروجی دارد پس جمع جریان ورودی و خروجی مجموعه ای که ما در نظر گرفتیم دقیقا
f
است و چون جریان ورودی این مجموعه ۰ است، در نتیجه جریان خروجی این مجموعه f
است. یال های خروجی این مجموعه را در نظر بگیرید، همه ظرفیتشان تماما تکمیل است
(وگرنه مسیر افزایش دهنده به رئوس خروجی این یال ها وجود داشت)
و جمع ظرفیت هایشان دقیقا f است. این یال ها را قطع کنید، دیگر مسیری از مبدا به بیرون این مجموعه
و در نتیجه به مقصد وجود ندارد. پس ما برشی به اندازه f یعنی اندازه بزرگترین جریان بیشینه
پیدا کردیم. پس جریان بیشینه برابر برش کمینه است.
</p><h2>الگوریتم فورد فلکرسون برای جریان بیشینه</h2><p>سعی می کنیم که یک مسیر افزایش دهنده از مبدا به مقصد پیدا کنیم و به کمک آن
یک واحد به جریان اضافه کنیم. آن قدر این کار را ادامه می دهیم تا دیگر مسیر افزایش دهنده
وجود ندارد. یک جریان به دست می آید که برشی به اندازه آن وجود دارد. و چون می دانیم
که همه برش ها بزرگتر مساوی همه جریان ها هستند، جریانی که پیدا کرده ایم قطعا جریان
بیشینه است.
</p><p>قطعه کد زیر پیاده سازی این الگوریتم است. برای سادگی کار، به جای این که برای پیدا کردن
مسیر حالت های در جهت و در خلاف جهت را جداگانه بررسی کنیم، به ازای هر یال یک یال در خلاف
جهت آن و با وزن ۰ قرار می دهیم. هر گاه که از یک یال جریانی گذراندیم، ظرفیت خودش را کم
می کنیم و به ظرفیت یال دوگان آن یال اضافه می کنیم. 
</p><pre dir="ltr">cpp
int cnt, head[M], pre[M], cap[M], to[M], from[M];
int n,m;
void add(int u, int v, int w){
    // ezafe kardane yale asli
    from[cnt] = u;
    to[cnt] = v;
    pre[cnt] = head[u];
    cap[cnt] = w;
    head[u] = cnt++;
    // ezafe kardane yale dogaan
    from[cnt] = v;
    to[cnt] = u;
    pre[cnt] = head[v];
    cap[cnt] = 0;
    head[v] = cnt++;
}
int tnod = 0;
bitset &lt;M&gt; mark;
// say mikonim ke masir afzaayesh dahande peydaa konim
int dfs(int u, int mn){
    mark[u] = 1;
    if(u == tnod)return mn;
    // yal haye ras u dar yek link list rikhte shode and.
    for (int i = head[u]; i != -1; i = pre[i]){
        // agar yale hadaf zarfiat nadasht bikhiaale aan mishavim
        if (cap[i] == 0 || mark[to[i]]) continue;
        // say mikonim ke jaryani be maghsad peyda konim
        int s = dfs(to[i], min(mn,cap[i]));
        // agar s = 0 nabashad, masir afzayesh dahande i vojood darad ke
        // kam zarfiat tarin yale aan s vahed zarfiat darad
        if (s){
            // az zarfiate yal s vahed kam mikonim
            cap[i] -= s;
            // be zarfiate yaale dogan s vahed ezafe mikonim
            cap[i^1] += s;
            // elam mikonim ke masir s vahedi peyda shode ast
            return s;
        }
    }
    // masiri peyda nakardim 
    return 0;
}
int maxflow(){
    int flow = 0;
    while(1){
        mark &amp;= 0;
        int s = dfs(0, inf);
        // agar masiri peyda nashode bood flow = maxflow
        if (!s) return flow;
        flow += s;
    }
}</pre><p>در این الگوریتم برای پیدا کردن مسیر افزایش دهنده از الگوریتم DFS استفاده کرده ایم. این
الگوریتم در هر مرحله حداقل یک واحد به جریان موجود اضافه می کند و چون زمان
DFS خطی است این الگوریتم پیچیدگی زمانی
$ O(ef) $
دارد که e تعداد یال ها و f مقدار بیشینه جریان است.
اگر به جای الگوریتم 
DFS از الگوریتم BFS
استفاده می کردیم کران
$ O(ve^2) $
نیز ثابت شده بود که به اثبات آن نمی پردازیم.
</p><h2>پیدا کردن عدد همبندی راسی و یالی</h2><p>به کمک الگوریتم جریان بیشینه می توان عدد همبندی راسی و یالی را در زمان چند جمله ای
به دست آورد.
</p><p>برای به دست آوردن عدد همبندی یالی، به ازای هر یال دو یال جهت دار با وزن ۱ در خلاف جهت
هم بین این دو راس اضافه می کنیم. سپس بین هر دو راس جریان بیشینه را پیدا می کنیم که برابر
برش کمینه نیز هست. با توجه به این که برش کمینه هر دو جهت یال را قطع نمی کند، برش
کمینه این گراف با گراف بی جهت برابر است. و هر برش دو راس را ناهمبند می کند پس از عدد همبندی
یالی گراف بیشتر است و چون کمینه یال های لازم برای ناهمبند کردن یک گراف دو راس را از
هم جدا می کند کمینه این برش ها همان عدد همبندی یالی گراف است. پیچیدگی زمانی این الگوریتم
$ O(v^3e) $
است زیرا جواب از تعداد راس ها کمتر است.
</p><p>برای به دست آوردن عدد همبندی راسی گراف، یک گراف جدید می سازیم که به ازای هر راس دو راس
دارد. یک راس ورودی و یک راس خروجی. به ازای هر یال نیز دو یال اضافه می کنیم. از راس های
ورودی متناظر به راس های خروجی متناظر. برای هر راس نیز از ورودی به خروجی یال می کشیم.
یال های متناظر با یال ها ظرفیت بینهایت و یال های درون هر راس ظرفیت ۱ دارد. برای این که
به دست بیاوریم که چه میزان راس مورد نیاز است حذف شود تا دو راس مورد نظر ناهمبند شوند،
می توان برش کمینه بین این دو راس را در گراف به دست آورد. برای هر دو راس این مقدار را
محاسبه می کنیم و عدد همبندی راسی به دست می آید. پیچیدگی زمانی این الگوریتم
$ O(v^3e) $
است زیرا جواب از تعداد راس ها کمتر است.
</p><h1>آشنایی</h1><h2>تعریف</h2><p>تطابق مجموعه‌ای از یال‌هاست که هیچ‌دوتایی از آنها باهم راس مشترک ندارند.
</p><p>به زبان ریاضی، اگر گراف را $ G $ و مجموعه یال‌های آن را $ E $ درنظر بگیریم، به زیرمجموعه‌ای از $ E $ که هیچ‌یک از دو عضو آن راس مشترکی در $ G $ ندارند، تطابق یا مجموعه‌ ناوابسته‌ یال‌ها می‌گویند و آن را با $ M $ نشان می‌دهند.
</p><p>به راسی که در یکی از دو انتهای یال‌های تطابق گراف  $ G $ واقع شده باشد، راس اشباع (منطبق شده) و در غیر این صورت راس غیراشباع (منطبق نشده) می‌گویند.
</p><img src="/_static/matching_example.jpg"><h2>تطابق ماکسیمال و ماکسیمم</h2><p>تطابق ماکسیمال یک تطابق در $ G $ است، به صورتی که هر یال دیگری که در تطابق نیامده باشد را که به آن اضافه کنیم، گراف به وجود آمده خاصیت تطابق بودن خود را از دست بدهد. به عبارتی دیگر، تطابق $ M $ زمانی ماکسیمال است که هر یال $ G $ حداقل با یکی از یال‌های آن تقاطع داشته باشد.
</p><p>تطابق ماکسیمم تطابقی است که بیشترین تعداد یال‌های $ G $ را دارد. بنابراین می‌توان نتیجه گرفت هر تطابق ماکسیمم، یک تطابق ماکسیمال است، ولی هر تطابق ماکسیمال لزوما یک تطابق ماکسیمم نیست.
</p><p>تطابق کامل نیز تطابقی است که در آن همه راس‌ها اشباع هستند (در اصل تعداد یال‌های آن برابر $ |G| / 2 $ است). همچنین به راحتی می‌توان دید که تطابق ماکسیمال حداقل برابر نصف تطابق ماکسیمم است.
</p><img src="/_static/matchings.png"><h2>مسیر متناوب و افزایشی</h2><p>مسیر متناوب، مسیری است که یال‌های آن یکی در میان در میان یال‌های تطابق و خارج از یال‌های تطابق است.
</p><p>مسیر افزایشی، مسیری متناوب است که راس‌های اول و آخر آن غیراشباع هستند و در تطابق وجود ندارند.
</p><img src="/_static/matching_paths.png"><p>یک تطابق ماکسیمم است، اگر و تنها اگر مسیر افزایشی نداشته باشد که این نتیجه‌گیری به قضیه‌ی برژ نیز معروف است.
</p><p>برای اثبات این که تطابق ماکسیمم مسیر افزایشی ندارد می توانیم با فرض خلف یک مسیر افزایشی در نظر بگیریم. چون مسیر افزایشی یک مسیر
متناوب است و راس اول و آخر آن درون تطابق نیستند می توان یال های تطابق که در این مسیر هستند را از تطابق حذف کرد و یال های
دیگر این مسیر را به جای آن ها به تطابق اضافه کرد. چون راس اول و آخر درون تطابق نیستند یال های خارج از تطابق در هر مسیر
افزایشی یکی بیشتر از یال های درون تطابق است. پس به اندازه تطابق یک واحد اضافه می شود و تطابق بزرگتری ساخته می شود، که با فرض
ماکسیمم بودن تطابق اولیه در تناقض است. پس تطابق بیشینه، هیچ مسیر افزایشی ندارد.
</p><p>اثبات عکس این قضیه یعنی اگر تطابقی مسیر افزایشی نداشته باشد آنگاه تطابق ماکسیمم است نیز به روش برهان خلف قابل انجام است:
فرض کنید تطابق $ M' $ تطابقی ماکسیمال بدون مسیر افزایشی و تطابق $ M $ تطابق بیشینه است. در این صورت گراف
$ M \Delta M' $
را درنظر بگیرید. درجه هر راس در آن حداکثر برابر دو است. پس این گراف از تعدادی دور و مسیر یکی‌درمیان تشکیل می‌شود. در دور‌ها و مسیرهای زوج، تعداد یال‌های هر دو تطابق باهم برابر است. در مسیرهای فرد نیز حتما اولین و آخرین یال از
$ M $
است، زیرا در غیر این صورت می‌توانستیم به جای یال‌های
$ M $
در مسیر از یال‌های
$ M' $
استفاده کنیم و اندازه تطابق را افزایش دهیم. پس اگر مسیر فردی داشته باشیم یعنی حداقل یک
مسیر افزایشی داریم که این تناقض است. پس نتیجه میگیریم که مسیر فردی نداریم و
$ |M| = |M'| $.
</p><img src="/_static/matching_diff.jpg"><h2>پوشش راسی و یالی</h2><p>به مجموعه‌ای (پوششی) از رئوس که هر یال حداقل یکی از دو سرش در این مجموعه آمده باشد، پوشش راسی می‌گوییم.
</p><img src="/_static/vertex_cover.png"><p>به مجموعه‌ای (پوششی) از یال‌ها که هر راس حداقل یکی از یال‌های مجاورش در این مجموعه آمده باشد، پوشش یالی می‌گوییم.
</p><img src="/_static/edge_cover.png"><p>به پوشش راسی با مینیمم تعداد راس، مینیمم پوشش راسی و به پوشش یالی با مینیمم تعداد یال، مینیمم پوشش یالی می‌گوییم.
</p><img src="/_static/min_vertex_cover.png"><img src="/_static/min_edge_cover.png"><h1>تطابق در گراف دوبخشی</h1><p>در بخش قبل گفتیم که شرط لازم و کافی برای داشتن یک تطابق ماکسیمم این است که مسیر افزوده وجود نداشته باشد. این شرط در گراف دوبخشی به راحتی قابل بررسی است (چرا؟).
</p><p>در نتیجه بررسی کردن تطابق در گراف های دوبخشی (به عنوان حالت خاصی از گراف) به علت کاربرد زیادشان سودمند است.
</p><h2>الگوریتم</h2><p>در این الگوریتم از تطابق خالی شروع می‌کنیم و تا زمانی که مسیری افزایشی در گراف وجود داشت تطابق را بزرگ‌تر می‌کنیم. به راحتی قابل مشاهده است که در این صورت ماکسیمم بودن تطابق نهایی ما بدیهی است. برای پیدا کردن مسیر افزایشیبه این صورت عمل میکنیم:
</p><p>فرض کنید گراف ما شامل دو بخش $ n_1 $ راسی و $ n_2 $ راسی باشد. به ازای $ v = 1 ... n_1 $ در گراف حال حاضرمان به دنبال مسیر افزایشی می‌گردیم. در مرحله $ i $ ام می‌توان ادعا کرد تطابقی که بین $ i $ راس بخش اول و بقیه رئوس بخش دوم است ماکسیمم است، در نتیجه در آخر نیز تطابق ما ماکسیمم خواهد بود. پیاده‌سازی آن به شکل زیر است:
</p><pre dir="ltr">cpp
const int N = 2e3 + 5;
int n1, n2, m, k, match[N];
vector &lt;int&gt; adj[N];
bool mark[N];
bool try_kuhn(int u){
    mark[u] = true;
    for(auto v: adj[u])
        if(match[v] == -1 || (!mark[match[v]] &amp;&amp; try_kuhn(match[v]))){
            match[v] = u;
            return true;
        }
    return false;
}
void read_input(){
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;
    for(int i = 0; i &lt; m; i++){
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[--u].push_back(--v);
    }
}
void calc(){
    memset(match, -1, sizeof match);
    for(int u = 0; u &lt; n1; u++){
        memset(mark, false, sizeof mark);
        k += try_kuhn(u);
    }
}
void write_output(){
    cout &lt;&lt; k &lt;&lt; endl;
    for(int u = 0; u &lt; n2; u++)
        if (match[u] != -1)
            cout &lt;&lt; match[u] + 1 &lt;&lt; ' ' &lt;&lt; u + 1 &lt;&lt; endl;
}
int main() {
    read_input();
    calc();
    write_output();
    return 0;
}</pre><p>در الگوریتم ذکر شده به ازای هر راس از بخش بالا، $ O(m) $ گام انجام می‌شود، پس پیچیدگی زمانی آن برابر $ O(nm) $ است. البته یک نوع پیاده‌سازی دیگر همین الگوریتم نیز وجود دارد که سرعت آن حداقل دوبرابر سریع‌تر از الگوریتم بالا است (چرا؟):
</p><pre dir="ltr">cpp
const int N = 2e3 + 5;
int n1, n2, m, k, match[N];
vector &lt;int&gt; adj[N];
bool mark[N];
bool try_kuhn(int u){
    mark[u] = true;
    for(auto v: adj[u])
        if (match[v] == -1 || (!mark[match[v]] &amp;&amp; try_kuhn(match[v]))) {
            match[v] = u;
            return true;
        }
    return false;
}
void read_input(){
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;
    for(int i = 0; i &lt; m; i++){
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[--u].push_back(--v);
    }
}
void calc(){
    memset(match, -1, sizeof match);
    while(true){
        bool flag = false;
        memset(mark, false, sizeof mark);
        for(int u = 0; u &lt; n1; u++)
            if (!mark[u])
                k += try_kuhn(u);
        if (!flag)
            break;
    }
}
void write_output(){
    cout &lt;&lt; k &lt;&lt; endl;
    for (int u = 0; u &lt; n2; u++)
        if (match[u] != -1)
            cout &lt;&lt; match[u] + 1 &lt;&lt; ' ' &lt;&lt; u + 1 &lt;&lt; endl;
}
int main(){
    read_input();
    calc();
    write_output();
    return 0;
}</pre><h2>قضیه هال</h2><p>این قضیه شرط لازم و کافی دیگری برای ماکسیمم بودن یک تطابق در یک گراف دوبخشی را بیان می‌کند که اولین بار توسط فیلیپ هال مطرح شد و به قضیه ازدواج معروف است. این قضیه به شرح زیر است:
</p><p>فرض کنید $ X $ مجموعه‌ای از رئوس بخش اول یک گراف دوبخشی باشد. مجموعه $ X $ در گراف تطابق کامل دارد، اگر و تنها اگر به ازای هر زیرمجموعه از آن مثل $ S $ و مجموعه همسایه‌های خارج $ X $ آن‌ها در گراف به نام $ T $، داشته باشیم $ |S| \leq |T| $.
</p><p>لازم بودن شرط بالا بدیهی است (در غیر این صورت تعداد رئوس مجاور یک مجموعه برای تطابق دادنشان کافی نخواهد بود). برای اثبات کافی بودن نیز از برهان خلف استفاده می‌کنیم و فرض می‌کنیم گرافی با چنین خاصیتی باشد که تطابق کامل نداشته باشد؛
</p><img src="/_static/marriage_theorem.jpeg"><p>یک تطابق ماکسیمم را درنظر می‌گیریم و راس دلخواهی مثل $ u $ که غیراشباع است را درنظر می‌گیریم (حتماً وجود دارد!). از آنجا که این راس با کسی منطبق نشده، راس منطبق یک راس دلخواه مجاور آن را درنظر میگیریم. این دو راس طبق فرض مسئله یک راس مجاور دیگر دارند که یا منطبق نشده (که در این صورت مسیر افزایشی داریم) و یا منطبق شده که راس منطبق آن را نیز به این دو راس اضافه می‌کنیم. این کار را تا جای ممکن ادامه می‌دهیم و از آنجا که تعداد رئوس مجاور $ X $ حداقل اندازه خودشان است، در آخر به مرحله‌ای میرسیم که مجموعه حال حاضرمان یک راس مجاور دارند که اشباع نشده که در این صورت مسیر افزایشی داریم که این با ماکسیمم بودن تطابقمان در تناقض است.
</p><h2>تطابق در گراف دوبخشی k منتظم</h2><p>طبق قضیه هال می‌توان اثبات کرد که گراف دوبخشی k منتظم تطابق کامل دارد. برای اثبات این موضوع نیز کافیست اثبات کنیم که شرط هال برای آن برقرار است؛
</p><p>مجموعه‌ای از رئوس بخش اول گراف مثل $ S $ را درنظر بگیرید و همسایه‌های آن‌ها در بخش دوم را $ T $ بنامید. اثبات می‌کنیم $ |S| \leq |T| $. می‌دانیم مجموع یال‌های بین دو بخش برابر $ x = |S| \times k $ است. از این رابطه می‌توان نتیجه گرفت $ |T| \geq (x \div k) = |S| $.
</p><img src="/_static/dot/K_R_Bipartite_Subgraph.svg"><p>پس حکم حال در گراف ما برقرار است و قطعاً در گراف ما تطابقی کامل یافت می‌شود.
</p><h2>تعمیم قضیه هال</h2><p>یک گراف دوبخشی به نام $ G $ داریم و می‌خواهیم تعدادی از یال‌های آن را برداریم، طوری که درجه هر راس بخش اول مثل $ u $ برابر $ a_u $ و درجه هر راس بخش دوم حداکثر یک شود. برای حل این مسئله گراف $ G' $ را به گونه‌ای میسازیم که در آن تطابق کامل از بخش اول به دوم وجود دارد، اگر و تنها اگر در گراف $ G $ چنین مجموعه یال‌هایی وجود داشته باشد؛
</p><p>گراف $ G' $ را بدین گونه می‌سازیم که به جای هر راس $ u $ در گراف از بخش اول، یک مجموعه $ a_u $ تایی از رئوس می‌سازیم (که کپی هایی از راس $ u $ هستند) و به ازای هر یال گراف مثل $ (u, v) $، تمام مجموعه راس $ u $ را به راس  $ v $ متصل می‌کنیم. گراف حاصل دوبخشی است (چرا؟) اگر شرط هال در آن برقرار باشد یعنی تطابق کامل دارد که در این صورت به ازای هر یال بین مجموعه رئوس راس $ u $ و راس $ v $ در گراف، یال $ (u, v) $ را در گراف $ G $ برمی‌داریم که بدیهی است که در این صورت به مجموعه یال‌های دلخواهمان می‌رسیم. در صورتی هم که گراف $ G' $ تطابقی کامل نداشته باشد به همین شکل می‌توان نتیجه گرفت که در گراف $ G $ نیز چنین مجموعه‌ای وجود ندارد (به صورت برعکس عمل میکنیم).
</p><p>فرایند چک کردن شرط هال در گراف $ G^{\prime} $ را در نظر بگیرید.به ازای هر زیرمجموعه $ S $ که از بخش اول گراف $ G ^ {\prime} $ و مجموعه همسایه های آن $ T $ است، چک می کنیم که $ |S| \leq |T| $ برقرار باشد. حالا می توان توجه کرد که به ازای هر راس $ u $ اگر تعدادی از کپی های $ u $ در $ S $ آمده باشد ولی همه آن ها نیامده باشند می توان همه را به مجموعه $ S $ اضافه کرد در اینصورت $ T $ تغییری نخواهد کرد و تنها $ S $ زیاد می شود. پس می توان فقط $ S $ هایی را چک کرد که به ازای هر $ u $ یا تمام کپی های $ u $ آمده اند یا هیچکدام نیامده اند.
</p><p>با کمی تفکر نتیجه می گیریم که طبق حرف های بالا می توان روی گراف $ G $ این شرط لازم و کافی را پیدا کرد : $ \forall_{S} \sum\limits_{i \in S} a_i \leq |T| $
</p><p>که $ S $ هر زیرمجموعه ای از راس های بخش اول گراف است و  $ T $ اجتماع همسایه های $ S $ است.   
</p><h1>قضایا ی مینماکس</h1><p>در این بخش تعدادی قضیه را بررسی می کنیم که بیان می کنند مینیمم یک مقدار برابر است با ماکسیمم یک مقدار دیگر. تعدادی از این قضیه ها در هر گرافی برقرار است و تعدادی دیگر تنها در گراف دوبخشی برقرار هستند.
</p><p>ابتدا این علائم را قرار داد می کنیم‌ :
</p><p>+------------------------+-----------------------+
|:math:دستور پشتیبانی نشده          | ماکسیمم مجموعه مستقل  |
+------------------------+-----------------------+
|:math:دستور پشتیبانی نشده | ماکسیمم تطابق         |
+------------------------+-----------------------+
|:math:دستور پشتیبانی نشده           | مینیمم پوشش راسی      |
+------------------------+-----------------------+
|:math:دستور پشتیبانی نشده  | مینیمم پوشش یالی      |
+------------------------+-----------------------+
</p><h2>قضیه های برقرار در هر گرافی</h2><h3>:math:`\alpha + \beta = n`</h3><p>مکمل یک مجموعه مستقل یک پوشش راسی و مکمل یک پوشش راسی یک مجموعه مستقل است(چرا؟). در نتیجه اگر ماکسیمم مجموعه مستقل را در نظر بگیرید مکمل آن مینیمم پوشش راسی است و بالعکس.
</p><h3>:math:`\alpha^{\prime} + \beta^{\prime} = n`</h3><p>ابتدا باید فرض کنیم که گراف راس تنها ندارد زیرا در غیراینصورت پوشش یالی برای این گراف تعریف نمی شود.
</p><p>حالا مینیمم پوشش یالی را در نظر بگیرید.
</p><p>در ابتدا می توان نتیجه گرفت در این مجموعه یالی دور وجود ندارد (در اینصورت با حذف یکی از یال های دور به مجموعه کوچک تری رسید که همچنان پوشش یالی است). پس هر مولفه همبندی آن یک درخت است.
</p><p>سپس می توان نتیجه گرفت در هیچکدام از درخت ها فاصله بیشتر از 2 وجود ندارد (چرا؟). پس هر کدام از درخت ها یک ستاره هستند.
</p><p>تعداد ستاره ها $ n-\beta^{\prime} $ می باشد. و می توان از هر ستاره دقیقا یک یال را انتخاب کرد و یک تطابق تشکیل داد که اندازه آن کمتر مساوی تطابق ماکسیمم است. یعنی $ n-\beta^{\prime} \leq \alpha^{\prime} $ در نتیجه $ n \leq \alpha^{\prime} + \beta^{\prime} $.
</p><p>حالا تطابق ماکسیمم را در نظر بگیرید.
</p><p>هر راسی مثل $ u $ که با تطابق ماکسیمم پوشش داده نمی شود را در نظر بگیرید. تمام مجاور های $ u $ باید با تطابق ماکسیمم پوشش داده شود (چرا؟) و چون راس تنها نداریم $ u $ حداقل یک مجاور دارد.
</p><p>حالا یک پوشش یالی می سازیم. ابتدا تمام یال های تطابق را به آن اضافه می کنیم. سپس به ازای هر راسی که با تطابق ماکسیمم پوشش داده نشده یکی از یال های مجاورش را به پوشش راسی اضافه می کنیم. حالا پوشش راسی به اندازه $ n - \alpha^{\prime} $ داریم زیرا که $ \alpha^{\prime} $ یال اولیه هر کدام دو راس را پوشش دادند و بقیه یال ها هر کدام یک راس را پوشش دادند. $ n-\alpha^{\prime} \geq \beta^{\prime} $ در نتیجه $ n \geq \alpha^{\prime} + \beta^{\prime} $.
</p><p>در نهایت دو قسمت بالا حکم را نتیجه می دهند.
</p><h3>:math:`\beta \geq \alpha^{\prime}`</h3><p>تطابق ماکسیمم را در نظر بگیرید. تنها برای اینکه یال های مربوط به این تطابق را پوشش دهید به $ \alpha^{\prime} $ راس نیاز دارید. (هر راس حداکثر می تواند یکی از آن ها را پوشش دهد). پس $ \beta \geq \alpha^{\prime} $.
</p><h2>قضیه های برقرار در گراف دوبخشی</h2><h3>:math:`\alpha^{\prime} = \beta`</h3><p>در قسمت بالا داشتیم $ \beta \geq \alpha^{\prime} $ پس هر پوشش راسی بزرگتر مساوی یک تطابق است. پس اگر یک تطابق پیدا کنیم که برابر با یک پوشش راسی باشد در اینصورت حکم را ثابت کردیم همچنین آن تطابق ماکسیمم خواهد بود و آن پوشش راسی مینیمم خواهد بود.
</p><p>یک پوشش راسی مینیمم را در نظر بگیرید. فرض کنید گراف دو بخشی ما دارای دوبخش $ X,Y $ است و مجموعه راس های پوشش راسی ما $ X1 \cup Y1 $ است که $ X1 $ از بخش $ X $ و $ Y1 $ از بخش $ Y $ می باشد همچنین $ X2=X-X1, Y2=Y-Y1 $.
</p><p>حالا گرافی که تنها شامل راس های $ X1,Y2 $ باشند را در نظر بگیرید. می خواهیم یک تطابق کامل از $ X1 $ به $ Y2 $ پیدا می کنیم (یعنی کل راس های $ X1 $ درون تطابق باشند).
</p><p>برقرار بودن شرط هال را برای پیدا کردن یک تطابق کامل از $ X1 $ به $ Y2 $ بررسی می کنیم. فرض کنید $ S \subseteq X1 $ ادعا می کنیم $ |S| \leq |n(S)| $ برقرار است. فرض کنید برقرار نباشد یعنی $ |S| > |n(S)| $ آنگاه اگر مجموعه $ S $ را از پوشش راسی حذف کنیم و مچموعه $ n(S) $ را به پوشش راسی اضافه کنیم همچنان همه یال ها پوشانده می شوند و به یک پوشش راسی کوچکتر رسیدیم که با مینیمم بودن پوشش راسی فعلی در تناقض است. پس شرط هال برقرار است.
</p><p>مشابها می توان یک تطابق کامل از $ Y1 $ به $ X2 $ پیدا کرد. که نتیجه می دهد ما تطابقی پیدا کردیم که اندازه آن برابر با پوشش راسی است.
</p><h3>:math:`\beta^{\prime} = \alpha`</h3><p>از بخش های قبل داشتیم‌ که $ \alpha^{\prime} = \beta $ و  $ n - \alpha = \beta $ و $ n - \beta^{\prime} = \alpha^{\prime} $ برقرارند.
</p><p>در نتیجه $ n - \alpha = n - \beta^{\prime} $ پس $ \alpha = \beta^{\prime} $.
</p><h1>کاربرد ها</h1><h2>گراف جهت دار و دوبخشی</h2><p>در این بخش می بینیم که دو مفهوم گراف دوبخشی و جهت دار قابل تبدیل به یکدیگر هستند و بسته به اینکه کدام یک شهود بهتری برای حل مسئله به ما می دهند می توانیم از یکی از آن دو استفاده کنیم.
</p><p>ماتریس مجاورت یک گراف دوبخشی و جهت دار را در نظر بگیرید. هر دو ماتریسی $ n*n $ هستند که در خانه ها 0,1 قرار دارد. (لزوما ماتریس متقارن نیست)
</p><p>حالا برای تبدیل گراف جهت دار به دوبخشی کافیست ماتریس مجاورت گراف جهت دار که آن را $ M $ می نامیم در نظر بگیرید و گراف دو بخشی رسم کنید که ماتریس مجاورت آن $ M $ باشد. تبدیل گراف دوبخشی به جهت دار نیز مشابه است. اگر بخواهیم شهودی تر به مطلب نگاه کنیم هر یال $ ab $ در گراف جهت دار معادل یک یال بین راس $ a $ از بخش سمت چپ و راس $ b $ از بخش سمت راست است. یعنی بخش سمت چپ نماینده خروجی ها و بخش سمت راست نماینده ورودی ها است.
</p><p>حالا یک تطابق در گرافی دوبخشی را در نظر بگیرید. اگر گراف دوبخشی را به گراف جهت دار تبدیل کنیم تطابق ما به چه چیزی تبدیل خواهد شد؟ 
</p><p>تعدادی دور و مسیر جهت دار! زیرا که در گراف دوبخشی از هر راس حداکثر یک یال مجاور انتخاب شده است این موضوع در گراف جهت دار به این معنی است که هر راس حداکثر یک ورودی و حداکثر یک خروجی دارد.
</p><h2>افراز dag به مسیر ها</h2><p>یک گراف جهت دار بدون دور داریم. مینیمم $ x $ که می توان این گراف را به $ x $ مسیر جهت دار افراز کرد چند است؟
</p><p>توجه کنید که اگر در این افراز بهینه تعداد یال های مسیر ها $ y $ باشد آنگاه $ x+y=n $ پس برای مینیمم کردن $ x $ کافی است $ y $ را ماکسیمم کنیم. گراف جهت دار را به دوبخشی تبدیل کنید. حالا $ y $ برابر است با ماکسیمم تطابق این گراف دوبخشی.‌ (چرا؟)
</p><h2>افراز گراف جهت دار به دور ها</h2><p>فرض کنید در یک گراف جهت دار می خواهیم یک روش برای افراز کردن این گراف به دور ها پیدا کنیم.
</p><p>ابتدا گراف را به فرم دوبخشی در بیاورید. گفتیم یک تطابق به معنای افراز به دور ها و مسیر ها است. می توانید به راحتی نتیجه گیری کنید که یک تطابق کامل به ما یک افراز به دور ها را ارائه می دهد. پس کافیست یک تطابق کامل در گراف دوبخشی پیدا کنیم.
</p><h2>گراف 2k منتظم و افراز به دور ها</h2><p>این بار موضوع بحث ما گرافی بی جهت است. مشابه مسئله بالا تصور کنید گرافی <b>بی جهت</b> مثل $ G $ داریم و می دانیم $ 2k $ منتظم است. می خواهیم <b>اثبات کنیم</b> یک روش برای افراز این گراف به دور ها وجود دارد.
</p><p>اولین ایده این است که به ازای هر یال $ G $ مثل $ ab $ در یک گراف جهت دار دو یال $ ab, ba $ را قرار دهیم. سپس مشابه مسئله بالا ابتدا گراف جهت دار را به فرم دوبخشی در بیاوریم و سپس تلاش کنیم تطابقی کامل پیدا کنیم.
</p><p>مشکلی که در این راه به وجود می آید این است که در این افراز ممکن است دور هایی به طول 2 (که همان تک یال می باشند) به وجود بیاید که این موضوع برای ما مطلوب نیست.
</p><p>برای اینکه این مشکل به وجود نیاید تور اویلری گراف را در نظر بگیرید و هر یال را در جهتی که تور اویلری آن را می پیماید جهت دار کنید. (اگر گراف چندین مولفه همبندی داشت این کار را برای هر کدام از مولفه ها انجام می دهیم).
حالا گراف حاصل گرافی جهت دار است که در هر راس آن درجه ورودی و خروجی برابر با $ k $ می باشد. حالا اگر این گراف را به فرم دوبخشی در بیاوریم هر راس آن درجه $ k $ خواهد داشت. 
</p><p>طبق قضیه ای که قبلا ثابت کردیم گراف دوبخشی $ k $ منتظم تطابق کامل دارد پس در این گراف جهت دار هم روشی برای افراز به دور ها وجود دارد.
</p><h2>دنباله درجه ای تورنومنت و تطابق</h2><p>فرض کنید دنباله $ d_1,d_2,...d_n $ داده شده است و می دانیم $ \sum\limits_{i=1}^{n} d_i = {n \choose 2} $.می خواهیم بررسی کنید آیا تورنومنتی وجود دارد درجه خروجی هر راس مثل $ u $ برابر با $ d_u $ باشد؟
</p><p>گرافی دوبخشی بسازید. بخش سمت راست $ n $ راس دارد و سمت چپ $ n \choose 2 $ راس دارد و هر کدام از راس های بخش سمت چپ به نشانه یک یال از تورنومنت می باشد. راسی که به نشانه یال $ ab $ است را به راس $ a $ و راس $ b $ از بخش سمت راست متصل کنید. حالا یک زیرمجموعه از یال ها انتخاب کنید که درجه هر راس سمت چپ برابر با 1 و درجه راس $ u $ از بخش سمت راست برابر با $ d_u $ باشد. (شبیه تطابقی که در بخش تعمیم هال بررسی کردیم).
</p><p>به طور شهودی این هر راس سمت چپ مثل راسی که به نشانه $ ab $ است باید یکی از دو راس $ a $ یا $ b $ را انتخاب کند. اگر $ a $ را انتخاب کند یعنی قرار است در تورنومنت یال بین راس $ a,b $ از $ a $ به $ b $ جهت دار شده باشد و بالعکس. همچنین قرار است درجه خروجی راس $ u $ در تورنومنت برابر با $ d_u $ باشد پس هر راس $ u $ از بخش سمت چپ باید توسط دقیقا $ d_u $ راس از بخش سمت چپ انتخاب شده باشد!
</p><p>پس طبق مطالبی که در بخش تعمیم هال بررسی کردیم شرط لازم و کافی برای وجود داشتن چنین تورنومنتی این است که به ازای هر زیرمجموعه از راس های سمت چپ مثل $ S $ اگر اجتماع مجاور های آن در بخش سمت راست $ P $ باشد آنگاه :
$ |S| \leq \sum\limits_{u \in P} d_u $
از آنجایی که می توانیم بدون تغییر دادن سمت راست نامساوی، سمت چپ را تا $ |P| \choose 2 $ زیاد کنیم (چرا؟) پس می توانیم شرط را به این صورت نیز بنویسیم :
</p><p>$ \forall_{P \subseteq \{1,2,...,n\}} {|P| \choose 2} \leq \sum\limits_{u \in P} d_u $
</p><p>حالا از آنجایی که در سمت چپ نامساوی تنها تعداد اعضای مجموعه مهم است نه خود مجموعه پس کافیست شرط را به ازای کمترین $ d_u $ ها بررسی کنیم. به عبارتی با فرض $ d_1 \leq d_2 \leq ... d_n $ شرط زیر لازم و کافی می باشد :
</p><p>$ \forall_{1 \leq k \leq n} {k \choose 2} \leq \sum\limits_{i=1}^{k} d_i $
</p><h2>راس های ثابت در تطابق دو بخشی</h2><p>یک گراف دوبخشی داریم. به ازای تطابق $ M $ هر راس $ u $ که مجاور یکی از یال های $ M $ باشد را حاضر در $ M $ می گوییم. حالا شما باید به ازای تمام راس ها مثل $ u $ بگویید آیا تطابقی ماکسیممی وجود دارد که $ u $ در این تطابق حاضر <b>نباشد</b>؟ 
</p><p>ابتدا یک تطابق ماکسیمم دلخواه مثل $ M $ را در نظر بگیرید. حالا به ازای تمام راس هایی که در $ M $ حاضر نیستند جواب را می دانیم. و می خواهیم به ازای هر راس حاضر در $ M $ مثل $ u $ جواب را بیابیم. فرض کنید تطابق ماکسیممی مثل $ M^{\prime} $ وجود دارد که $ u $ در آن حاضر نیست. حالا فرض کنید تفاضل متقارن $ M $ و $ M^{\prime} $ برابر با $ H $ باشد. در اینصورت $ H $ باید شامل تعدادی دور و مسیر زوج باشد همچنین $ u $ باید ابتدای یکی از این مسیر های زوج باشد(چرا؟)!  
</p><p>پس نتیجه می گیریم به ازای هر راس $ u $ که عضو تطابق $ M $ هست می توانیم تطابقی پیدا کنیم که $ u $ در آن حاضر نباشد اگر و فقط اگر مسیری متناوب از راسی آزاد (راسی که در تطابق $ M $ نیامده است) به $ u $ وجود داشته باشد دقت کنید از آنجایی که این مسیر افزوده مسیر افزایشی نیست پس دو سر مسیر در یک بخش از گراف دوبخشی ما قرار دارند.
</p><p>تا اینجای کار از دوبخشی بودن گراف استفاده ای نکردیم (تمام حکم هایی که بیان شد برای هر گرافی صدق می کند). اما حالا برای پیدا کردن یک تطابق ماکسیمم و راس هایی که شروع مسیر متناوب هستند باید از دوبخشی بودن گراف استفاده کنیم.
</p><p>ابتدا با الگوریتمی که در بخش 12.2 ارائه دادیم تطابق ماکسیمم $ M $ را پیدا کنید.
</p><p>حالا فرض کنید دو بخش گراف $ X $ و $ Y $ باشند و ما می خواهیم به ازای بخش $ X $ مسئله را حل کنیم یال های گراف را جهت دهی می کنیم به این صورت که یال هایی که عضو $ M $ هستند را از $ Y $ به $ X $ و یال هایی که عضو $ M $ نیستد را از $ X $ به $ Y $ جهت دهی می کنیم. می توانید ببینید که یک هر مسیر متناوب با شروع از یک راس $ X $ در واقع معادل با مسیری در گراف جهت دهی شده ما است که باید از یکی از راس های آزاد $ X $ شروع شود.
</p><p>پس کافی است گراف را همانطور که گفتیم جهت دهی کنید و سپس از هر راس آزاد $ X $ الگوریتم dfs را اجرا کنید و بررسی کنید به کدام راس ها می رسیم. در نهایت تمامی راس های $ X $ که توانستیم به آن ها برسیم در یک مسیر متناوب قرار دارند. همانطور که گفتیم این موضوع به این معناست که به ازای هر کدام از آن راس ها تطابق ماکسیممی وجود دارد که آن راس در تطابق حاضر نباشد.
</p><p>مشابها می توانیم مسئله را برای بخش $ Y $ هم حل کنیم.
</p><h2>پیدا کردن یک مینیمم پوشش راسی در گراف دو بخشی</h2><p>در بخش 12.3 فهمیدیم که در گراف دوبخشی اندازه مینیمم پوشش راسی برابر است با اندازه ماکسیمم تطابق. در این قسمت یاد میگیریم چگونه با داشتن ماکسیمم تطابق، مینیمم پوشش راسی را پیدا کنیم.
</p><p>ابتدا یال های ماکسیمم تطابق را در نظر بگیرید و آن را $ M $ بنامید. از آنجایی که به ازای هر یال تطابق یکی از دو سر آن باید در پوشش راسی آمده باشد پس از هر یال دقیقا یکی از دو سر آن در مینیمم پوشش راسی آمده است (چرا؟). پس کافیست به ازای یال $ M $ تصمیم بگیریم که راسی که عضو بخش اول گراف است را در پوشش راسی بگذاریم یا راسی که در بخش دوم گراف است.
</p><p>دو بخش گراف را $ X $ و $ Y $ بنامید. مجموعه یال هایی از $ M $ که برای آن ها بخش $ X $ را انتخاب می کنیم $ MX $ بنامید و مجموعه یال هایی از $ M $ که برای آن ها بخش $ Y $ را انتخاب می کنیم $ MY $ بنامید. حالا می خواهیم $ MX, MY $ را مشخص کنیم.
</p><p>مشابه بخش قبل یال های گراف دوبخشی را جهت دهی می کنیم به اینصورت که یال های عضو $ M $ را از بخش $ Y $ به $ X $ و یال هایی که عضو $ M $ نیستند را از $ X $ به $ Y $ جهت دهی می کنیم. حالا از تمامی راس های بخش $ X $ که در تطابق حاضر نیستند dfs بزنید. تمام راس هایی که آن ها را می بینیم $ A $ و بقیه را $ B $ بنامیم. واضح است که بین $ X \cap A $ و $ Y \cap B $ یال نیست (در غیر اینصورت مجموعه $ A $ تغییر می کرد). پس می توان تمام راس هایی که در $ Y \cap A $ و $ X \cap B $ هستند را در پوشش راسی انتخاب کرد. از آنجایی که در هیچ یک از این دو مجموعه راس آزاد نداریم (به دلیل اینکه $ M $ ماکسیمم است پس مسیر افزایشی نداریم) می توان نتیجه گرفت حرفمان معادل این است که تمام یال هایی که در dfs دیده می شوند را $ MY $ قرار دهیم و باقی را $ MX $ قرار دهیم. یعنی $ MX = M - MY $.
</p><img src="/_static/min_cover_finding.jpg"><h1>جریان بیشینه و تطابق</h1><p>با مساله جریان بیشینه در فصل قبل آشنا شدیم. در این جا با یکی از کاربرد های دیگر این مساله که حل مساله تطابق و تعمیم های آن است آشنا می شویم.
</p><h2>حل مساله تطابق بیشینه در گراف دو بخشی</h2><p>این مساله را می توان به کمک مساله جریان بیشینه حل کرد. به این صورت که به گراف دوبخشی دو راس مبدا و مقصد اضافه کنید و راس مبدا را به همه رئوس بخش بالا با ظرفیت یک و رئوس بخش پایین را به راس مقصد با وزن ۱ یال بدهید. به ازای هر یال گراف نیز یک یال با وزن یک از راس بالا به پایین بکشید. ( مانند شکل )
</p><img src="/_static/flow_matching.svg"><p>در این گراف بزرگترین تطابق همان جریان بیشینه است.
</p><h2>تطابق بیشینه وزن دار</h2><p>در این مساله هر یال ارزشی دارد و ارزش یک تطابق برابر جمع ارزش یال های آن است. مسائل مختلفی را می توان برای تطابق وزن دار مطرح کرد. مانند تطابق با بیشترین ارزش، تطابق بیشینه با بیشترین ارزش یا تطابق با اندازه خاص و بیشترین ارزش. این مسائل را می توان به کمک تعمیمی از مساله جریان بیشینه که در زیر بررسی می کنیم حل کرد. خوب است که حین خواندن سعی کنید که خودتان به این مساله فکر کنید و قبل از رسیدن به بخش راه حل این سوال آن را حل کرده باشید.
</p><h2>جریان با کمترین هزینه</h2><p>در این مساله هدف پیدا کردن جریانی است که کمترین هزینه را داشته باشد. هزینه هر جریان برابر جمع جریان گذرنده از هر یال * هزینه آن یال به ازای تمام یال هاست. می خواهیم به ازای تمام مقادیر صحیح جریان ( از ۰ تا جریان بیشینه ) کمینه هزینه را به دست بیاوریم.
</p><h3>راه حل</h3><p>از روشی مشابه روش فورد فلکرسون که در فصل قبل آموختیم استفاده می‌کنیم. با این تفاوت که به جای انتخاب یک مسیر دلخواه، مسیری که کمترین هزینه را دارد را انتخاب می‌کنیم و سپس یک واحد جریان را از آن می گذرانیم. این کار را تا زمانی که دیگر نتوان جریانی گذراند ادامه می‌دهیم. در هر مرحله هزینه به دست آمده کمینه هزینه ممکن برای آن مقدار جریان است. طبق درستی الگوریتم فورد، این الگوریتم جواب را تا جریان بیشینه به دست می‌آورد.
</p><h3>اثبات بهینگی</h3><p>مانند اثبات درستی الگوریتم فورد، می‌توان ثابت کرد که در هر مرحله، اگر f مقدار جریان هدف و c هزینه آن باشد و کوتاه ترین مسیر از مبدا به مقصد x باشد، در گراف ساخته شده هم f-1 مقدار جریان هدف باشد، مینیمم هزینه ای که می توان با آن این مقدار جریان را عبور داد، c-x است.
</p><h3>تحلیل پیچیدگی</h3><p>برای به دست آوردن کوتاه ترین مسیر، می توان از الگوریتم spfa استفاده کرد ( چون یال منفی داریم نمی توان از الگوریتم دایسترا استفاده کرد. ) که پیچیدگی زمانی $ O(E) $ دارد. پس پیچیدگی زمانی کل از $ O(fE) $ است.
</p><h2>راه حل تطابق بیشینه وزن دار</h2><p>یک گراف مانند بالا می سازیم با این تفاوت که یال های مبدا و مقصد را با ظرفیت بینهایت قرار می‌دهیم و یال های وسط را با ظرفیت یک و هزینه اش را برابر وزن یال قرار می دهیم. سپس با الگوریتم جریان با کمترین هزینه می‌توان تمام مسائل بالا را پاسخ گفت.
</p><h1>Poset</h1><h2>تعریف</h2><p>به گراف جهت داری که دارای ویژگی زیر باشد Poset (Partially ordered set) می گوییم.
</p><ul><li><p>اگر $ ab $ و $ bc $ یال های این گراف باشد آنگاه $ ac $ هم یال این گراف است.
</p></li></ul><p>از آنجایی که بسیاری از مفاهیم ریاضی به poset تبدیل می شوند بررسی کردن آن ها مفید است.
</p><h3>اولین مسئله</h3><p>فرض کنید مجموعه ای از اعداد طبیعی مثل $ A $ داریم و می خواهیم بزرگترین زیرمجموعه ای از آن مثل $ B $ را پیدا کنیم که هر دو عضو $ B $ را که در نظر بگیریم یکی بر دیگری بخش پذیر است.
</p><p>می توانیم مسئله را به اینصورت به گراف مدل کنیم. به ازای هر عضو $ A $ یک راس در گراف قرار دهید و به ازای دو راس $ x,y $ که $ x|y $ است از $ x $ به $ y $ یال بگذارید. حالا مسئله معادل پیدا کردن بلندترین مسیر در این گراف است!
</p><h3>زنجیر و پادزنجیر</h3><p>به یک دنباله از راس های غیر تکراری مثل $ u_1,...,u_k $ که به ازای هر $ i<j $ ، $ u_i $ به $ u_j $ یال داشته باشد یک زنجیر می گوییم توجه کنید که به خاطر ویژگی poset کافیست که $ u_1, ... u_k $ یک مسیر باشد.
</p><p>به یک زیرمجموعه از راس ها که هیچ دوتایی به هم یال نداشته باشند یک پادزنجیر می گوییم.
</p><p>در ادامه افراز یک گراف به زنجیر ها یا پادزنجیر ها را بررسی خواهیم کرد (افراز راس های گراف مد نظر است).
</p><p>توجه کنید که از این تعاریف تنها در poset ها استفاده می شود.
</p><h2>ماکسیمم زنجیر = مینیمم افراز به پادزنجیر</h2><p>فرض کنید اندازه ماکسیمم زنجیر $ L $ باشد. و یک زنجیر ماکسیمم مثل $ A $ را در نظر بگیرید.
</p><p>هر پادزنجیر می تواند حداکثر یکی از راس های $ A $ را شامل شود. پس مینیمم افراز به پادزنجیر حداقل به اندازه $ L $ می باشد. حالا ثابت می کنیم حالتی از تساوی هم وجود دارد.
</p><p>به هر راس $ u $ عدد $ a_i $ را نسبت می دهیم که برابر است با اندازه بزرگترین زنجیری که $ u $ انتهای آن باشد. حالا می توانید ببینید که اگر $ a_i = a_j $ برقرار باشد امکان ندارد یالی بین $ i,j $ باشد زیرا به عنوان مثال اگر از $ i $ به $ j $ یال باشد آنگاه $ a_j \geq a_i+1 $ خواهد بود.
</p><p>به ازای هر راس $ u $ به $ a_u $ رنگ راس $ u $ می گوییم. طبق اثبات بالا راس هایی که رنگ برابر دارند یک پادزنجیر هستند. همچنین تعداد رنگ ها برابر است با $ L $ (چرا؟). پس توانستیم گراف را به $ L $ پادزنجیر افراز کنیم.
</p><p>قضیه یالا به قضیه میرسکی معروف است و در سال 1971 مطرح شد. جالب است بدانید این قضیه در سال 1940 توسط گالای دیلورث ، گالای،‌ فولکرسون و بسیاری دیگر شناخته شده بود و تنها دلیل آنها برای مطرح نکردن آن بدیهی فرض کردن این قضیه بود!
</p><h2>ماکسیمم پادزنجیر = مینیمم افراز به زنجیر</h2><p>مثل قبل می توان ابتدا به این نتیجه رسید که مینیمم افراز به زنجیر ها حداقل به اندازه ماکسیمم پادزنجیر است. (زیرا در هر زنجیر ماکسیمم یکی از راس های پادزنجیر را می توانیم استفاده کنیم). حالا می خواهیم برای اثبات تساوی یک مثال ارائه دهیم.
</p><p>در مورد مسئله افراز راس های گراف به مینیمم تعداد مسیر در بخش 4 صحبت کردیم. کافی بود که گراف را به فرم دوبخشی در بیاوریم و ماکسیمم تطابق را پیدا کنیم. حالا می دانیم که در poset ها هر زنجیر معادل با یک مسیر است. پس مسئله مینیمم افراز به زنجیر با پیدا کردن مینیمم افراز راس ها به مسیر ها حل می شود.
</p><h3>مسیر شبه افزایشی</h3><p>پس حالا فرض کنید poset ما یک گراف جهت دار به اسم $ P $ باشد. گراف دوبخشی معادل آن را $ G $ بنامید. یک مینیمم افراز به مسیر ها در $ P $ را در نظر بگیرید. یال های جهت داری که در مسیر هایمان وجود دارد را مجموعه $ M $ بنامید. می دانیم که یال های $ M $ معادل با یال های یک تطابق بیشینه در $ G $ می باشد. شرط لازم و کافی برای بیشینه بودن یک تطابق این بود که مسیر افزایشی نداشته باشیم. بررسی می کنیم که معادل یک مسیر افزایشی در گراف جهت دارمان به چه شکل خواهد بود. یک راس آزاد در بخش اول $ G $ معادل است با راسی در $ P $ که پایان یک مسیر است. یک راس آزاد در بخش دوم $ G $ معادل است با راسی که در $ P $ شروع یک مسیر است.
</p><p>پس می خواهیم معادل یک مسیر افزایشی که در $ G $ که از بخش اول شروع می شود و به بخش دوم می رود را در گراف $ P $ بفهمیم. <b>مسیر شبه افزایشی</b> در $ P $ را اینطور تعریف می کنیم :
</p><p>دنباله راس های $ u_1,u_2,...,u_{2k+1} $ به طوریکه $ u_1 $ ابتدای و $ u_{2k+1} $ انتهای یک مسیر انتخاب شده در افراز مینیمم باشد. همچنین به ازای $ u_{2i-1},u_{2i} $ در $ P $ یال $ u_{2i-1}u_{2i} $ موجود باشد و عضو $ M $ نباشد و به ازای $ u_{2i},u_{2i+1} $ یال $ u_{2i+1}u_{2i} $ در $ M $ آمده باشد! (به عوض شدن ترتیب دقت کنید).
</p><p>پس حالا می توان فرض کرد که راس های $ P $ را به کمینه تعداد مسیر ها افراز کردیم به طوریکه در $ P $ مسیر شبه افزایشی وجود ندارد.
</p><h3>الگوریتم</h3><p>حالا هدف ما این است که از هر کدام از زنجیر ها دقیقا یک راس را انتخاب کنیم به صورتیکه راس های انتخاب شده پادزنجیر باشند. در اینصورت می توانیم به حالت تساوی برسیم.
</p><p>الگوریتم زیر را در نظر بگیرید :
</p><ul><li><p>راس های اول مسیر را در نظر بگیرید. اگر بین آنها هیچ یالی نبود تنها کافیست آنها را انتخاب کنید.‌ اگر نه یعنی یالی مثل $ uv $ وجود دارد که $ u,v $ هر دو اول دو مسیر در افرازمان هستند.
</p></li><li><p>حالا باید راس $ u $ را حذف کنیم. زیرا که با توجه به اینکه $ u $ به $ v $ یال دارد و $ v $ اول یک مسیر است پس طبق خاصیت poset می توان نتیجه گرفت $ u $ به تمام راس های مسیر $ v $ یال دارد پس اگر $ u $ را در پادزنجیر انتخاب کنیم هیچکدام از راس های مسیری که $ v $ اول آن است را نمی توانیم انتخاب کنیم پس نمی توانیم به هدفمان که انتخاب یک راس از هر مسیر است برسیم. پس $ u $ را حذف کنید.
</p></li></ul><p>آنقدر این فرایند را ادامه دهید که بین راس های اول مسیر (بعد از حذف ها) هیچ یالی نباشد و یک پادزنجیر به اندازه تعداد مسیر ها بیابیم. تنها حالتی که کار ما را خراب می کند این است که یک مسیر به طور کامل حذف شود. (در این صورت پادزنجیر به اندازه تعداد مسیر های اولیه نخواهد بود).
</p><h3>هیچ مسیری کاملا حذف نمی شود</h3><p>پس ثابت می کنیم که هیچکدام از مسیر ها طی الگوریتم به طور کامل حذف نمی شوند. ایده اثبات این است که با برهان خلف فرض کنیم یک مسیر کامل حذف شده و سپس یک مسیر شبه افزایشی در گراف اولیه پیدا کنیم که با مینیمم بودن افرازمان در تناقض خواهد بود.
</p><p>به ازای هر راس $ a $ به راسی مثل $ b $ پدر راس $ a $ می گوییم اگر در الگوریتم $ a $ به خاطر یال $ ab $ حذف شده باشد. یعنی در مرحله ای از الگوریتم $ a,b $ هر دو اول دو مسیر باشند و یال $ ab $ عضو $ P $ باشد و طبق الگوریتم بالا ما راس $ a $ را حذف کنیم.
</p><p>به ازای هر راس $ a $ مسیری که $ a $ در آن است را در نظر بگیرید و راسی که در مسیر قبل از $ a $ است (مثل $ b $) را رئیس $ a $ بنامید. (یعنی $ ba $ یالی عضو $ M $ باشد).
</p><p>توجه کنید که به ازای هر راس $ a $ زمان حذف شدن $ a $ بعد از زمان حذف شدن رئیس پدر $ a $ است. زیرا زمانی که $ a $ حذف شده توسط پدرش باید اول یک مسیر باشد. این یعنی ریئس پدر (در صورت وجود) قبل از این حذف شده است.
</p><p>حالا فرض کنید در مرحله ای راس $ a $ حذف شود که انتهای یک مسیر از افرازمان است. از راس $ a $ شروع کنید و یک مهره روی $ a $ بگذارید. در هر مرحله اگر مهره روی $ u $ باشد ابتدا مهره را به پدر $ u $ ببرید اگر پدر $ u $ اول یکی از مسیر ها باشد که مسیر شبه افزایشیمان را پیدا کردیم در غیر اینصورت مهره را به رئیس پدر $ u $ ببرید. به دو مورد توجه کنید :
</p><ul><li><p>فرایند پایان پذیر است زیرا طبق آنچه گفتیم بعد از هر مرحله مهره روی راسی قرار می گیرد که زمان حذف شدن آن در الگوریتم کمتر است.
</p></li><li><p>در هر مرحله راسی که مهره روی آن قرار دارد پدر دارد. زیرا که در الگوریتممان این راس زمانی حذف می شود (زیرا که زمان حذف شدن آن از $ a $ کم تر است و گفتیم $ a $ هم حذف می شود).
</p></li></ul><p>پس توانستیم یک مسیر شبه افزایشی پیدا کنیم. همانطور که گفتیم تناقض حاصله نشان می دهد هیچ مسیری کاملا حذف نمی شود!
</p><h1>تطابق در گراف های عام</h1><p>در فصل های قبل شرط لازم و کافی برای وجود داشتن تطابق کامل در گراف های دوبخشی را بررسی کردیم. در این قسمت وجود تطابق کامل در هر گرافی را بررسی خواهیم کرد.
</p><h2>قضیه تات</h2><p>به ازای هر زیر مجموعه $ S $ از راس ها (که می تواند تهی نیز باشد) فرض کنید $ O(S) $ برابر با تعداد مولفه های همبندی با اندازه فرد باشد در صورتیکه رئوس $ S $ را از گراف حذف کرده باشیم.
</p><p>قضیه تات بیان می کند شرط زیر لازم و کافی می باشد :
</p><p>$ \forall_S : |S| \geq O(S) $
</p><p>شرط تات به وضوح برای وجود تطابق کامل لازم است. برای اثبات به ازای یک مجموعه $ S $ داشته باشیم $ |S| < O(S) $. در اینصورت برای وجود تطابق کامل باید از هر مولفه فرد که در $ O(S) $ شمردیم باید یک راس به راسی در $ S $ مطابق شده باشد. از آنجایی که گفتیم $ |S| < O(S) $ پس پیدا کردن تطابق کامل امکان پذیر نیست.
</p><p>برای اثبات کافی بودن شرط از اکسترمال استفاده می کنیم. یعنی با استفاده از برهان خلف فرض کنید گراف $ G $ تطابق کامل ندارد و شرط تات در آن صدق می کند. توجه کنید که با اضافه کردن یال به گراف $ G $ شرط تات برقرار می ماند‌ (چرا؟). پس ایده کلی ما به این صورت است که تا زمانی که در گرافمان تطابق کامل به وجود نیاید یک یال که در آن حضور ندارد را به آن اضافه خواهیم کرد. در نهایت به گراف ماکسیمال $ H $ می رسیم که :
</p><ul><li><p>شرط تات در آن صدق می کند.
</p></li><li><p>در آن تطابق کامل وجود ندارد.
</p></li><li><p>به ازای هر یال $ uv $ که در $ H $ نیست در صورتی که آن را به $ H $ اضافه کنیم تطابق کامل به وجود خواهد آمد.
</p></li></ul><p>حالا هدف ما این است که ثابت کنیم گراف $ H $ همین حالا هم تطابق کامل دارد (در اینصورت با فرض خلف به تناقض می خوریم و مسئله اثبات می شود).
</p><p>ابتدا توجه کنید که برقرار بودن شرط تات به ازای $ S = \phi $ به ما نتیجه می دهد که $ H $ دارای هیچ مولفه همبندی با فرد راس نیست در نتیجه تعداد راس های گراف زوج است.
</p><ul><li><p><b>گلابی</b> : راس های $ a,b,c,d $ به طوریکه $ ab,ac $ یال‌های گراف باشند ولی $ bc,ad $ یال‌های گراف نباشند.
</p></li><li><p><b>سیب</b> : راس های $ a,b,c $ به طوریکه $ ab,ac $ یال‌های گراف باشند ولی $ bc $ یال‌ گراف نباشد.
</p></li></ul><img src="/_static/sib_golabi.png"><p>ادعا می کنیم اگر بتوانیم در $ H $ یک گلابی پیدا کنیم می توانیم ثابت کنیم در $ H $ تطابق کامل وجود دارد. پس یک گلابی دلخواه را در نظر بگیرید و راس های آن را $ a,b,c,d $ مطابق تعریف در نظر بگیرید. 
</p><p>اگر به $ H $ یال $ ad $ را اضافه کنید در آن تطابق $ M1 $ وجود خواهد داشت که شامل $ ad $ است.
</p><p>اگر به $ H $ یال $ bc $ را اضافه کنید در آن تطابق $ M2 $ وجود خواهد داشت که شامل $ bc $ است.
</p><p>حالا $ M = M1 \Delta M2 $ را در نظر بگیرید. طبق مطالب گفته شده در قسمت های قبل یال های $ M $ به صورت تعدادی دور می باشد.
</p><h3>اگر یال :math:`ad` و :math:`bc` در دو دور متفاوت باشند‌</h3><p>آنگاه از دوری که $ ad $ درون آن است یال های $ M2 $ و از دوری که $ bc $ درون آن است یال های $ M1 $ را انتخاب کنید (از بقیه دور ها به صورت دلخواه یال های $ M1 $ یا $ M2 $ را انتخاب کنید و یال هایی که در $ M1 \cap M2 $ هستند را نیز انتخاب کنید). در اینصورت در $ H $ یک تطابق کامل خواهیم داشت!
</p><h3>اگر یال :math:`ad` و :math:`bc` در یک دور باشند</h3><p>در ابتدا باید بگوییم که این دور زوج است. حالا چون $ b,c $ یکی از یال های دور است $ b,c $ دو راس متوالی در دور هستند پس در صورتیکه به ازای دقیقا یکی از یال های $ ab $ یا $ ac $ اتفاق زیر می افتد :
</p><p>اگر راس های دو سر یال را از گراف حذف کنیم دور ما تبدیل به دو مسیر زوج راسی خواهد شد.
</p><p>بدون کم شدن از کلیت مسئله فرض کنید این یال $ ab $ باشد. حالا یال $ ab $ را برای تطابق انتخاب کنید. و سپس $ a,b $ را از گراف حذف کنید و یال های دو مسیر زوج راسی به وجود آمده را یکی در میان برای تطابق انتخاب کنید. در اینصورت تمام راس های دور ما توسط یال های انتخاب شده پوشش داده می شوند. مشابه بالا از بقیه دور ها به صورت دلخواه یال های $ M1 $ یا $ M2 $ را انتخاب کنید و یال هایی که در $ M1 \cap M2 $ هستند را نیز انتخاب کنید. در اینصورت در $ H $ یک تطابق کامل خواهیم داشت!
</p><h3>اگر گلابی نداشتیم چه؟</h3><p>در دو قسمت بالا ثابت کردیم اگر در گراف $ H $ گلابی داشتیم آنگاه $ H $ دارای یک تطابق کامل است. حالا باید حالاتی که در $ H $ گلابی وجود ندارد را هم در نظر بگیریم.
</p><p>مجموعه $ C $ را شامل تمام راس های $ H $ در نظر بگیرید که به همه راس های دیگر یال دارند (درجه آن ها $ n-1 $ است).
</p><p>حالا اگر $ C $ تمام راس های $ H $ را شامل شود به این معنی است که $ H $ یک خوشه‌ (و دارای زوج راس) است.پس به وضوح در آن تطابق کامل وجود دارد.
</p><p>پس گراف $ W = H-C $ را در نظر بگیرید. در $ W $ به ازای هر راس مثل $ u $ راسی مثل $ v $ وجود دارد که بین $ uv $ یالی نیست (چرا؟). پس اگر بتوانیم در $ W $ یک سیب پیدا کنیم آنگاه می توانیم یک گلابی هم پیدا کنیم(زیرا تنها کافیست به ازای راس $ a $ در سیب راس $ d $ را طوری بیابیم که بین $ a,d $ یال نباشد).
</p><p>پس اگر در $ W $ سیب وجود داشته باشد مسئله حل می شود. پس فرض کنید در $ W $ سیب وجود ندارد. در اینصورت به ازای هر $ a,b,c $ دلخواه که $ ab,ac $ یال گراف هستند، $ bc $ هم باید یال این گراف باشد. یک راس دلخواه مثل $ u $ را در نظر بگیرید و مجموعه خود $ u $ و راس های مجاور آن را $ A $ در نظر بگیرید. بین هر دو راس در $ A $ باید یال باشد(چرا؟) همچنین هیچ راسی خارج از $ A $ نیست که به $ A $ یال داشته باشد(چرا؟). پس می توان نتیجه گرفت که هر مولفه همبندی در $ W $ یک خوشه است. در هر خوشه راس ها را به صورت دلخواه تطابق دهید. از هر خوشه فرد دقیقا یک راس اضافه می ماند. از آنجایی که به ازای $ S = C $ شرط تات برقرار است پس می توان تمام راس های اضافه مانده در $ W $ را به راس های $ C $ تطابق داد. در نهایت کل راس های اضافه مانده در $ C $ را (که یک خوشه زوج راسی هستند) را به صورت دلخواه تطابق می دهیم. پس در نهایت یک تطابق کامل در $ H $ پیدا کردیم.
</p><h2>حالت کلی تر تطابق یا k-factor</h2><p>طبق تعریف یک تطابق کامل در گراف $ G $ به معنی یک زیرمجموعه از یال های گراف مثل $ M $ است که در $ M $ درجه هر راس دقیقا 1 باشد.
</p><p>حالا می خواهیم این تعریف را تعمیم دهیم. فرض کنید $ a_1,a_2,...,a_n $ داده شده است و ما باید بفهمیم آیا یک زیرمجموعه از یال های گراف مثل $ M $ وجود دارد که در آن درجه هر راس $ u $ برابر با $ a_u $ شود؟
</p><p>در نگاه اول این مسئله بسیار کلی تر و سخت تر از تطابق است ولی در این بخش می خواهیم آن را با استفاده از تطابق حل کنیم.
</p><h3>یک ایده اشتباه</h3><p>احتمالا اولین ایده ای که به ذهن می رسد این است که راس $ u $ را دقیقا $ a_u $ بار کپی کنیم سپس به ازای هر یال $ uv $ در $ G $ بین تمام کپی های $ u,v $ یال قرار دهیم. سپس بررسی کنیم که در گراف جدید تطابق کامل وجود دارد یا خیر. 
</p><p>این ایده بسیار شبیه به آن چیزی است که قبلا در فصل تطابق دوبخشی بررسی کردیم اما یک اشتباه بسیار ریز دارد. مشکل این است که ممکن است همزمان از چند تا از یال های بین $ u,v $ در تطابق استفاده کنیم و این 
باعث می شود که از یک یال چند بار استفاده کنیم که مطلوب مسئله نیست.
</p><h3>حل درست</h3><p>فرض کنید $ d_u $ درجه راس $ u $ باشد. از گراف $ G $ گراف $ G^{\prime} $ را به اینصورت می سازیم :
</p><p>به ازای هر راس $ u $ یک گراف دوبخشی کامل قرار می دهیم! به صورتی که بخش اول آن دارای $ d_u - a_u $ راس قرار داشته باشد و در بخش دوم آن $ d_u $ راس قرار داشته باشد. به گراف دوبخشی متناظر با راس $ u $ ، $ B_u $ گوییم. سپس یال های گراف $ G $ را به ترتیبی دلخواه در نظر بگیرید و متناظر آن را (به صورتی که خواهیم گفت) به گراف $ G^{\prime} $ اضافه کنید. فرض کنید $ i $ امین یالی که بررسی می کنیم $ uv $ باشد و قبل از آن $ c1 $ تا از یال های مجاور $ u $ و $ c2 $ تا از یال های مجاور $ v $ را بررسی کرده ایم. حالا متناظر یال $ uv $ برابر خواهد بود با یالی که بین دو راس زیر است :
</p><ul><li><p>راس $ c1 $ ام <b>بخش دوم</b> گراف $ B_u $
</p></li><li><p>راس $ c2 $ ام <b>بخش دوم</b> گراف $ B_v $
</p></li></ul><p>حالا ادعا می کنیم وجود داشتن زیرمجموعه $ M $ از یال ها که شرط مسئله را برآورده کند معادل است با وجود داشتن یک تطابق کامل در گراف $ G^{\prime} $!
</p><p>توجه کنید که در این گراف هر یال در گراف اصلی دقیقا یک یال متناظر دارد پس مشکل قبل (چند بار استفاده کردن از یک یال) پیش نمی آید. اثبات کامل درستی قضیه بالا به عهده خواننده واگذار می شود.
</p><img src="/_static/k_factor.png"><h1>گراف مسطح</h1><p>گراف مسطح گرافی است که می توان آن را روی صفحه رسم کرد بدون آن که یال هایش از روی هم دیگر
بگذرند. گراف های زیر مسطح هستند:
</p><img src="/_static/mosatah.png"><p>گرافی که نتوان روی صفحه به این صورت رسم کرد، گراف غیر مسطح است. برای مثال گراف کامل
پنج راسی غیر مسطح است. ( امتحان کنید :) )
</p><h2>رسم گراف مسطح روی کره</h2><p>یک گراف را می توان روی کره رسم کرد به صورتی
که یال های آن یکدیگر را قطع نکنند اگر و تنها اگر مسطح باشد. برای اثبات از تبدیل زیر
استفاده می کنیم.
</p><img src="/_static/mosatah_kore.jpg"><p>یک کره را روی صفحه قرار دهید و قطب مخالف نقطه مماس به صفحه را در نظر بگیرید.
(نقطه N)
هر خطی که شامل این نقطه باشد دقیقا یک نقطه از صفحه و یک نقطه از کره را می پوشاند. حال
برای اثبات قضیه یک گراف مسطح را روی صفحه در نظر بگیرید و آن را روی کره رسم کنید. به
این صورت که به ازای هر نقطه از صفحه خط
از N به آن را رسم کنید و نقطه معادل
آن در کره را به دست آورید. حال اگر آن نقطه از صفحه یک راس بود، روی کره راس، اگر یال بود
نقطه ای از یال و اگر ناحیه بود نقطه ای از ناحیه روی آن بگذارید. به این صورت یک رسم از
گراف روی کره به دست می آید. می توان دید که یال ها بیوستگی خود را از دست نمی دهند و بدیهیست
که یکدیگر را قطع نمی کنند.
</p><p>برای سمت دیگر قضیه نیز به طور مشابه عمل می کنیم. اما دقت می کنیم که نقطه
N
روی راس یا یال نباشد. ناحیه ای که آن نقطه روی آن است تبدیل به ناحیه نامتناهی که
گراف را احاطه کرده می شود.
</p><h2>قضیه اویلر</h2><p>قضیه اویلر رابطه ای برای به دست آوردن تعداد ناحیه های تشکیل شده در یک گراف مسطح است. این
قضیه بیان می کند که: 
</p>$$ f = e + t + 1 - n $$<p>که در آن f تعداد ناحیه ها، e تعداد یال ها، t تعداد مولفه ها و n تعداد رئوس است.
به طور خاص در گراف همبند، داریم:
</p>$$ f = e + 2 - n $$<h3>اثبات</h3><p>اثبات این قضیه اصلا پیچیده نیست، بنابراین خوب است که ابتدا خودتان به آن فکر کنید.
اگر گراف یک جنگل باشد، حکم برقرار است چون یک ناحیه وجود دارد و داریم
$ e = n - t $
اما اگر جنگل نباشد، یکی از یال هایی که درون دور آمده و غیر برشی است را از گراف حذف
می کنیم. تعداد رئوس و مولفه ها ثابت می ماند اما تعداد نواحی و تعداد یال ها دقیقا یک
واحد کم می شود. پس اگر حکم در گراف جدید درست باشد، در گراف قبلی نیز درست بوده است. آن
قدر این کار را ادامه می دهیم تا به یک جنگل برسیم. چون در جنگل حکم برقرار است، در تمام
گراف های این بین از جمله گراف ابتدایی نیز برقرار بوده است.
</p><h2>گراف دوگان</h2><p>گراف دوگان یک گراف مسطح، گرافی است که به این صورت به دست می آید: در هر ناحیه یک راس قرار
دهید، سپس بین راس های متناظر با ناحیه های مجاور یال قرار دهید. مانند شکل زیر:
</p><img src="/_static/mosatah_dogan.svg"><p>توجه کنید که گراف دوگان نیز مسطح است. گراف دوگان
در حل مسائل مربوط به گراف مسطح می تواند مفید باشد.
</p><h2>گراف اشباع</h2><p>گراف اشباع یک گراف مسطح ساده است که نمی توان به آن یال اضافه کرد و باز هم مسطح ساده
بماند. یک گراف که بیش از دو راس دارد
اشباع است اگر و تنها اگر هر ناحیه سه ضلع داشته باشد یا به عبارت دیگر
گراف دوگان آن سه منتظم باشد. در یک گراف اشباع داریم:
</p>$$ 3f = 2e $$<p>که اگر آن را درون رابطه اویلر قرار دهیم ( گراف اشباع به وضوح همبند است ) به دست می آید:
</p>$$ \frac{2e}{3} = e - n + 2 $$$$ \frac{e}{3} = n - 2 $$$$ e = 3n - 6 $$<p>که ثابت می کند که در هر گراف ساده مسطح
</p>$$ e \le 3n - 6 $$$$ e = O(n) $$<h1>دنباله درجه ای</h1><p>گرافی
$ n $
راسی مانند
$ G $
را در نظر بگیرید.
</p><p>فرض کنید درجه راس
$ i $
را به صورت 
$ d_{i} $
نشان دهیم. آنگاه به دنباله
$ d_{1}, d_{2}, ..., d_{n} $
دنباله درجه‌ای گراف
$ G $
می‌گوییم.
</p><h2>دنباله گرافیک</h2><p>به دنباله‌ی
$ d_{1}, d_{2}, ..., d_{n} $
یک دنباله گرافیک گوییم، اگر گرافی ساده
$ n $
راسی مانند
$ G $
وجود داشته باشد، که دنباله درجه راس های آن،‌ برابر با دنباله فوق باشد.
</p><h2>الگوریتم هاول حکیمی</h2><p>این الگوریتم برای تشخیص دنباله های گرافیک به کار می رود. این الگوریتم یک الگوریتم
حریصانه است و هر بار، راس بزرگترین درجه را به راس های با درجه های بزرگ بعدی وصل
می کند و اگر در یک مرحله، مجبور شدیم به یک راس درجه صفر یال وصل کنیم، یعنی دنباله
ما گرافیک نیست. درستی این الگوریتم حریصانه معادل این قضیه است که یک دنباله مرتب شده
$ d_{1}, d_{2}, ..., d_{n} $
که در آن
$ d_{1} \ge d_{2} \ge ... \ge d_{n} $
گرافیک است اگر و تنها اگر
$ d_{2} - 1 , d_{3} -1 , ... d_{d_1+1} -1, d_{d_1+2}, ... , d_{n} $
گرافیک باشد.
</p><h3>جابه جایی دوتایی</h3><p>در راستای اثبات قضیه هاول حکیمی، تعریف می‌کنیم عملیات جابه‌جایی دوتایی را بین 4 راس
$ a, b, c, d $
به این‌صورت که فرض کنید بین
$ a, b $
و
$ c, d $
یال باشد و بین
$ a, c $
و
$ b, c $
یالی نباشد.
</p><p>در این‌صورت، یال های
$ a, b $
و
$ c, d $
را از گراف حذف می‌کنیم و یال های
$ a, c $
و
$ b, c $
را اضافه می‌کنیم. برای درک بهتر، به شکل زیر توجه کنید.
</p><img src="/_static/2-switch.png"><p>نکته مهم این تبدیل این است که با اجرای آن، دنباله درجه ای گراف بدون تغییر باقی
می ماند.
</p><h3>اثبات قضیه</h3><p>یک سمت این قضیه، بدیهی است چون اگر دنباله
$ d_{2} - 1 , d_{3} -1 , ... d_{d_1+1} -1, d_{d_1+2}, ... , d_{n} $
گرافیک باشد با در نظر گرفتن گراف متناظر آن و اضافه کردن یک راس، می توان
نشان داد که دنباله اصلی نیز گرافیک بوده است.
</p><p>حال سمت دیگر را اثبات می کنیم. طبق فرض دنباله اصلی گرافیک است و ما باید
ثابت کنیم که دنباله
$ d_{2} - 1 , d_{3} -1 , ... d_{d_1+1} -1, d_{d_1+2}, ... , d_{n} $
نیز گرافیک است. بین تمام گراف هایی که دنباله درجه ای برابر با دنباله ما
دارند، آن را در نظر بگیرید که راس شماره یک به بیشترین تعداد راس از
$ v_{2} , v_{3} , ... v_{d_1+1} $
که از این به بعد آن ها را رئوس خوب و بقیه را رئوس بد می نامیم 
وصل باشد. اگر راس شماره یک به تمامی رئوس خوب وصل باشد، با حذف آن گراف مورد
نظر ساخته می شود و حکم برقرار است. در غیر این صورت، یکی از رئوس خوب که به راس
یک متصل نیست را در نظر بگیرید و یک راس بد که به راس یک متصل هست را نیز در نظر
بگیرید. اگر راس خوب همسایه ای داشته باشد که مجاور راس بد نباشد، می توان روی این
چهار راس یک عملیات جابه جایی دوتایی اجرا کرد و به این ترتیب تعداد رئوس خوب مجاور
راس یک یک واحد زیاد می شود که با فرض اکسترمال در تناقض است. در غیر این صورت، تمام
مجاور های راس خوب مجاور راس بد نیز هستند و علاوه بر آن راس بد مجاور راس شماره یک
نیز هست. پس درجه راس بد از راس خوب اکیدا بیشتر است که با فرض مرتب شده بودن درجات
در تناقض است. بنابراین حکم ثابت شد و یعنی دنباله خواسته شده درجه ای است.
</p><h1>رنگ آمیزی</h1><h2>رنگ آمیزی راسی</h2><p>در رنگ آمیزی راسی، به هر راس یک رنگ تعلق می گیرد به طوری که دو راس مجاور دو رنگ مختلف داشته باشند.
</p><h3>K رنگ پذیر</h3><p>اگر بتوانیم با حداکثر k رنگ راس های گرافی را رنگ کنیم به آن گراف k رنگ پذیر می گوییم.
</p><h3>K رنگ آمیزی مناسب</h3><p>اگر در رنگ آمیزی راس ها از k رنگ استفاده کنیم (به ازای هر رنگ z، راسی وجود داشته باشد که در رنگ آمیزی به رنگ z باشد)، به رنگ آمیزی انجام شده، k رنگ آمیزی مناسب می گوییم.
</p><h3>عدد رنگی</h3><p>به گرافی k رنگ پذیر باشد ولی k - 1 رنگ پذیر نباشد، k رنگی گفته می شود.
به k، عدد رنگی گراف گفته می شود که آن را به صورت χ(G) = k نشان می دهند.
در واقع عدد رنگی یک گراف کمترین تعداد رنگ مورد نیاز برای رنگ کردن راس های گراف را نشان می دهد.
</p><h2>رنگ آمیزی یالی</h2><p>اگر بتوان یال های یک گراف را با k رنگ رنگ آمیزی کرد گوییم آن گراف k رنگ پذیر یالی است.
</p><h3>عدد رنگی یالی</h3><p>اگر گرافی k رنگ پذیر یالی باشد ولی k - 1 رنگ پذیر یالی نباشد گوییم این گراف k رنگی یالی است.
در اینجا k عدد رنگی یالی گراف محسوب می شود و آن را به صورت χ′(G) = k نشان می دهیم.
</p><h2>اطلاعاتی درباره رنگ آمیزی</h2><p>نقشه ها را جوری رنگ آمیزی می کنند تا دو کشور همسایه رنگ یکسان نداشته باشند.
اما سوال اینجا بود که کمترین تعداد رنگ مورد نیاز برای رنگ کردن چقدر است و فرانسیس گاثری اولین کسی بود که احتمال داد هر نقشه با ۴ رنگ قابل رنگ آمیزی است و در سال ۱۹۷۶ احتمال گاثری به کمک کامپیوتر اثبات شد و به قضیه تبدیل شد.
</p><h1>یک ریختی</h1><h2>گراف های یکسان</h2><p>گراف G و H را در نظر بگیرید.
اگر V(G) = V(H) و E(G) = E(H) باشد گوییم گراف های G و H یکسان هستند.
</p><h2>یک ریختی</h2><p>گراف G و H را در نظر بگیرید.
تابع یک به یک و پوشا f(u) را تعریف کنیم راس تناظر داده شده در گراف H از راس u در گراف G و با این شرط که f(u) و f(v) با هم برابرند تنها در صورتی که u برابر با v باشد.
اگر بتوان یک تابع f بین راس های G و H ایجاد کرد که با قراردادن f هر راس u در گراف G جای خود راس u این دو گراف یکسان شود، گوییم این دو گراف یک ریخت هستند.
به عبارت دیگه یال uv در G وجود دارد اگر و تنها اگر یال f(u)f(v) هم در H وجود داشته باشد؛ در این صورت دو گراف یک ریخت هستند.
</p><h2>خود ریختی</h2><p>تعریف ساده خود ریختی،یک ریختی گراف به خودش است.
یعنی با جایگشت دادن راس های گراف مجموعه یال ها تغییر نکند.
</p><h1>Random Walk</h1><p>تصور کنید که در یک هزارتو گیر افتاده اید. همه جا تاریک است و شما به هر تقاطعی که می رسید به صورت تصادفی یکی از مسیر ها را در پیش می گیرید. همچنین هیچگونه اطلاعاتی از مسیر ها و تقاطع ها به خاطر نمی سپارید. احتمال اینکه در نهایت بتوانید از هزار تو خارج شوید چقدر است؟ امیدریاضی زمانی که طول می کشد که از هزار تو خارج شوید چقدر است؟
</p><p>مسئله کلی random walk به این شکل است که یک گراف جهت دار داده شده است. روی یال های مجاور هر راس یک توزیع احتمالاتی داریم. یعنی روی هر راس مثل $ v $ که باشیم به ازای هر کدام از مجاور های $ v $ مثل $ u $ احتمال $ p_{vu} $ را احتمال طی کردن این یال تعریف می کنیم. همچنین جمع احتمال تمام یال های مجاور $ v $ باید برابر با 1 باشد. حالا می توانیم تصور کنیم که فردی روی راس $ s $ ایستاده است و هر مرحله به صورت تصادفی و طبق توزیع احتمالاتی راسی که روی آن ایستاده است جا به جا می شود. فضای کلی مسئله به این شکل است. حالا می توان سوال های مختلفی در این فضا پرسید. دو تا از مهم ترین سوال ها که در این بخش آنها را بررسی می کنیم این است که احتمال و امیدریاضی تعداد حرکات رسیدن فرد به راس $ t $ چقدر است؟
</p><h2>تبدیل مسائل به Random Walk</h2><p>اگر به مسائل احتمالات توجه کنید خیلی از آنها به Random Walk تبدیل می شوند. به این صورت که به ازای هر وضعیت ممکن (با بررسی مثال های پایین دقیق تر متوجه می شوید) یک راس در نظر می گیریم. عملیات هایی که انجام می دهیم هم در واقع یال هایی هستند که به صورت احتمالاتی وضعیت ما را عوض می کنند (ما را از یک راس به راس دیگر می برند).
</p><p>چند مثال را بررسی می کنیم.
</p><h3>موش و پنیر</h3><p>یک محور اعداد صحیح داریم. موشی  نابینا روی نقطه $ s $ است و به دنبال یک پنیر می گردد که روی نقطه $ t $ است. موش در هر مرحله به احتمال $ p $ به جلو می رود و به احتمال $ 1-p $ به عقب می رود. امیدریاضی مراحلی که طول می کشد تا موش به پنیر برسد چند است؟
</p><h3>تبدیل</h3><p>برای تبدیل این مسئله به random walk کافی است گرافی با نامتناهی راس در نظر بگیریم. که راس $ x $ نشان دهنده نقطه $ x $ در محور اعداد است. هر راس $ x $ به $ x+1 $ یال دارد که روی آن احتمال $ p $ نوشته شده است همچنین به $ x-1 $ یال دارد که روی آن احتمال $ 1-p $ نوشته شده است. حالا مسئله معادل با امیدریاضی یال های طی شده برای رسیدن از $ s $ به $ t $ است.
</p><p>توجه کنید که صرفا توانستیم این مسئله را به random walk تبدیل کنیم ولی هنوز آن را حل نکرده ایم!
</p><h3>بمب</h3><p>یک تروریست داریم که دکمه ای در دست دارد. بعد از گذشت هر ساعت تروریست دکمه را فشار می دهد. بعد از فشار دادن دکمه بمب به احتمال $ p $ منفجر می شود و به احتمال $ 1-p $ هیچ اتفاقی نمی افتد. این روند انقدر ادامه پیدا می کند که بالاخره بمب منفجر بشود (یا این روند تا بی نهایت به طول می انجامد). امیدریاضی زمانی که طول می کشد تا بمب منفجر شود را بیابید.
</p><h3>تبدیل</h3><p>تبدیل این مسئله به random walk در نگاه اول واضح نیست. اما همانطور که گفتیم، اکثر مسائل احتمالاتی را می توان به random walk تبدیل کرد (اما لزومی ندارد که گراف کوچک باشد و حل مسئله اصلی از طریق حل مسئله random walk ساده تر باشد). 
</p><p>در اینجا وضعیت های ما منفجر شدن و یا نشدن بمب است پس کافیست دو راس $ A $ و $ B $ در نظر بگیریم که $ A $ یعنی در وضعیتی هستیم که بمب منفجر نشده است. حالا بعد از گذشت هر ساعت (هر عملیات) به احتمال $ p $ بمب منفجر می شود. پس راس $ A $ یالی به $ B $ دارد که روی آن احتمال $ p $ نوشته شده است. همچنین به احتمال $ 1-p $ بمب منفجر نمی شود که به وضعیت قبل خود بر می گردیم پس راس $ A $ یک یال به خودش دارد که روی آن احتمال $ 1-p $ نوشته شده است. 
</p><p>در نهایت مسئله ما تبدیل به امیدریاضی تعداد یال های مورد نیاز برای رسیدن از $ A $ به $ B $ شد. گراف مورد بحث هم دارای دو راس و دو یال می باشد!
</p><h3>سه دزد بز دزد</h3><p>در این مسئله سه دزد بز دزد داریم که آن ها را اولی، دومی و سومی می نامیم. سه دزد با هم مشغول بازی کردن هستند. هر مرحله از بازی به این صورت است :
</p><ul><li><p>به صورت تصادفی آن ها از بین خودشان یکی را انتخاب می کنند. در هر گام به احتمال  $ \frac 1 2 $ اولی، به احتمال $ \frac 1 3 $ دومی و به احتمال $ \frac 1 6 $ سومی انتخاب می شود. فرض کنید دزدی که در اینجا انتخاب شده را آقای $ D $ بنامیم.
</p></li><li><p>آقای $ D $ به مزرعه می رود و یک بز می دزد. بز دزدیده شده به دارایی های آقای $ D $ اضافه می شود.
</p></li><li><p>در اینجا اگر بز های آقای $ D $ از یکی از دوستانش حداقل 2 تا بیشتر باشد، آقای آقای $ D $ سلطان دزد ها می شود و بازی تمام می شود. در غیر اینصورت دوباره یک نفر دیگر از بین خودشان انتخاب می کنند و این روند ادامه پیدا می کند.
</p></li></ul><p>پس به صورت کلی دزد ها آنقدر این روند را انجام می دهند که دزدی که بیشترین دارایی را دارد از دزدی که کمترین دارایی را دارد حداقل دو بز بیشتر داشته باشد...
</p><p>حالا شما باید احتمال اینکه اولی سلطان دزد ها بشود را حساب کنید!
</p><h3>تبدیل</h3><p>لیستی از وضعیت های مختلف بازی به این شکل است.
</p><ul><li><p>همه تعداد بز های برابر داشته باشند. راس $ s $
</p></li><li><p>تعداد بز های اولی یکی بیشتر از بقیه باشد. راس $ A_1 $
</p></li><li><p>تعداد بز های دومی یکی بیشتر از بقیه باشد. راس $ B_1 $
</p></li><li><p>تعداد بز های سومی یکی بیشتر از بقیه باشد. راس $ C_1 $
</p></li><li><p>تعداد بز های اولی یکی کمتر از بقیه باشد. راس $ A_{-1} $
</p></li><li><p>تعداد بز های دومی یکی کمتر از بقیه باشد. راس $ B_{-1} $
</p></li><li><p>تعداد بز های سومی یکی کمتر از بقیه باشد. راس $ C_{-1} $
</p></li><li><p>اولی سلطان باشد. راس $ A_2 $
</p></li><li><p>دومی سلطان باشد. راس $ B_2 $
</p></li><li><p>سومی سلطان باشد. راس $ C_3 $
</p></li></ul><p>هر کدام از راس ها (به جز سه تای آخر)، دقیقا سه یال خروجی دارند که هر کدام بستگی به این دارد که کدام یک از دزد ها برای دزدیدن انتخاب شوند. به عنوان مثال مجاور های راس $ A_{-1} $ به این صورت هستند :
</p><ul><li><p>اگر اولی انتخاب شود به راس $ s $ می رویم که احتمال $ \frac 1 2 $ دارد.
</p></li><li><p>اگر دومی انتخاب شود به راس $ B_2 $ می رویم که احتمال $ \frac 1 3 $ دارد.
</p></li><li><p>اگر سومی انتخاب شود به راس $ C_2 $ می رویم که احتمال $ \frac 1 6 $ دارد.
</p></li></ul><p>در نهایت مسئله معادل با احتمال رسیدن از راس $ s $ به راس $ A_2 $ می باشد.
</p><h2>حل مسئله Random Walk</h2><p>در قسمت قبل دیدم که بسیاری از مسائل احتمال را می توان با Random Walk مدل سازی کرد. اما اگر این مدل سازی ما را به حل مسئله اصلی نزدیک تر نکند برای ما سودی نخواهد داشت! در این قسمت می بینیم که می توان مسئله احتمال و امیدریاضی رسیدن از $ s $ به $ t $ در  Random Walk را به صورت الگوریتمی و با استفاده از دستگاه چند معادله و چند مجهول حل کرد!
</p><p>فرض کنید احتمال رفتن از راس $ A $ به راس $ B $ برابر با $ P_{AB} $ باشد. در صورتیکه در گراف از $ A $ به $ B $ یالی نباشد، $ P_{AB}=0 $ در نظر بگیرید. همچنین لزوما $ P_{AB} $ با $ P_{BA} $ مساوی نیست (چون گراف جهت دار است).
</p><p>در این قسمت فرض می کنیم که راس $ t $ به ما داده شده است و ما می خواهیم به ازای تمام راس ها مثل $ u $ احتمال و امیدریاضی رسیدن از $ u $ به $ t $ را بیابیم.
</p><p>احتمال رسیدن از $ u $ به $ t $ را $ ansP_u $ می نامیم و امیدریاضی تعداد یال های طی شده برای رسیدن از $ u $ به $ t $ را $ ansE_u $ می نامیم. 
</p><p>واضح است که $ ansP_t = 1 $ و $ ansE_t = 0 $.
</p><p>معادلات زیر به ازای هر $ u \neq t $ برقرار هستند.
</p><p>$ ansP_u = \sum P_{uv} \times ansP_v $
</p><p>$ ansE_u = 1 + \sum P_{uv} \times ansE_v $
</p><p>که اگر $ n $ راس داشته باشیم این معادلات به ما یک دستگاه $ n-1 $ معادله و $ n-1 $ مجهول می دهند. همچنین به طور خاص اگر گراف جهت دار ما DAG باشد دیگر نیازی به حل دستگاه معادلات نیست. بلکه گراف را به صورت ترتیب توپولوژیکی در نظر می گیریم و از آخر به اول جواب ها را به دست می آوریم (و این بسیار شبیه به کاری است که در توابع بازگشتی انجام می دهیم).
</p><h3>حل یک مثال </h3><p>در اینجا می خواهیم مسئله بمب که در بالا گفته شد را حل کنیم. اگر دستگاه معادلات را شکل بدهیم نتیجه به این شکل است :
</p><p>$ ansE_B = 0 $
</p><p>$ ansE_A = 1 + (1-p) \times ansE_A + p \times ansE_B $
</p><p>که به راحتی نتیجه می شود $ ansE_A = \frac 1 p $
</p><h2>نتیجه گیری</h2><p>در اینجا وارد فضای Random Walk شدیم و در مورد بعضی از مسائلی که در این فضا تعریف می شوند کمی صحبت کردیم اما حقیقت این است که انواع پرسش هایی که در فضای Random Walk مطرح می شوند بسیار زیاد است و بحث در این مورد از حوصله کتاب خارج است.
</p><p>روشی که برای تبدیل به Random Walk و سپس حل آن گفتیم بسیار کلی است. این کار برای شهود گرفتن ما نسبت به مسائل خوب است اما در خیلی از اوقات گرافی که ساخته می شود بسیار بزرگ تر از آن است که بتوان به صورت دستی معادلات مربوط به آن را حل کرد (مثل مسئله سه دزد بز دزد).
</p><p>گاهی اوقات می توانیم از خاص بودن گراف استفاده کنیم. مثلا فرض کنید می خواهیم امیدریاضی رسیدن از راس $ s $ به $ t $ را بیابیم و ساختار گراف طوری است که هر مسیر از $ s $ به $ t $ حتما از راس $ w $ می گذرد. در اینجا طبق قوانین امیدریاضی می توانیم بفهمیم که امیدریاضی تعداد یال ها برای رسیدن از $ s $ به $ t $ برابر است با جمع امیدریاضی رسیدن از $ s $ به $ w $ و سپس رسیدن از $ w $ به $ t $. از این موضوع می توانید برای حل مسئله موش و پنیر استفاده کنید!
</p><p>پس در کل می توان گفت تبدیل مسائل به Random Walk به ما کمک می کند ولی اغلب به تنهایی برای حل سوال کافی نیست و ما باید خلاقیت بیشتری برای ساده تر کردن مسئله استفاده کنیم.
</p><h1>اعداد رمزی</h1><h2>آشنایی</h2><h3>اولین مسئله</h3><p>جمعی 6 نفره داریم که هر دو یا با هم دوست هستند یا با هم دشمن هستند. ثابت کنید 3 نفر وجود دارند که یا همه با هم دشمن باشند یا همه با هم دوست باشند.
</p><h3>تعریف</h3><p>تابع $ R(a,b) $ برابر است با کمترین $ n $ به طوریکه هر طور یال های یک $ K_n $ را با دو رنگ آبی و قرمز رنگ آمیزی کنیم یا یک $ K_a $ آبی داشته باشد یا یک $ K_b $ قرمز.
</p><p>می توانید به راحتی ثابت کنید که مسئله بالا معادل است با اثبات حکم $ R(3,3) \leq 6 $.
</p><h2>کران ها</h2><p>به دست آوردن مقدار دقیق $ R(a,b) $ ممکن نیست اما می توان کران هایی برای آن ارائه داد.
</p><p>در وهله اول باید ثابت کنیم $ R(a, b) $ وجود دارد.(ممکن است به ازای هیچ $ n $ ای ویژگی مطلوب برای $ K_n $ برقرار نباشد)
</p><p>ایده حل این است که یک راس پیدا کنیم که به اندازه کافی مجاور آبی یا قرمز داشته باشد و سپس تنها مجاور های آن راس را در نظر بگیریم و در آنجا یک خوشه آبی یا قرمز با اندازه کوچکتر پیدا کنیم.
</p><p>به صورت دقیق فرض کنید راسی مثل $ u $ وجود داشته باشد که حداقل $ R(a-1,b) $ مجاور آبی داشته باشد در اینصورت اگر مجاور های این راس را در نظر بگیرید دو حالت زیر پیش می آید‌ :
</p><ul><li><p>در آن یک $ K_{a-1} $ آبی وجود دارد که در اینصورت می توانیم با اضافه کردن راس $ u $ به آن یک $ K_a $ آبی به دست بیاوریم.
</p></li><li><p>در آن یک $ K_b $ قرمز وجود دارد.
</p></li></ul><p>پس اگر راسی باشد که حداقل $ R(a-1,b) $ مجاور آبی وجود داشته باشد مسئله حل می شود. مشابها اگر راسی باشد که حداقل $ R(a, b-1) $ مجاور قرمز داشته باشد هم مسئله حل می شود.
</p><p>پس نتیجه می گیریم که $ R(a,b) \leq R(a-1,b) + R(a,b-1) $ زیرا اگر گراف ما حداقل $ R(a-1,b) + R(a,b-1) $ راس داشته باشد هر راس دلخواهی را که در نظر بگیرید یا به اندازه کافی مجاور آبی خواهد داشت یا به اندازه کافی مجاور قرمز خواهد داشت.
</p><p>نامساوی بالا ما را به یاد اتحاد پاسکال می اندازد. ( $ \binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1} $ )
</p><p>همچنین می توان با استقرا ثابت کرد که $ R(a, b) \leq \binom{a+b}{a} $
</p><h2>تعمیم به k بعد</h2><p>تصور کنید که مجموعه ای $ n $ عضوی داریم و هر زیرمجموعه $ k $ تایی آن را با یکی از رنگ های آبی یا قرمز رنگ کرده ایم. حالا به یک زیرمجموعه مثل $ A $ خوشه $ k $ بعدی می گوییم اگر تمام زیر مجموعه های $ k $ تایی $ A $ همرنگ باشند. (اگر این رنگ آبی باشد خوشه آبی می گوییم و اگر این رنگ قرمز باشد خوشه قرمز می گوییم).
</p><p>حالا $ R_k(a,b) $ را تعریف می کنیم مینیمم $ n $ که هر طور زیرمجموعه های $ k $ تایی آن را با آبی و قرمز رنگ کنیم یا یک خوشه آبی $ a $ تایی داشته باشیم یا یک خوشه قرمز $ b $ تایی.
</p><p>ایده اثبات مشابه بالا است. فرض کنید $ n = R_k(a,b) $ یک عضو خاص مثل $ u $ از مجموعه $ n $ تایی $ A $ را در نظر بگیرید. فرض کنید $ B = A - \{u\} $. هر زیر مجموعه $ k-1 $ تایی از $ B $ مثل $ S $ را به رنگی در می آوریم که زیرمجموعه $ k $ تایی $ S \cup \{u\} $ دارد. اگر تعداد اعضای $ B $ حداقل $ R_{k-1}( R_k(a-1,b), R_k(a,b-1) ) $ باشد در اینصورت یکی از دو اتفاق زیر می افتد :
</p><ul><li><p>در $ B $ یک خوشه $ k-1 $ بعدی آبی مثل $ S $ به اندازه حداقل $ R_k(a-1,b) $ دارد. در اینصورت یا $ S $ یک خوشه $ k $ بعدی قرمز به اندازه $ b $ دارد (که مسئله حل است). یا $ S $ یک خوشه $ k $ بعدی آبی به اندازه $ a-1 $ دارد. در اینصورت می توانیم $ u $ را به این مجموعه اضافه کنیم و یک خوشه $ k $ بعدی به اندازه $ a $ داریم.
</p></li><li><p>در $ B $ یک خوشه $ k-1 $ بعدی قرمز مثل $ S $ به اندازه حداقل $ R_k(a,b-1) $ دارد. در اینصورت یا $ S $ یک خوشه $ k $ بعدی آبی به اندازه $ a $ دارد (که مسئله حل است). یا $ S $ یک خوشه $ k $ بعدی قرمز به اندازه $ b-1 $ دارد. در اینصورت می توانیم $ u $ را به این مجموعه اضافه کنیم و یک خوشه $ k $ بعدی قرمز به اندازه $ b $ داریم.
</p></li></ul><p>طبق مطالب گفته شده می توان ثابت کرد که $ R_k(a,b) \leq R_{k-1}(R_k(a-1,b),R_k(a,b-1)) $
</p><h2>تعمیم به k بعد و c رنگ</h2><p>به صورت مشابه می توانیم برای بیش از دو رنگ نیز مسئله را بیان و اثبات کنیم. پیدا کردن کران روی $ R_k(a_1,a_2,...,a_c) $ را به خواننده واگذار می کنیم.
</p><h1>مجموعه مستقل و خوشه</h1><p>در فصل اول با مجموعه مستقل و خوشه و همچنین اعداد استقلال و خوشه ای آشنا شدیم. هم چنین
دانستیم که
</p>$$ \alpha(G) = \omega(\overline{G}) $$<p>در این فصل با خواص بیشتری از این دو آشنا می شویم.
</p><h2>قضیه توران</h2><p>این قضیه کرانی روی یال های گراف، بر حسب عدد خوشه ای آن است. اگر
$ e $
را تعداد یال های گراف و
$ n $
را تعداد راس های آن
در نظر بگیرید، این قضیه بیان می کند که:
</p>$$ e \le \frac{n^2(\omega - 1)}{2 \omega} $$<p>و حالت برابری تنها در گراف
$ \omega $
بخشی کامل روی می دهد.
</p><h3>اثبات</h3><p>تعریف می کنیم
$ x \sim y $
یعنی راس
$ x $
و
$ y $
به هم یال ندارند. در گرافی که بیشترین تعداد یال ممکن را دارد اگر
$ x \sim y $
و
$ y \sim z $
آن گاه
$ x \sim z $
را اثبات می کنیم. برهان خلف می زنیم. فرض کنید این طور نباشد، آن گاه یکی از دو
حالت زیر وجود دارد:
</p><ul><li><p>درجه راس
$ y $
از دو راس دیگر بزرگتر مساوی باشد. در این صورت آن دو را حذف کنید و 
دو کپی از راس
$ y $
اضافه کنید. واضح است که این گراف خوشه بزرگتری نخواهد داشت و با کمی محاسبه
می توانید دریابید که تعداد یال هایش اکیدا بیشتر است.
</p></li><li><p>درجه یکی از رئوس
$ x $
یا
$ z $
از راس
$ y $
بزرگتر باشد. در این صورت راس
$ y $
را حذف کنید و یک کپی از آن راس با درجه بیشتر اضافه کنید. این گراف خوشه بزرگتری
نخواهد داشت اما یال هایش اکیدا بیشتر است.
</p></li></ul><p>از گزاره بالا نتیجه می شود که گرافی با خوشه
حداکثر
$ \omega $
که بیشترین تعداد یال را داشته باشد، باید یک گراف چند بخشی کامل باشد. و در میان
این گراف ها، گرافی بیشترین یال را دارد که دقیقا
$ \omega $
بخشی باشد و رئوس در این بخش ها به صورت مساوی تقسیم شده باشند (یعنی اختلاف اندازه
بخش ها بیشتر از ۱ واحد نباشد) که این مطلب را می توانید با انتقال رئوس از بخش بزرگ
به کوچک و زیاد شدن تعداد یال ها ثابت کنید.
</p><h3>صورت های دیگر</h3><p>به حالتی که خوشه را کمتر مساوی ۲ در نظر بگیریم، قضیه منتل می گویند که معادل این
می شود که در هر گرافی که مثلث نداشته باشد داریم
</p>$$ e \le \frac{n^2}{4} $$<p>هم چنین این قضیه را می توان برای عدد استقلال نیز بیان کرد. به این صورت که طبق توران
داریم:
</p>$$ e(G) \le \frac{n^2(\omega(G) - 1)}{2 \omega(G)} $$$$ \binom{n}{2} - e(G) \ge \binom{n}{2} - \frac{n^2(\omega(G) - 1)}{2 \omega(G)} $$$$ e(\overline{G}) \ge \binom{n}{2} - \frac{n^2(\alpha(\overline{G}) - 1)}{2 \alpha(\overline{G})} $$<p>و چون هر گرافی یک مکمل دارد، به ازای همه گراف ها داریم:
</p>$$ e \ge \binom{n}{2} - \frac{n^2(\alpha - 1)}{2 \alpha} $$<h2>ارتباط با اعداد رمزی</h2><p>طبق تعریف اعداد رمزی که در بخش های قبل با آن آشنا شدیم، اگر
$ R(s,t)=n $
باشد آن گاه هر گراف
$ n $
راسی یا یک مجموعه مستقل با اندازه
$ s $
و یا یک خوشه با اندازه
$ t $
دارد. از قسمت قبل به خاطر داریم که
$ R(a,b) \le \binom{a+b}{b} $
و بنابراین
</p>$$ R(n,n) \le \binom{2n}{n} \le 4^n $$$$ max(\alpha, \omega) \ge log_4(n) $$<p>که در نوع خود کران جالبی است، مخصوصا وقتی که بدانیم به ازای هر
$ n $
گرافی وجود دارد که
$ max(\alpha, \omega) = \theta(lg(n)) $
باشد.
</p><h1>2-SAT</h1><p>2-SAT که مخفف 2-Satisfiability است یک مسئله منطقیست.
</p><p>نکته ای که وجود دارد این است که به شما یک عبارت با متغیر های منطقی داده شده و شما باید جوری متغیر ها را صفر و یک دهید که شرط برقرار شه و یا بگویید که نمی توان شراطی را برقرار کرد. این عبارت چیزی شبیه به $ ({a_1} ∨ {b_1}) ∧ ({a_2} ∨ {b_2}) ∧ ··· ∧ ({a_m} ∨ {b_m}) $ است که در آن $ a_i $ و $ b_i $ یکی از متغیر های $ ({x_1}, {x_2},..., {x_n}) $ و یا نقیض آن ها یعنی $ ({¬x_1}, {¬x_2},..., {¬x_n}) $ است.
</p><h2>الگوریتم</h2><p>در ابتدا به ازای هر متغیر و نقیض آن یک راس در گراف می گذاریم (در مجموع 2n راس) و به ازای هر عبارت $ u ∨ w $ یک یال جهت دار از نقیض u به w و یک یال جهت دار از نقیض w به u می گذاریم.
</p><p>اگر دو راس u و نقیض u در یک مولفه قویاً همبندی باشند به این معنی است که نمی توان شرایط این عبارت را برقرار کرد چرا که اگر u یک باشد آنگاه نقیض آن هم یک است و اگر u صفر باشد نقیض آن هم صفر است.
</p><p>با توجه به این مفهوم می توانیم با الگوریتم کوسارا جو <https://gtoi.shaazzz.ir/book/3/4.html#id13> بفهمیم که آیا در یک مولفه قویاً همبندی یک راس با نقیضش آمده یا نه.
</p><p>اگر نکته بالا برقرار بود یعنی می توانیم جوری متغیر ها را یک و صفر دهیم که شرایط عبارت سوال برقرار شود بنابراین در گام بعدی می خواهیم متغیر ها را یک و صفر دهیم.
</p><p>راس های گراف را مرتب سازی توپولوژیک <https://gtoi.shaazzz.ir/book/3/3.html#id4> می کنیم. اگر u بعد از نقیضش بیاد مقدارش رو یک و اگر u قبل از نقیضش بیاد به آن صفر می دهیم.
</p><p>این الگوریتم دارای اردر $ O(n + m) $ است.
</p><h2>کاربرد ها</h2><p>از کاربرد های 2-SAT می توان به تشخیص دو بخش بودن گراف کرد. به این نحو که به ازای هر راس یک متغیر در نظر می گیریم. و اگر دو راس مانند u و v به هم یال داشتند دو شرط $ (a_v ∨ ¬a_u) ∧ (¬a_v ∨ a_u) $ را به عبارت 2-SAT اضافه می کنیم.
واضح است که می توانیم با این شرط ها گراف های دو بخشی را تشخیص دهیم. به این صورت که یک بخش گراف را صفر و بخش دیگر را یک در نظر بگیریم شرط 2-SAT برقرار است بنابراین اگر به جواب برسیم یعنی گراف دو بخشی است.
</p><h2>3-SAT</h2><p>مسئله سخت تری نسبت به 2-SAT، که بجای دو متغیر در هر پرانتز سه متغیر وجود دارد. این مسئله NP است و بنابراین الگوریتم مناسبی برای آن موجود نیست.
گفتی است که می توان تمام K-SAT ها را به 3-SAT تبدیل کرد که در آن k از سه بزرگ تر است.</p><h1>چند ماتریس خاص</h1><h2>ماتریس صفر</h2><p>ماتریسی که تمام درایه های آن صفر است.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس سطری</h2><p>ماتریسی که فقط یک سطر دارد.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس ستونی</h2><p>ماتریسی که فقط یک ستون دارد.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس مربعی</h2><p>ماتریسی که تعداد سطر های آن با تعداد ستون های آن برابر است.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس قطری</h2><p>نوع خاصی از ماتریس مربعی است که تمام درایه های بالا و پایین قطر اصلی آن صفر است.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس اسکالر</h2><p>ماتریسی قطری است که درایه های روی قطر اصلی آن با هم برابرند.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس همانی(واحد)</h2><p>ماتریس اسکالری که درایه های روی قطر آن برابر 1 است.
این ماتریس با مرتبه n × n را با $ I_n $ نشان می دهند.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس متقارن</h2><p>ماتریسی مربعی که درایه سطر i و ستون j با درایه سطر j و ستون i برابر است.
به عبارتی دیگر $ a_{ji} $ = $ a_{ij} $ است.
</p><p>$ \begin{equation*}
 $
</p><h2>ماتریس متناوب</h2><p>ماتریسی مربعی که توانی از k وجود داشته باشد که $ A^k = A $ می گویند.
</p><h2>ماتریس ترانهاده</h2><p>ماتریس ترانهاده از روی یک ماتریس دیگر ساخته می شود و اگر ماتریس A را در نظر بگیریم با n سطر و m ستون، درایه $ a^{T}_{ij} $ ماتریس ترانهاده ساخته شده از روی ماتریس A که آن را با $ A^T $ نشان می دهیم با m سطر و n ستون برابر است با درایه $ a_{ji} $ ماتریس A .
</p><p>$ \begin{equation*}
 $
$ \begin{equation*}
 $
</p><h2>ماتریس مثلثی</h2><p>گونه خاصی از ماتریس های مربعی است. ماتریس های مثلثی به دو دسته بالا مثلثی و پایین مثلثی تقسیم می شوند که بالا مثلثی به ماتریسی گفته می شود که درایه های زیر قطر اصلی صفر است و پایین مثلثی به ماتریسی که درایه های بالای قطر اصلی صفر است.
</p><h2>ماتریس کهاد</h2><p>ماتریس کهاد از روی یک ماتریس دیگر ساخته می شود و اگر ماتریس A را در نظر بگیریم، برای بدست آوردن درایه $ a_{ij} $ ماتریس ترانهاده اول ماتریس B را با حذف کردن سطر i و ستون j ماتریس A درست میکنیم و بعد مقدار $ a_{ij} $ برابر با دترمینان ماتریس B است.
</p><p>$ \begin{equation*}
 $
$ \begin{equation*}
 $
</p><h2>ماتریس همسازه</h2><p>ماتریس همسازه از روی ماتریس دیگر ساخته می شود و فرض کنید که ماتریس A باشد، درایه سطر i و j ماتریس همسازه با $ a_{ij} $ × $ -1^{i + j} $ برابر است.
</p><p>$ \begin{equation*}
 $
$ \begin{equation*}
 $
</p><h2>ماتریس الحاقی</h2><p>به ترانهاده همساز یک ماتریس گفته می شود.
</p><h2>ماتریس وارون</h2><p>به ماتریس B وارون ماتریس A می گویند اگر ضربشان ماتریس همانی باشد(A × B = I). 
وارون یک ماتریس برابر با ماتریس الحاقی ماتریس کهاد آن ماتریس است.
</p><p>$ \begin{equation*}
 $
$ \begin{equation*}
 $</p><h1>﻿خاصیت های مقدماتی</h1><p>در این فصل به بررسی درخت که یکی از مهمترین تعاریف گراف است و کاربرد زیادی در برنامه نویسی نیز دارد میپردازیم . 
</p><p>در این بخش ویژگی ها و خاصیت های اصلی درخت را بیان و آن ها را اثبات میکنیم . در پایان این بخش انتظار میرود شهود خوبی روی شکل درخت و ویژگی های ابتدایی آن داشته باشید.
</p><h2>تعاریف مربوط به این بخش</h2><ul><li><p><b>درخت</b> : گراف ساده ای که همبند است و دور ندارد .
</p></li><li><p><b>جنگل</b> : گراف ساده ای که دور ندارد .
</p></li><li><p><b>برگ</b> : راسی در درخت که درجه اش 1 است .
</p></li><li><p><b>درخت فراگیر یا درخت پوشا</b> : زیر گراف فراگیری که درخت است .
</p></li></ul><h2>قضایا و لم های مورد استفاده در این بخش </h2><h3>لم 2.1.1</h3><p><b>صورت لم :</b> یک گراف $ n $ راسی و $ m $ یالی حداقل max(1,n-m) مؤلفه همبندی دارد و اگر دقیقا n-m مؤلفه همبندی داشت دور ندارد و اگر نه دور دارد .
</p><p><b>اثبات لم :</b>
ابتدا فرض میکنیم گراف هیچ یالی ندارد و یال های آن را به ترتیبی دلخواه اضافه میکنیم . 
</p><p>حال اثبات میکنیم وقتی یک یال را به گراف اضافه میکنیم تعداد مؤلفه های همبندی حداکثر یکی کمتر میشود و اگر تعداد مؤلفه های ثابت ماند گراف دور خواهد داشت.
فرض کنید یالی که الان به گراف اضافه میکنیم بین دو راس i و j است. اگر i و j در یک مؤلفه همبندی بودند بعد اضافه کردن یال تعداد مولفه های همبندی تغییر نمیکند و چون بین i و j مسیر است یال جدید و مسیر بین i و j تشکیل دور میدهند.
اگر هم i و j در دو مؤلفه همبندی بودند بعد اضافه کردن یال مولفه های  i و j باهم یک مولفه همبندی میدهند یعنی تعداد مؤلفه های همبندی یکی کم میشود و چون مسیری بین i و j نبود با اضافه شدن یال دوری با این یال بوجود نمیاید.
</p><p>وقتی هیچ یالی را هنوز اضافه نکردیم گراف n مؤلفه همبندی دارد و چون با اضافه کردن هر یال حداکثر تعداد مولفه ها یکی کم میشد پس در اخر حداقل n-m مولفه همبندی داریم.
پس اگر گراف در اخر دقیقا n-m مولفه همبندی داشت یعنی با اضافه کردن هر یال تعداد مولفه های همبندی دقیقا یکی کم میشد که ما ثابت کردیم وقتی تعداد مؤلفه های همبندی یکی کم شود دوری اظافه نمیشود 
پس در اخر گراف ما بدون دور است. و اگر بیشتر از n-m بود یعنی یالی بود که وقتی اضافه اش میکردیم تعداد مولفه های همبندی کم نمیشد پس دور بوجود می امد پس گراف ما دور دارد.
</p><p>با توجه به لم 2.1.1 اگر بدانیم یک گراف دور ندارد و از تعداد یال ها , تعداد راس ها و تعداد مولفه های همبندی حداقل دو تایشان را بدانیم دیگری یکتا بدست می اید در واقع اگر گراف دور نداشت :
</p><ul><li><p>n - m - Cc = 0
</p></li><li><p>n = تعداد راس ها
</p></li><li><p>m = تعداد یال ها
</p></li><li><p>Cc = تعداد مؤلفه های همبندی
</p></li></ul><h3>قضیه 2.1.2</h3><p><b>صورت قضیه :</b> درخت n راسی دقیقا n-1 یال دارد.
</p><p><b>اثبات قضیه :</b> طبق لم 2.1.1 اگر یک گراف n راسی و m یالی دور نداشته باشد دقیقا n-m مولفه همبندی دارد و چون درخت یک مولفه همبندی دارد و دور ندارد پس در درخت n راسی n - m = 1 است پس m = n - 1.
</p><h3>قضیه 2.1.3</h3><p><b>صورت قضیه :</b> یک درخت n راسی که (n >= 2) حداقل 2 برگ دارد.
</p><p><b>اثبات :</b> بلندترین مسیر در درخت را در نظر بگیرید. چون n > 1 پس قطعا بلندترین مسیر حداقل 2 راس دارد.حال 2 راس سر مسیر را در نظر بگیرید. حداکثر به یک راس در مسیر یال دارد زیرا اگر بیشتر داشته باشند دور بوجود می اید که با ویژگی درخت
تناقض دارد . و چون بلند ترین مسیر را گرفته ایم دو سر مسیر به راسی که داخل مسیر نیست یال ندارند پس ثابت شد دو سر بلند ترین مسیر در درخت برگ هستند.
</p><h3>قضیه 2.1.4</h3><p><b>صورت لم :</b> اگر از درخت برگش را حذف کنیم گراف باقی مانده باز درخت است.
</p><p><b>اثبات :</b> باید ثابت کنیم گراف باقی مانده همبند است و دور ندارد. واضح است که یک گراف اگر دور نداشته باشد وقتی راسی از ان را نیز حذف کنیم باز دور ندارد.حال میخواهیم بگوییم همبند است. اگر برگ را حذف کنیم و گراف ناهمبند شود پس حداقل  2 مولفه همبندی دارد
و راسی که حذف کردیم هم باید به هر یک از این مولفه ها حداقل یک یال میداشت تا گراف بدون حذفش همبند باشد پس درجه اش حداقل 2 بود ولی درجه برگ 1 است. با تناقض بدست آمده ثابت شد گراف همبند نیز هست پس درخت است.
</p><p>قضیه 2.1.4 بسیار کاریردی است چون نشان میدهد اگر در سوالی خواستید روی درخت استقرا بزنید با حذف برگ میتوانید به فرض استقرا بروید.در ادامه کتاب با چنین سوالاتی اشنا خواهید شد.
</p><h3>قضیه 2.1.5</h3><p>ثابت کنید گرافی که ویژگی های یکی از موارد زیر را داشته باشد درخت است. 
</p><ul><li><p>الف) گرافی که n-1 یال دارد و همبند است.
</p></li><li><p>ب) گرافی که دور ندارد و n-1 یال دارد.
</p></li><li><p>ج) بین هر دو راس گراف دقیقا یک مسیر وجود دارد.
</p></li></ul><p><b>جواب :</b>
</p><p><b>الف)</b>  اگر ثابت کنیم گراف دور ندارد قضیه اثبات میشود. طبق لم 2.1.1 اگر گراف دور داشته باشد تعداد مولفه های همبندی بیشتر از n-m است ولی در این گراف برابر n-m است.
با تناقض بدست امده قضیه اثبات شد.
</p><p><b>ب)</b>  چون گراف دور ندارد طبق لم 2.1.1 : 
</p><p>n - m - Cc = 0  -->  n - (n-1) = Cc  -->  Cc = 1 
</p><p>پس گراف همبند است و دور ندارد پس درخت است .
</p><p><b>ج)</b> باید ثابت کنیم گراف همبند است و دور ندارد. واضح است گراف همبند است زیرا بین هر دو راس مسیر وجود دارد پس همه در یک مولفه همبندی هستند .حال باید بگوییم دور ندارد .این هم 
واضح است زیرا اگر دور داشته باشد بین هر دو راس از یک دور حداقل 2 مسیر وجود دارد .
</p><h3>قضیه 2.1.6</h3><p><b>صورت قضیه :</b> هر گراف همبند یک درخت فراگیر دارد.
</p><p><b>اثبات :</b> تا زمانی تعداد یال های گراف n-1 نشده هر مرحله یک یال را از گراف حذف میکنیم و ثابت میکنیم گراف همچنان همبند است و طبق قضیه 2.1.5 گرافی که n-1 یال دارد و همبند است درخت است و قضیه اثبات میشود.
</p><p>پس تا زمانی که تعداد یال ها n-1 نشده حرکت زیر را انجام میدهیم : چون تعداد یال ها بیشتر از n-1 است و گراف 1 مولفه همبندی دارد طبق لم 2.1.1 در گراف دور وجود دارد. یکی از دور ها را بگیرید و یک یال از ان را حذف کنید واضح است گراف همبند میماند 
زیرا دو سر این یال از طریق یال های دیگر این دور باز هم به هم مسیر دارند پس تا وقتی تعداد یال ها n-1 نشده میتوانیم هی یال حذف کنیم به طوری که گراف همبند بماند پس قضیه اثبات شد.
</p><h2>ریشه دار کردن درخت</h2><p>فرض کنید یال های درخت را طوری جهت دهی کردیم که هر راس به جز راس $ u $ دقیقا یک ورودی دارد (دقیقا یک یال به آن وارد می شود) و راس $ u $ هیچ ورودی ندارد.
</p><p>در ابتدا یک مهره را روی راس $ v $ قرار دهید و در هر مرحله مهره اگر در راس $ w $ بودیم مهره را به راسی ببرید که به $ w $ یال ورودی دارد. اگر $ w \neq u $ باشد آنگاه این راس یکتا است.
</p><p>اول از همه می توان نتیجه گرفت در هر مرحله یک راس جدید را می بینیم (زیرا در درخت دور نداریم و اگر راس تکراری ببینیم یک دور را طی کرده ایم) سپس می توان نتیجه گرفت مراحل متناهی است (زیرا در هر مرحله یک راس جدید را می بینیم و تعداد راس ها متناهی است) و در نهایت می توان گفت مهره به $ u $ خواهد رسید.
</p><p>به صورت شهودی می توانید تصور کنید درخت را از $ u $ <b>آویزان</b> کرده اید و به ازای هر یال $ ab $ اگر $ a $ در ارتفاع بالاتری نسبت به $ b $ بود یال را از $ a $ به $ b $ جهت دهی کرده ایم. در اینصورت جهت دهی مذکور همان جهت دهی خواهد بود که در بالا به آن اشاره کردیم. برای شهود بیشتر می توانید به اینصورت فکر کنید. در جهت دهی بالا راس $ u $ ورودی ندارد پس تمام یال های مجاور $ u $ باید از $ u $ به خارج جهت دهی شوند. در اینصورت به راس های مجاور $ u $ لایه اول می گوییم. حالا تمام لایه اول دقیقا یک ورودی دارند‌ (که آن ورودی $ u $ است) پس تمام یال های مجاور دیگر آن ها باید از لایه اول به خارج جهت دهی شوند که به آن ها لایه دوم می گوییم. به همین شکل می توان لایه سوم را تعریف کرد. هر راس لایه دوم دقیقا یک ورودی دارد که در لایه اول قرار دارد. پس تمام مجاور های دیگر آن را در لایه سوم قرار می دهیم و یال ها را از لایه دوم و سوم جهت دهی می کنیم. به همین شکل می توانید جهت دهی کردن و لایه بندی را ادامه دهید. یال های لایه $ h $ ام به $ h+1 $ ام را در نظر بگیرید و توجه کنید که تعداد یال های ورودی هر راس لایه $ h+1 $ ام باید دقیقا 1 باشد پس به هر راس در لایه $ h+1 $ ام دقیقا یک یال از لایه $ h $ ام می رسد.در نهایت نتیجه می گیرید که جهت دهی که در ابتدا تصور کردیم همان جهت دهی است که با شهود <b>آویزان کردن</b> از راس $ u $ به دست آوردیم.
</p><img src="/_static/dot/Simple_Rooted_Tree.svg"><p>به این عمل آویزان کردن درخت از راس $ u $، ریشه دار کردن درخت از راس $ u $ هم می گویند. در اینصورت به راس $ u $ <b>ریشه</b> می گوییم. همچنین گفتیم در جهت دهی هر راس به جز $ u $ تنها یک یال ورودی دارد.
</p><p>به ازای راس $ b $ اگر یال ورودی به آن $ ab $ باشد به راس $ a $ <b>پدر</b> راس $ b $ می گوییم.
</p><p>هر دو راسی که پدر مشترک داشته باشند را <b>برادر</b> می نامیم.
</p><p>راس $ u $ <b>جد</b> راس $ v $ است اگر که یا $ u $ پدر راس $ v $ باشد یا اینکه $ u $ جد پدر $ v $ باشد. به عبارتی به مجموعه پدران یک راس جد های این راس می گوییم.
</p><p>به فاصله بین $ u $ و هر راس (تعداد یال های مسیر بین آن ها) <b>ارتفاع</b> آن راس می گوییم.
</p><p>به ازای یک راس خاص مثل $ v $ به مجموعه راس هایی که مسیرشان (که این مسیر یکتا است) به ریشه از $ v $ می گذرد <b>زیردرخت</b> راس $ v $ می گوییم. به طور شهودی وقتی درخت را از $ u $ آویزان کردیم به مجموعه راس هایی که از $ v $ آویزان شده اند زیردرخت $ v $ می گوییم.
</p><p>اویزان کردن درخت بسیار مهم است زیرا در ادامه فصل در الگوریتم ها از آن استفاده میشود و همچنین در حال حاظر بهترین روش برای شهود روی شکل درخت است است به این صورت که درخت یک ریشه 
دارد و ان ریشه با تعدادی شاخه با راس های دیگر همسایه است و ان ها نیز با تعدادی شاخه با راس های جدیدی همسایه هستند و ...(به مانند شکل بالا)
</p><h1>فاصله در درخت و گراف</h1><p>در این بخش با معرفی فاصله در گراف به بررسی تعریف های مرتبط با فاصله چه در حالت کلی و چه در حالت خاص آن(یعنی در درخت) میپردازیم. در درخت ها صحبت در مورد فاصله به مراتب راحت تر از گراف در حالت کلی است چرا که همانطور که در بخش قبل بررسی کردیم در درخت مسیر بین هر دو راس یکتا است.
</p><h2>فاصله چیست؟</h2><p>دو راس $ u,v $ در گراف را در نظر بگیرید. فاصله این دو راس طول (تعداد یال ها) کوتاه ترین مسیر بین این دو راس تعریف می شود.
</p><p>نکته : اگر دو راس در دو مولفه همبندی جدا باشند فاصله آن ها بینهایت است.
</p><p>فاصله دو راس $ u,v $ را به صورت $ d(u,v) $ نشان میدهند.
</p><h2>قطر </h2><p>تعریف : قطر گراف برابر است با
$ Max_{u,v} d(u,v) $
یا به عبارتی ماکسیمم فاصله دو به دو راس ها در گراف.
</p><p>توجه کنید که قطر بلندترین مسیر نیست و در واقع بلند ترین <b>فاصله</b> است ولی در درخت بلندترین مسیر و قطر یکی است زیرا اگر دو سر بلندترین مسیر را بگیرید
چون بین آن دو دقیقا یک مسیر وجود دارد و بلندترین مسیر , آن مسیر است در واقع طول بلندترین مسیر برابر فاصله آن دو راس است پس قطر برابر بلندترین مسیر است.
تفاوت بلند ترین مسیر و قطر جایی به چشم می اید که در حالت کلی  پیدا کردن قطر یک گراف از اوردر چند جمله ای حل میشود ولی پیدا کردن بلند ترین مسیر یک مسئله NP است.
</p><h2>خروج از مرکز</h2><p>اگر نام راس را $ u $ در نظر بگیریم خروج از مرکز $ u $ برابر ماکسیمم $ d(u,v) $ به ازای همه $ v $ هاست.
</p><p>گراف اگر درخت باشد و درخت را از $ u $ اویزان کنیم خروج از مرکز $ u $ میشود ارتفاع راسی که بیشترین ارتفاع را در درخت دارد.
</p><p>خروج از مرکز راس $ u $ را با  $ \varepsilon{(u)} $  نشان میدهند.
</p><h2>قضیه 2.2.1</h2><p>صورت قضیه : در درخت خروج از مرکز یک راس برابر ماکسیمم فاصله آن از دو سر قطر است.
</p><p>اثبات : برهان خلف میزنیم. فرض کنید راس ما $ a $  است و دو سر قطر هم راس های $ u , v $ هستند . و راسی که فاصله اش با $ a $ برابر $ \varepsilon(a) $ است $ b $ نام دارد . واضح هم است $ a $ اگر یکی از دو سر قطر بود حکم درست است پس فرض میکنیم هیج یک از دو سر قطر نیست.
</p><p>درخت را از $ a $ آویزان میکنیم. فرض کنید راس $ mh $ راسی با بیشترین ارتفاع باشد که سه راس $ b,u,v $ داخل زیر درخت آن هستند.
چون $ mh $ بیشترین ارتفاع از پدر های مشترک این سه راس دارد یعنی یا $ mh = b $ است یا بچه ای از $ mh $ که جد $ b $ است در زیر درختش حداقل یکی از دو راس 
$ u , v $ را ندارد.که یعنی $ mh = lca(u,b) $  or $ lca(v,b) $ .بدون از دست دادن کلیت مسئله فرض کنید $ mh = lca(u,b) $. حال ثابت میکنیم $ d(b,u) $ > $ d(u,v) $
با اثبات این بخش با تناقض بدست امده در طول قطر قضیه اثبات میشود.
</p><ul><li><p>$ d(b,u) $ > $ d(u,v) $
</p></li><li><p>$ mh = lca(b,u) $ $ \longrightarrow $  $ h(b)+h(u)-2×h(Mh) $ > $ d(u,v) $
</p></li><li><p>اگر $ mh \neq lca(u,v) $ هم باشد باز جد مشترکشان است پس $ d(u,v) $ $ \leqslant $ $ h(u)+h(v)-2×h(mh) $
</p></li><li><p>در نتیجه 
$ h(B) + h(u) - 2×h(mh) > h(u) + h(v) - 2×h(mh) \longrightarrow h(B) > h(u) $
که فرض سوال است پس عبارت درست است. با تناقض بدست امده قضیه اثبات شد.
</p></li></ul><h2>شعاع و مرکز</h2><p>به راسی که مینیمم خروج از مرکز را را در بین راس های گراف دارد مرکز گراف گوییم و به خروج از مرکز آن شعاع گراف.
</p><h2>قضیه 2.2.2</h2><ul><li><p>الف) در درخت اگر قطر برابر $ Q $ باشد شعاع برابر $ \lceil{Q/2}\rceil $ است.
</p></li><li><p>ب) در درخت اگر $ Q $ فرد باشد دو راس وسط مسیر دو سر قطر مرکز هستند و اگر زوج باشد راس وسط قطر.
</p></li></ul><p>اثبات : در ابتدا ثابت میکنیم راسی که در مسیر دو سر قطر نیست نمیتواند مرکز باشد. راسی مانند $ u $ را در نظر بگیرید که در مسیر دو سر قطر نیست و راس $ v $ را راسی از مسیر دو سر قطر در نظر بگیرید که فاصله اش با
$ u $ مینیمم است با توجه به قضیه 2.2.1 میتوان فهمید $ \varepsilon{(u)} = \varepsilon{(v)} + d(u,v) $ پس $ u $ قطعا مرکز نیست.
حال بیایبد راس های درون مسیر دو سر قطر را از یک سر قطر به ترتیب شماره گزاری کنید(یعنی از 0 تا $ Q $. طبق  قضیه 2.2.1 میدانیم راس خروج از مرکز راس $ i $ ام در مسیر دو سر قطر برابر $ max(i,Q-i) $
است.میدانیم مینیمم عبارت بالا زمانی است که $ i , Q-i $ کمترین اختلاف را با هم داشته باشند پس
</p><ul><li><p>اگر $ Q $ زوج باشد جواب میشود  $ max(Q - Q/2 , Q/2) $ = $ Q/2 $  پس شعاع برابر $ Q/2 $ است و تنها مرکز هم راس وسط قطر است (راس $ Q/2 $ مسیر دو سر قطر.
</p></li><li><p>اگر $ Q $ فرد باشد شعاع میشود  $ max((Q-1)/2 , (Q+1)/2) $ = $ (Q+1)/2 $  و تنها راس هایی در مسیر در سر قطر که چنین ویژگی دارد راس های $ (Q-1)/2,(Q+1)/2 $  مسیر دو سر قطر هستند.
</p></li></ul><h2>سنتروید</h2><p>به راسی در گراف که مجموع فاصله هایش از دیگر راس ها مینیمم است سنتروید گراف میگویند . به مانند تعاریف بالا سنتروید در درخت نیز دارای ویژگی جالبی است که در قضیه زیر آمده.
</p><h2>قضیه 2.2.3</h2><ul><li><p>الف) در درخت یک راس سنتروید است اگر و تنها اگر وقتی او را از درخت حذف کنیم سایز هر مولفه کمتر مساوی $ n/2 $ باشد.
</p></li><li><p>ب) در درخت حداکثر دو سنتروید داریم و اگر دو تا باشند گراف زوج راسی است و ان دو به هم یال دارند .
</p></li></ul><p>اثبات : راس ها را شماره گزاری میکنیم و $ a_i $ برابر مجموع فاصله های راس $ i $ از دیگر راس های خواهد بود.حال ابتدا بخش اگر الف را اثبات میکنیم. فرض کنید سنتروید راس $ u $ باشد و وقتی ان را حذف کنیم 
مولفه همبندی با سایز بیشتر از
$ n/2 $
بوجود بیاید حال میگویم راسی که از ان مولفه با
$ u $
همسایه است را در نظر بگیرید و نام آن را
$ v $
بگزارید . فاصله
$ v $
از راس های داخل این مولفه همبندی 
یکی کمتر از فاصله
$ u $
از ان ها است و برای دیگر راس ها هم فاصله آن یکی بیشتر از فاصله
$ u $
است پس
$ a_v = a_u - sz + (n-sz) $
که $ sz $ برابر سایز آن مولفه همبندی است.
و چون
$ sz > n/2 \longrightarrow n - 2 \times sz < 0 \longrightarrow a_v > a_u $
با تناقض بدست امده اگر الف اثبات شد.
</p><p>حال ثابت میکنم هر دو راسی مانند
$ i , j $
که ویژگی اگر بخش الف را دارند در ان ها
$ a_i = a_j $
و چون میدانیم سنتروید ما ویژگی اگر الف را دارد پس همه راس ها با ویژگی اگر الف سنتروید هستند.
درخت را از راس
$ i $
اویزان میکنیم.حال یک متغیر به نام
$ A $
داریم که وقتی روی راس
$ z $
هستیم
$ A = a_z $
و اول کار $ A = a_i $ حال از راس ریشه یعنی $ i $ به سمت راس $ j $ حرکت میکنیم
(یعنی در واقع مسیر بین این دو راس را با شروع از
$ i $
طی میکنیم) حال زمانی که از یک راس به بچه اش میرویم
$ A $
به اندازه سایز زیر درخت بچه اش کم میشود
و به اندازه تعداد راس های منهای سایز زیر درخت بچه اش به
$ A $
اضافه میشود.
ما میدانیم سایز زیر درخت
$ j $
بیشترمساوی از
$ n/2 $
است زیرا وقتی
$ j $
را از درخت حذف کنیم سایز مولفه همبندی که پدرش در آن قرار دارد طبق فرض کمتر مساوی
$ n/2 $
است پس تعداد راس های که در این مولفه نیستند(با احتساب $ j $)
بیشتر مساوی
$ n/2 $
است. پس سایز زیر درخت تمام جد های
$ j $
که ما طی کردیم هم این بیشتر مساوی بیشتر مساوی
$ n/2 $
است پس میتوان نتیجه گرفت مقدار
$ A $
همیشه یا کمتر میشود یا تغییر نمیکند.
پس
$ a_i \geq a_j $
. اگر ما درخت را از
$ j $
هم اویزان کنیم و مسیر بین ان دو را طی کنیم به نتیجه
$ a_j \geq a_i $
میرسیم که در نتیجه
$ a_i = a_j $
است.
</p><p>حال به اثبات بخش ب میرویم فرض کنید دو راس $ i,j $ سنتروید هستند و درخت را از  $ i $ اویزان کردیم و داریم الگوریتم بالا را طی میکنیم حال میگوییم وقتی از یک راس به بچه اش میرویم $ A $ در صورتی تغییر نمیکند
که سایز زیر درخت بچه دقیقا برابر $ n/2 $ باشد و چون سایز زیر درخت $ j $ بیشتر مساوی از $ \lceil{n/2}\rceil $ است پس باید برای آن که $ A $ در کل مسیر تغییر نکند $ j $ بچه 
$ i $ باشد و سایز زیر درختش  دقیقا $ n/2 $ باشد . پس درخت زوج راسی است زیرا سایز زیر درخت $ j $ بیشتر مساوی $ \lceil{n/2}\rceil $ است و سایز زیر درخت بچه های 
$ i $ باید کمتر مساوی $ \lfloor{n/2}\rfloor $ باشد پس باید $ \lfloor{n/2}\rfloor = \lceil{n/2}\rceil ` باشد پس :math:`n $ زوج است.
همچنین فهمیدیم در بالا هر دو سنتروید با هم همسایه اند پس واضح است که حداکثر میتوانیم دو سمنترید داشته باشیم و اگر نه دور داریم.
</p><h2>مجموع فاصله ها</h2><p>فرض کنید در مسئله ای هدف مینیمم یا ماکسیمم کردن مجموع فاصله بین هر دو راس است فرض کنید به این مجموع چگالی گراف بگوییم. به صورت شهودی هر چه چگالی گراف کمتر باشد گراف جمع و جور تر و هر چه چگالی گراف بیشتر باشد گراف پهن و پخش تر است.
</p><p>در ضمن برای اینکه فاصله تعریف شده باشد فرض کنید موضوع بحث ما گراف های همبند می باشد.
</p><h3>کمینه کردن چگالی گراف</h3><p>فاصله بین دو راس حداقل 1 است. و در گراف $ K_n $ فاصله بین هر دو راس دقیقا 1 است. پس کمترین چگالی ممکن در گراف $ K_n $ به دست می آید که برابر با $ n \choose 2 $ می باشد.
</p><p>حالا اگر دامنه بحث را به درخت ها محدود کنیم مسئله کمی سخت تر می شود. اما همچنان می توان اینگونه استنتاج کرد.
</p><ul><li><p>دقیقا $ n-1 $ جفت از راس ها هستند که فاصله اشان دقیقا 1 است. زیرا درخت $ n-1 $ یال دارد.
</p></li><li><p>هر جفتی از راس ها که به همدیگر یال ندارند دارای فاصله حداقل 2 هستند.
</p></li></ul><p>در نتیجه کمترین چگالی ممکن حداقل $ 2 \times {n \choose 2} - (n-1) $ می باشد و تنها مثالی که در حالت این کران صدق می کند حالتی است که فاصله بین هر دو راس <b>حداکثر</b> برابر با 2 است. تنها درختی که این ویژگی را دارد ستاره می باشد (همانطور که در عکس می بینید). زیرا که اگر در این گراف دو برگ باشند که پدر مشترک نداشته باشند در اینصورت فاصله آنها حداقل 3 خواهد بود.
</p><img src="/_static/dot/S_7.svg"><h3>بیشینه کردن چگالی گراف</h3><p>در این حالت توجه کنید که اگر یالی را حذف کنیم و حذف این یال گراف را ناهمبند نکند باید اینکار را بکنیم. زیرا که حذف یال باعث بیشتر شدن چگالی می شود (چرا؟). پس گرافی که چگالی آن بیشینه است را باید در میان درخت ها جست و جو کرد (زیرا همانطور که گفتیم همه یال های آن باید برشی باشد).
</p><p>حالا یک راس خاص مثل $ u $ را در نظر بگیرید. ادعا می کنیم جمع فواصل همه راس ها از $ u $ حداکثر برابر با $ n \choose 2 $ است.
</p><p>برای اثبات فرض کنید درخت را از $ u $ آویزان کرده ایم و به ازای هر ارتفاع می دانیم که چند راس در این ارتفاع قرار دارند و بیشترین ارتفاع $ H $ باشد. در اینصورت به ازای هر ارتفاعی از 0 تا $ H $ حداقل یک راس از این ارتفاع باید داشته باشیم. حالا اگر حداقل دو راس در یک ارتفاع داشتیم می توان یکی از آن ها را به ارتفاع بالاتر برد و در اینصورت جمع ارتفاع ها بیشتر خواهد شد. با تکرار این فرایند به حالتی می رسیم که در هر ارتفاع 0 تا $ n-1 $ دقیقا یک راس باشد (یعنی درخت یک مسیر شده) که در این حالت جمع فاصله ها از $ u $ برابر با $ 1 + 2 + ... + (n-1) = {n \choose 2} $ خواهد بود. پس ثابت کردیم که جمع فاصله ها از هر راس $ u $ حداکثر $ n \choose 2 $ است.
</p><p>پس حالا برای اینکه به یک کران برسیم در هر مرحله یک <b>برگ</b> را از درخت حذف کنید و جمع فاصله ها از این برگ را محاسبه کنید. جمع تمام مقادیر برابر با چگالی گراف خواهد بود که طبق آنچه گفتیم حداکثر $ \sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3} $ خواهد بود (طبق اتحاد چوشی چی).
</p><p>می توان نتیجه گرفت تنها گرافی که در حالت تساوی این کران صدق می کند گراف مسیر است.
</p><h2>درخت پشتیبانی</h2><p>فرض کنید یک شبکه ارتباطی داریم که $ n $ شهر را به هم وصل می کنند. برای اطمینان یک شبکه ارتباطی پشتیبانی هم آماده کرده ایم که در صورت ایجاد اختلال در شبکه اصلی از شبکه پشتیبانی استفاده کنیم تا ارتباط قطع نشود.
</p><p>به زبان گراف دو درخت $ n $ راسی $ T $ و $ T ^ {\prime} $ داریم. می خواهیم ثابت کنیم در صورتیکه یکی از یال های $ T $ مثل $ uv $ قطع شوند می توان یکی از یال های $ T ^ {\prime} $ مثل $ u^{\prime}v^{\prime} $ را به درخت $ T $ اضافه کرد که ساختار همچنان همبند باقی بماند.
</p><p>پس فرض کنید $ uv $ را از $ T $ حذف کردیم در اینصورت درخت ما دارای دو مولفه همبندی خواهد شد یکی از مولفه ها را آبی و دیگری را قرمز در نظر بگیرید. حالا می توان در درخت $ T^{\prime} $ مسیری بین $ u,v $ یافت.
در این مسیر یالی وجود خواهد داشت که یک سر آن آبی و یک سر آن قرمز باشد (چرا؟). حالا اگر این یال $ u^{\prime}v^{\prime} $ باشد می توانیم این یال را به $ T $ اضافه کنیم و دوباره آن را همبند کنیم!
</p><h2>افراز درخت به مسیر ها</h2><p>درخت $ T $ را در نظر بگیرید. در این قسمت هدف ما این است که یال های این درخت را به کمترین تعداد تعدادی مسیر افراز کنیم. برای شهود بهتر فرض کنید یال های مسیر ها را یکی یکی از درخت حدف می کنیم تا به گرافی بدون یال برسیم.
</p><p>اول از همه توجه کنید که بعد از حذف هر مسیر تنها زوجیت درجه دو سر مسیر تغییر می کند همچنین در انتها درجه تمام راس ها زوج (صفر) خواهد بود. پس یک راس درجه فرد باید فرد بار و یک راس درجه زوج باید زوج بار به عنوان یک سر مسیر انتخاب شود. پس اگر تعداد راس های درجه فرد درخت $ X $ باشد آنگاه حداقل $ \frac X 2 $ مسیر نیاز داریم. (می دانیم که تعداد راس های درجه فرد هر گرافی زوج است پس $ X $ زوج است). 
</p><p>حالا اگر در هر مرحله مسیر بین دو راس درجه فرد را حذف کنیم می توانیم به حالت بهینه برسیم! فقط باید توجه داشته باشیم که دو راس درجه فرد ما مربوط به یک مولفه همبندی باشد.
</p><p>حالا سوالی که پیش می آید این است که درخت بودن طی این فرایند به ما چه کمکی کرد؟
</p><p>در نهایت ما از این موضوع استفاده کردیم که اگر درختی راس درجه فرد نداشته باشد یالی ندارد (اما این قضیه در گراف به صورت کلی برقرار نیست). چرا که اگر تعداد راس های گراف حداقل دو باشد در اینصورت برگی خواهد داشت که درجه آن 1 (و فرد) است.
</p><h2>پوشاندن یال های درخت با مسیر ها</h2><p>در ابن قسمت می خواهیم کمترین تعداد مسیر را پیدا کنیم که اجتماع آن ها کل یال های $ T $ را شامل شود. این مسئله مشابه حالت قبل است با این تفاوت که در حالت قبل یال ها را به مسیر ها افراز می کردیم یعنی هر یال متعلق به یک مسیر بود. در اینجا این آزادی را داریم که یک مسیر چند بار یالی را بپوشاند. می توان نتیجه گرفت که جواب این مسئله کمتر از مسئله قبل است.
</p><p>در نگاه اول متوجه می شوید که چون طولانی کردن مسیر ها ضرری با ما نمی زند پس حالت بهینه ای وجود دارد که دو سر هر مسیر برگ باشد!
</p><p>از طرف دیگر به ازای هر برگ یالی که از این برگ به راس مجاورش می رود را در نظر بگیرید. هر مسیر حداکثر 2 تا از این یال ها را می پوشاند. پس اگر $ X $ تا برگ داشته باشیم حداقل $ \frac X 2 $ تا مسیر نیاز داریم حالا تلاش می کنیم تا این کران را بر آورده کنیم. یعنی اگر $ X $ زوج باشد با $ \frac X 2 $ مسیر و اگر $ X $ فرد بود با $ \frac {X+1} 2 $ مسیر یال های درخت را بپوشانیم.
</p><p>پس سعی می کنیم در هر مرحله پس از انتخاب مسیر درختمان را به درختی تبدیل کنیم که تعداد برگ هایش دو تا کمتر است(البته در حالتی که $ X $ فرد باشد مرحله آخر نمی توانیم اینکار را بکنیم). اگر بتوانیم این کار را بکنیم تعداد مسیر هایی که انتخاب کردیم نصف تعداد برگ ها خواهد بود همانطور که می خواستیم.
</p><p>دو برگ دلخواه مثل $ u,v $ را در نظر بگیرید و درخت را از این مسیر آویزان کنید. ابتدا این مسیر را انتخاب کنید (که یال های بین $ u,v $ را بپوشاند). فرض کنید راس های مسیر ما $ a_1,...,a_k $ باشد حالا درختی می سازیم که به جای $ a_1,...,a_k $ یک راس دارد! بین این راس و یک راس مثل $ w $ یال است اگر و تنها اگر بین $ w $ و یکی از $ a_1,...,a_k $ یال باشد.‌ (به صورت شهودی مثل این است که کل راس های مسیر را فشرده کردیم و به یک راس تبدیل کردیم). حالا هر مسیر در گراف جدیدمان معادل با یک مسیر در گراف اولیه است و الان تنها کافیست کل یال ها در درخت جدید را با مسیر ها بپوشانیم! 
</p><img src="/_static/dot/Tree_to_Path_1.svg"><img src="/_static/dot/Tree_to_Path_2.svg"><p>پس در هر مرحله یک مسیر که دو سر آن برگ است را فشرده می کنیم و به صورت یک راس در می آوریم. در هر مرحله تعداد برگ های گراف جدیدمان دو تا کم می شود مگر اینکه راسی که جدید اضافه کردیم (راس فشرده) برگ باشد. در صورتی این اتفاق می افتد که راس های مسیر بین $ u,v $ همه درجه 2 باشند به جز یکی از آنها که باید درجه 3 باشد. به $ u,v $ که مسیر بین آن چنین خاصیتی داشته باشد یک زوج ناسازگار می گوییم.
</p><p>پس اگر بتوانیم در هر مرحله دو برگ $ u,v $ را طوری انتخاب کنیم که زوج ناسازگار نباشند این کار را می کنیم (‌که پس از فشرده سازی از تعداد برگ ها 2 تا کم می کند). اگر نتوانستیم اینکار را بکنیم چه؟ در اینصورت ادعا می کنیم تنها یک راس درجه 3 داریم و باقی راس ها دارای درجه 1 یا 2 هستند (چرا؟). در اینصورت همانطور که در شکل می بینید درخت ما دقیقا 3 برگ خواهد داشت و می توانیم آن را با 2 مسیر بپوشانیم.
</p><img src="/_static/dot/Tree_to_Path_3.svg"><h2>درخت چپانی</h2><p>فرض کنید درختی $ n $ راسی به نام $ T $ داریم. همچنین گرافی مثل $ G $ داریم که $ \delta(G) \geq n-1 $. می خواهیم ثابت کنیم زیرمجموعه ای از یال های $ G $ وجود دارد که $ T $ را بسازد. (به صورت شهودی یک درخت $ T $ در گراف $ G $ بتوان پیدا کرد).
</p><p>یک برگ دلخواه مثل $ u $ که تنها مجاور آن $ v $ است را در نظر بگیرید و $ u $ را از درخت حذف کنید! سپس به صورت استقرایی درخت $ T-u $ را در $ G $ پیدا کنید. حالا می خواهیم یال $ uv $ را به درختمان اضافه کنیم. فرض کنید راس $ v $ در گراف $ G $ متناظر با $ v^{\prime} $ شده باشد. حالا کافیست از بین مجاور های $ v^{\prime} $ راسی را انتخاب کنید که قبلا با هیچ راس درخت متناظر نشده است. سپس می توان این راس را متناظر با $ u $ قرار داد که فرض استقرای ما را ثابت می کند.
</p><p>برای یافتن چنین راسی کافیست از فرض $ \delta(G) \geq n-1 $ استفاده کنیم. پس $ v^{\prime} $ حداقل $ n-1 $ مجاور دارد و حداکثر $ n-2 $ تا از آن ها قبلا به راس های درخت متناظر شده اند. پس یکی از مجاور های $ v $ تا حالا به راس های درخت متناظر نشده که حالا می توانیم همانطور که گفتیم $ u $ را به آن متناظر کنیم.
</p><p>این مسئله به منظور آشنایی شما با ساختار استقرا پذیر درخت مطرح شد. دیدید که چطور می توان یک برگ از درخت را حذف کرد و فرض استقرا را برای درخت باقی مانده به کار برد.
</p><h1>شمردن تعداد درخت ها</h1><p>شمردن تعداد درخت های $ n $ راسی یکی از مسائل بسیار جذاب ترکیبیات هستند و راه های متنوع و خلاقانه ای برای آن وجود دارد. در این قسمت موضوع بحث درخت هایی با راس های برچسب دار هستند. (می توانید آنها را به صورت تعداد زیردرخت های فراگیر گراف $ K_n $ در نظر بگیرید). در واقع به چندین روش اثبات خواهیم کرد که تعداد درخت های $ n $ راسی برابر با $ n^{n-2} $ است. قبل از خواندن راه حل هر بخش راهنمایی ها را بخوانید و سعی کنید خودتان راه حلی ارائه دهید.
</p><h2>شمردن با دنباله درجه ای</h2><h3>راهنمایی</h3><p>رابطه ای ارائه دهید که تعداد درخت های با دنباله درجه ای $ d_1, d_2, ..., d_n $ را بشمارد. برای اثبات این رابطه به صورت استقرایی برگ حذف می کنیم!
</p><h3>حل</h3><p>رابطه مورد نظر برابر است با 
$ \frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_n-1)!} $
. توجه کنید که
$ \sum d_i-1 $
برابر با همان $ n-2 $ است پس عبارت بالا در واقع یک ترکیب با تکرار است!
</p><p>برای اثبات رابطه از استقرا روی $ n $ استفاده کنید. به عنوان پایه در نظر داشته باشید که به ازای $ n \leq 2 $ رابطه برقرار است. حالا کافیست تنها یک برگ خاص را در نظر بگیرید (راسی مثل $ u $ که $ d_u = 1 $ است). سپس حالت بندی کنید که تنها مجاور این راس چه راسی باشد.‌ اگر تنها مجاور راس $ u $ راس $ v $ باشد (توجه کنید چون $ n > 2 $ می توان نتیجه گرفت $ v $ نباید برگ باشد) آنگاه تعداد درخت های ممکن در این حالت برابر است با 
$ \frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_v-2)! (d_n-1)!} $
. همانطور که گفتیم عبارت بالا شبیه به یک ترکیب با تکرار است. طبق اتحاد تعمیم اتحاد پاسکال جمع عبارات (بعد از حالت بندی ها) برابر با 
$ \frac {(n-2)!} {(d_1-1)! \times (d_2-1)! \times ... (d_n-1)!} $
خواهد شد. همانطور که می خواستیم.
</p><p>حالا توجه کنید که عبارت بالا در واقع تعداد رشته های متفاوتی را می شمارد که از حرف $ i $ به تعداد $ d_i-1 $ بار در آن آمده است. پس مثل این است که هر درخت را به یک دنباله $ n-2 $ تایی از اعداد $ 1 $ تا $ n $ نسبت دادیم. پس اگر به ازای همه $ d_1,d_2,...,d_n $ های ممکن عبارت را جمع کنیم حاصل برابر با $ n^{n-2} $ خواهد شد که تعداد کل درخت های متفاوت $ n $ راسی است.
</p><h2>کد پروفر</h2><h3>راهنمایی</h3><p>تناظری یک به یک از درخت های $ n $ راسی به دنباله های $ n-2 $ تایی از اعداد $ 1 $ تا $ n $ ایجاد می کنیم.
</p><h3>حل</h3><p>تابع تناظر ما به اینصورت عمل می کند که در ابتدا درخت $ T $ را در نظر می گیریم و تا زمانی که تعداد راس های آن بیشتر از 2 است هر بار برگ $ u $ که برچسب آن کمینه است را حذف می کنیم. سپس برچسب تنها راس مجاور $ u $ را در روی کاغذ می نویسیم. در انتها $ n-2 $ عددی که روی کاغذ نوشتیم را به ترتیب نوشتن در نظر بگیرید. آن ها دنباله $ n-2 $ ما را تشکیل می دهند.
</p><p>برای اثبات یک به یک بودن تناظر باید ثابت کنیم هر دنباله $ n-2 $ تایی از اعداد $ 1 $ تا $ n $ به صورت یکتایی به درخت های $ n $ راسی متناظر شده اند. دنباله $ s_1,s_2,...,s_{n-2} $ را در نظر بگیرید. می خواهیم درختی که به آن تناظر داده شده است را پیدا کنیم.
</p><p>اول از همه توجه کنید که در فرایند تناظر دادن ما راس $ i $ دقیقا $ d_i-1 $ بار در رشته ظاهر شده است(چرا؟).
</p><p>پس اعدادی که در بین $ s_1,s_2,...,s_{n-2} $ ظاهر نشده اند باید برگ های درخت باشند. در فرایند تناظر در اولین گام برگی که برچسب آن کمینه بود را حذف کردیم. پس کمترین عددی که در بین $ s_1,s_2,...,s_{n-2} $ ظاهر نشده است را $ u $ بنامید. ابتدا باید $ u $ حذف شده باشد و تنها مجاور $ u $ راس $ s_1 $ می باشد. حالا به صورت استقرایی می توان درخت متناظر با $ s_2,...,s_{n-2} $ را به صورت یافت. سپس یال بین $ u,s_1 $ را به درخت اضافه می کنیم و درخت متناظر با $ s_1,s_2,...,s_{n-2} $ به دست خواهد آمد.
</p><h2>تناظر به گراف تابعی</h2><h3>راهنمایی</h3><p>درخت دو رنگ را درختی تعریف می کنیم که راس $ A $ در آن به رنگ آبی در آمده و رنگ $ B $ به رنگ قرمز (حتی ممکن است $ A, B $ یک راس باشند).
</p><p>واضح است که به ازای هر درخت $ n $ راسی دقیقا $ n^2 $ درخت دورنگ داریم پس اگر $ c $ تا درخت $ n $ راسی داشته باشیم آنگاه $ c \times n^2 $ تا درخت دورنگ $ n $ راسی داریم.
</p><p>در این قسمت تناظری یک به یک بین گراف های تابعی $ n $ راسی (که تعداد آن ها $ n^n $ تا است) و درخت های دو رنگ ایجاد می کنیم.
</p><h3>حل</h3><p>گراف تابعی را در نظر بگیرید. همانطور که می دانید در هر گراف تابعی از هر مولفه همبندی (در گراف زمینه) از یک دور جهت دار تشکیل شده است که از هر راس آن یک درخت آویزان است. شهودا برای تبدیل این گراف تابعی به درخت کافیست یک یال از هر دور را حذف کنیم سپس مولفه های همبندی گراف تابعی را به هم وصل کنیم تا تبدیل به درخت شود اما باید طوری این فرایند را انجام دهیم که تناظر یک به یک باشد و بتوان از روی درخت دو رنگ فهمید کدام یال حذف شده است!
</p><p>فرض کنید به ازای هر مولفه همبندی گراف تابعی (در گراف زمینه) کمترین برچسب در دور آن را زیبایی مولفه می نامیم و راسی که این برچسب کمینه را دارد راس زیبای مولفه بنامید. حالا برای تناظر فرایند زیر را انجام دهید.
</p><ul><li><p>مولفه ها طوری چپ به راس مرتب کنید که زیبایی مولفه ها از چپ به راست <b>نزولی</b> باشد.
</p></li><li><p>در هر کدام از مولفه ها فرض کنید دور آن $ p_1,p_2,...,p_k $ باشد به طوریکه $ p_1 $ راس زیبای مولفه باشد. ابتدا یال $ p_kp_1 $ را حذف کنید. سپس $ p_k $ را به راس زیبای مولفه بعدی (در سمت راست) وصل کنید.
</p></li><li><p>راس $ p_1 $ در چپ ترین مولفه را آبی کنید و راس $ p_k $ در راست ترین مولفه را قرمز کنید. سپس جهت دهی یال ها را از بین ببرید.
</p></li></ul><p>به این صورت از گراف تابعی که داشتیم یک درخت دو رنگ ساختیم.
</p><p>چرا زیبایی مولفه را <b>کوچکترین</b> راس دور تعریف کردیم و چرا مولفه ها را طوری مرتب کردیم که زیبایی ها <b>نزولی</b> باشد؟ دلیل این کار تنها این بود که مسیر راس آبی به قرمز این ویژگی را داشته باشد که به آن ویژگی جذاب می گوییم.
</p><p><b>ویژگی جذاب</b> : ابتدا توجه کنید که هر کدام از دور های گراف تابعی در واقع الان یک بازه از مسیر بین راس آبی و قرمز هستند. از راس آبی شروع کنید و به سمت راس قرمز بروید و برچسب ها را نگاه کنید. فرض کنید الان روی راس $ u $ هستیم و کمترین برچسبی که قبل از $ u $ در طول مسیر دیده ایم $ X $ باشد. اگر $ u<X $ باشد (یا به عبارتی $ X $ بعد از این مرحله کم شود) به این معنی است که وارد راسی شدیم که متعلق به یک دور دیگر (از گراف تابعی) بوده است(چرا؟)!
</p><p>برای اینکه ثابت کنیم تناظر برگشت پذیر است باید از روی یک درخت دو رنگ بتوانیم به صورت یکتا گراف تابعی را بسازیم.
</p><p>همانطور که گفتیم راس آبی را $ A $ در نظر بگیرید و راس قرمز را $ B $ در نظر بگیرید.
</p><p>مراحل تناظر را یکی یکی به عقب بر می گردانیم تا به گراف تابعی برسیم. اول از همه درخت را از مسیر $ A $ به $ B $ آویزان کنید. راس $ A $ را در سمت چپ در نظر بگیرید و راس $ B $ را در سمت راست در نظر بگیرید. 
</p><ul><li><p>مسیر $ AB $ باید از چپ به راست جهت دهی شده باشد.
</p></li><li><p>سپس تمام درخت هایی که از رئوس مسیر $ AB $ آویزان شده اند باید از پایین به بالا جهت دهی شده باشند (هر راس به پدرش یال دارد).
</p></li><li><p>در اینجا از <b>ویژگی جذاب</b> که در بالا گفتیم استفاده می کنیم. با طی کردن مسیر از $ A $ به $ B $ می توانیم مسیر را به بازه هایی افراز کنیم که قبلا (در گراف تابعی) متعلق به یک مولفه بوده اند. حالا می دانیم که هر کدام از بازه ها قبلا یک دور بوده اند که راس های آن به ترتیب $ p_1,...,p_k $ بوده اند و یال $ p_kp_1 $ حذف شده است. پس کافیست یک یال از راس آخر بازه (که همان $ p_k $ است) به راس اول بازه (که همان $ p_1 $ است) بکشیم.
</p></li></ul><p>پس توانستیم با معکوس تابع تناظر از هر درخت دو رنگ به یک گراف تابعی برسیم. پس توانستیم یک به یک بودن تناظر را ثابت کنیم. 
</p><h2>شمردن انشعاب ها</h2><h3>راهنمایی</h3><p>سعی می کنیم تعداد انشعاب ها (درخت های ریشه دار که هر راس به جز ریشه به پدرش یال جهت دار دارد) بشماریم همچینین فرض کنید یال های درخت هم دارای ترتیب هستند یعنی جایگشتی $ n-1 $ تایی روی یال های درخت نوشته ایم.
</p><p>در اینصورت اگر تعداد انشعاب هایی که شمردیم (با احتساب ترتیب یال ها) برابر با $ T $ باشد آنگاه تعداد درخت ها برابر با $ \frac {T} {(n-1)! \times n} $ خواهد بود. به عبارتی هر درخت را $ (n-1)! \times n $ بار می شماریم. ضریب $ n $ به خاطر حالت بندی روی ریشه درخت است و $ (n-1)! $ به خاطر حالت بندی روی جایگشت نوشته شده روی یال های درخت می باشد.
</p><h3>حل</h3><p>سعی می کنیم $ T $ را محاسبه کنیم. یک انشعاب خاص را در نظر بگیرید و فرایند ساختن آن را به شکل زیر در نظر بگیرید‌ :
</p><ul><li><p>ابتدا گرافی $ n $ راسی و بدون یال در نظر بگیرید. یال ها را یکی یکی اضافه می کنیم. پس در هر مرحله تعدادی درخت جهت دار خواهیم داشت.
</p></li><li><p>در مرحله $ i $ ام یالی که روی آن عدد $ i $ نوشته شده را در نظر بگیرید. فرض کنید $ uv $ باشد.
</p></li><li><p>در اینصورت لازم و کافی است که در هر مرحله $ u, v $ مربوط به دو مولفه متفاوت باشند و همچنین $ v $ راسی باشد که ریشه یکی از درخت های جهت دار ما است.
</p></li></ul><p>برای شمردن تعداد انشعاب های ممکن کافی است بفهمیم فرایند ساختن انشعاب چند حالت مختلف می تواند داشته باشد.
</p><p>در شروع مرحله $ i $ (با شمارش از 1) دقیقا $ n-i+1 $ درخت ریشه دار داریم. اگر روی $ u $ حالت بندی کنید (که $ n $ حالت دارد) برای انتخاب $ v $ دقیقا $ n-i $ حالت داریم زیرا که $ v $ باید ریشه یکی از درخت ها باشد و نباید ریشه درختی باشد که $ u $ در آن است. بنابراین مرحله $ i $ ام فرایند ساختن گراف $ n \times (n-i) $ حالت دارد. پس در نهایت داریم 
$ T = n^{n-1} * (n-1)! $
</p><p>پس همانطور که گفتیم تعداد درخت ها باید برابر با $ \frac {T} {(n-1)! \times n} $ باشد که همان $ n^{n-2} $ است. همانطور که می خواستیم!
</p><h1>DFS</h1><p>الگوریتم dfs یکی از روش های پیمایش گراف است و یکی از ساده ترین و پایه ای ترین الگوریتم های گراف می باشد. این الگوریتم در عین سادگی ویژگی های جالبی دارد و برخلاف تصور در حل مسائل تئوری و عملی کاربرد فراوان دارد!
</p><h2>اولین مسئله</h2><p>فرض کنید در یک هزارتو گیر کرده اید که به صورت یک گراف است. یعنی در هر راس گراف یک اتاق قرار دارد و هر یال نشان دهنده یک راهرو بین دو اتاق است. همچنین حافظه شما به قدری قوی است که می توانید اگر به یک اتاق تکراری رفتید تشخیص بدهید که این اتاق تکراری است و هنگامی که در یک اتاق هستید تنها می توانید راهرو های مجاور آن را ببینید. همچنین یک نخ به همراه دارید که یک سر آن به اتاقی که اول کار در آن قرار دارید بسته شده است و سر دیگر در دستان شماست. در یکی از راس های گراف گنجی قرار دارد. هدف شما این است که گنج را بیابید. چگونه این کار را انجام می دهید؟
</p><p>پیدا کردن گنج به سادگی انجام الگوریتم زیر است. تا زمانی که به گنج نرسیدیم الگوریتم زیر را انجام دهید :
</p><ul><li><p>اگر همه اتاق های مجاور تکراری بودند به اتاقی برو که برای اولین بار از آن به اتاق فعلی آمده ای. (کافی است نخی که دستمان است را دنبال کنیم). 
</p></li><li><p>در غیراینصورت به یکی از اتاق های مجاور که تکراری نیست برو.
</p></li></ul><p>چرا این الگوریتم مسئله ما را حل می کند؟ نکته اینجاست که زمانی که ما برای اولین بار در یک اتاق قرار می گیریم تمام تلاشمان را می کنیم که از آن اتاق مسیری به گنج پیدا کنیم. در نتیجه وقتی که همه اتاق های مجاور تکراری می شوند و ما نخ را دنبال کرده و بر می گردیم می توان نتیجه گرفت که هیچ مسیری از آن اتاق به گنج وجود ندارد. در نتیجه هیچ گاه دیگر نباید وارد این اتاق شویم. (و این منطق که نباید وارد اتاق تکراری شویم نیز از همینجا ناشی می شود).
</p><p>می توان با یک دید متفاوت تر هم به مسئله نگاه کرد. به ازای هر یال $ uv $ اگر یکی از $ u,v $ را ببینیم قطعا دیگری را نیز خواهیم دید. (زیرا زمانی کارمان با یک راس تمام می شود که تمام مجاور های آن تکراری باشند). در نتیجه اگر یک راس از مولفه همبندی را ببینیم تمام راس های دیگر آن را نیز خواهیم دید.
</p><h2>مولفه های همبندی</h2><p>گراف $ G $ به شما ورودی داده شده است. شما باید تعداد مولفه های همبندی این گراف را بیابید.
</p><p>آنچه در این قسمت بررسی می کنیم تصویری کلی از الگوریتم dfs است. فرض کنید آرایه mark نشان می دهد که چه راس هایی قبلا دیده شده اند و در ابتدای کار تمام خانه های آن false است. حالا الگوریتم ما به اینصورت خواهد بود :
</p><pre dir="ltr">cpp
void dfs(int u){
   mark[u] = true;
   for(int y : g[u])
     if(mark[y] == false)
           dfs(y);
}</pre><p>از شهودی که با حل مسئله بالا به دست آوردیم استفاده کنید. وقتی dfs(u) صدا زده می شود الگوریتم تلاش می کند که به صورت بازگشتی تمام راس هایی که با $ u $ می توان به آن رسید را ببیند سپس dfs(u) به اتمام می رسد و به راسی به نام $ par $ بر می گردیم که از آن برای اولین بار به $ u $ رسیده بودیم.
</p><p>در نتیجه می توان دید که پس از اجرای این تابع تمام راس هایی که در مولفه همبندی راس شروع قرار دارند دیده می شوند. پس برای حل مسئله کافیست در هر مرحله راسی مثل $ y $ را انتخاب کنیم که mark آن false باشد. سپس dfs(y) را اجرا کرده و به جواب مسئله یکی اضافه کنیم.
</p><h2>درخت dfs</h2><p>الگوریتم dfs علاوه بر اینکه گراف ما را پیمایش می کند این پیمایش را به صورت خاصی انجام می دهد! حالا با برخی از ویژگی های جالب این پیمایش آشنا می شویم.
</p><p>فرض کنید یال های گراف در ابتدا آبی هستند. حالا هر گاه که برنامه در راس $ v $ بود و با طی کردن یال $ uv $ به راس جدید $ u $ می رسید یال $ uv $ را قرمز کنید.
</p><p>در ابتدا توجه کنید که یال های قرمز تشکیل یک درخت می دهند! زیرا هر بار که یک یال قرمز می شود یک سر آن متصل یه راسی است که قبلا ندیده بودیم. پس مثل این است که یکی یکی به این درخت برگ اضافه می کنیم! به این درخت به دست آمده از الگوریتم
dfs،
درخت dfs می گوییم. ویژگی جالب dfs این است که وقتی اجرای
dfs(u)
شروع می شود راس
$ u $
در درخت قرمز ها تنها یک برگ است و زمانی که اجرای dfs(u) به پایان می رسد زیردرخت
$ u $
به طور کامل ساخته شده است.
پس می بینید که پس از اجرای الگوریتم dfs روی یک گراف همبند، یک درخت فراگیر از این گراف را به دست خواهیم آورد. این درخت فراگیر را از راس شروع ریشه دار کنید.
</p><p>حالا به ویژگی جالبی که روی یال های آبی به دست می آید توجه کنید.
</p><p>به یال $ uv $ بک اج (back edge) می گوییم اگر یکی از $ u,v $ جد دیگری باشد. در غیراینصورت به این یال کراس اج (cross edge) می گوییم. البته
ممکن است بعضا یک دسته تری ادج (tree edge) در نظر بگیرند و یال های خود درخت را تری ادج و یال های دیگر را بک ادج در نظر بگیرند اما ما در اینجا
همه را بک ادج در نظر می گیریم و به این دو دسته اکتفا می کنیم.
</p><p>ادعا می کنیم برای هر درخت dfs تمام یال های گراف بک اج هستند!
</p><img src="/_static/dot/Back_Edge.svg"><p>برای اثبات اینکه تمام یال ها بعد از پیمایش
dfs
بک اج هستند یک یال
$ uv $
دلخواه را در نظر بگیرید. بدون کم شدن از کلیت مسئله فرض کنید در الگوریتم ابتدا به راس
$ u $ وارد شده ایم. در اینصورت موقع شروع dfs(u) راس $ v $ هنوز دیده نشده است. همچنین زمانی که dfs(u) به پایان می رسد راس $ v $ باید دیده شده باشد (زیرا مجاور راس $ u $ است). بنابراین اگر درخت dfs را در نظر بگیرید راس $ v $ باید درون زیردرخت $ u $ باشد! در نتیجه $ u $ جد $ v $ است پس یال $ uv $ بک اج خواهد بود.
</p><p>در آینده از این قضیه که بعد از اجرای dfs تمام یال ها بک اج هستند استفاده های بسیاری خواهیم کرد!
</p><h2>مسیر ماکسیمال و dfs</h2><p>در فصل 1 با اثبات هایی که توسط مسیر ماکسیمال انجام می شد آشنا شدیم. در اینجا یاد می گیریم که می توان به جای استفاده از مسیر ماکسیمال از برگ های درخت dfs استفاده کرد(که شهود بسیار قوی تری ایجاد می کند)!
</p><p>بعد از dfs زدن روی درخت، تعداد بک اج هایی که
$ u $
راس پایین آن است را
$ back_u $
می نامیم. توجه کنید که یال های درخت dfs هم طبق تعریف ما بک اج محسوب می شوند. همچنین ارتفاع راس $ u $ در درخت را $ h_u $ می نامیم.
</p><p>دو قضیه زیر به راحتی از ساختار خاص درخت نتیجه می شوند (قضیه دوم با فرض ساده بودن گراف برقرار است).
</p><ul><li><p>$ \sum back_u = m $
</p></li><li><p>$ \forall_u back_u \leq h_u $
</p></li></ul><h3>مسیر به طول :math:`\delta`</h3><p>ثابت می کنیم که یک گراف ساده مسیری به طول حداقل $ \delta $ دارد. کافیست ثابت کنیم ارتفاع درخت dfs حداقل $ \delta $ است. یک برگ دلخواه مثل $ u $ را در نظر بگیرید. واضح است که $ back_u \geq \delta $ در نتیجه $ h_u \geq \delta $ که حکم ما را به سادگی نتیجه می دهد!
</p><h3>مسیر به طول :math:`\frac m n`</h3><p>ثابت می کنیم که یک گراف ساده مسیری به طول حداقل $ \frac m n $ دارد. مثل بالا ثابت می کنیم ارتفاع درخت dfs حداقل $ \frac m n $ است. برای اثبات از برهان خلف استفاده می کنیم. فرض کنید ارتفاع هر راس کمتر از $ \frac m n $ باشد. داریم :
$ m = \sum back_u \leq \sum h_u < n \times \frac m n = m \Rightarrow m < m $
</p><p>که به ما تناقض می دهد. در نتیجه راسی با ارتفاع حداقل $ \frac m n $ وجود دارد که حکم مسئله ما را ثابت می کند.
</p><h3>برگ ها و ارتفاع، مجموعه مستقل و طولانی ترین مسیر!</h3><p>فرض کنید بعد از اعمال الگوریتم dfs ارتفاع درخت برابر با $ H $ شود(در واقع $ H $ بیشینه مقدار بین $ h_u $ ها است). همچنین فرض کنید تعداد برگ ها $ S $ باشد.
</p><p>در اینجا ثابت می کنیم که $ H \times S \geq n-1 $.
</p><p>به ازای هر برگ درخت مسیر این راس تا ریشه را طی کنید و روی هر راس این مسیر به جز ریشه یک سنگ قرار دهید. در اینصورت به ازای هر برگ مثل $ u $ به تعداد کل سنگ ها $ h_u $ تا اضافه می شود. از طرفی روی هر راس به جز ریشه حداقل یک سنگ قرار دادیم در نتیجه تعداد کل سنگ ها حداقل $ n-1 $ می باشد. پس می توان نوشت :
</p><p>$ n-1 \leq \sum h_u \leq H \times S $
</p><p>که حکم ما را ثابت می کند. اما تا الان از ویژگی خاصی که توسط درخت dfs به دست بیاید استفاده نکردیم! نکته جالب این است که برگ های درخت dfs تشکیل یک مجموعه مستقل می دهند. (زیرا وجود یال بین دو برگ موجب ایجاد کراس اج می شود).
</p><p>در نتیجه اگر اندازه مجموعه مستقل بیشینه $ S^{\prime} $ باشد در اینصورت $ S \leq S^{\prime} $ برقرار است.
</p><p>همینطور اگر اندازه طولانی ترین مسیر این گراف $ H^{\prime} $ باشد در اینصورت $ H \leq H^{\prime} $ برقرار است.
</p><p>پس حالا توانستیم به نامساوی جالب $ n-1 \leq H \times S \leq H^{\prime} \times S^{\prime} $ برسیم!
</p><p>نکته جالب این است که هر دو مسئله پیدا کردن مچموعه مستقل با بیشترین بیشینه و طولانی ترین مسیر در گراف np هستند! اما با روشی که ارائه دادیم می توانیم یا یک مجموعه مستقل به اندازه حداقل $ \sqrt{n-1} $ یا یک مسیر به اندازه حداقل $ \sqrt{n-1} $ ارائه دهیم!
</p><h3>راس نابرشی</h3><p>ثابت می کنیم هر گراف با $ n > 1 $ حداقل دو راس نابرشی دارد.
</p><p>کافیست روی گراف dfs بزنید. سپس هر کدام از برگ های درخت dfs یک راس نابرشی خواهند بود (همچنین اگر این دو راس را با هم نیز حذف کنیم گراف ناهمبند نمی شود). زیرا که یال های درخت dfs بقیه گراف را همبند نگه می دارد (و حذف برگ از یک درخت همبندی آن را خراب نمی کند). همچنین هر درخت با $ n>1 $ حداقل دو برگ دارد که حکم ما را ثابت می کند. البته در این مسئله نیازی به استفاده از درخت dfs نبود و هر درخت فراگیر دلخواهی مسئله را برای ما حل می کرد.
</p><h2>پیمایش درخت</h2><p>یکی از حالات خاص مسئله پیمایش گراف، پیمایش درخت ها است. در این قسمت می بینیم که پیمایش درخت ها می تواند با الگوریتم dfs به صورت ساده تر انجام شود. مثلا دیگر به آرایه mark نیازی نداریم. زیرا تنها مجاور یک راس که قبلا دیده شده است پدر این راس می باشد.
</p><p>همچنین می توان همزمان به اجرای dfs اطلاعات دیگری نیز درباره درخت به دست آورد. به عنوان مثال در کد زیر بعد از اجرای dfs روی درخت تعداد راس های زیردرخت هر راس در آرایه sz، و ارتفاع هر راس در آرایه h ذخیره سازی می شوند.
</p><p>توجه کنید که فرض کردیم اندیس راس های درخت از 1 شروع می شوند و راس با اندیس 0 نداریم.
</p><pre dir="ltr">cpp
const int maxn = 1e5 + 10;
vector &lt;int&gt; g[maxn];
int sz[maxn], h[maxn];
void dfs(int u, int par = 0){
   h[u] = h[par] + 1;
   sz[u] = 1;
   for(int y : g[u]){
if(y != par){
           dfs(y, u);
           sz[u] += sz[y];
       }
   }
}</pre><h1>﻿BFS</h1><p>در این بخش به معرفی الگوریتم bfs که یک راه برای پیمایش گراف است و همچنین خاصیت های آن میپردازیم.
</p><h2>الگوریتم bfs </h2><p>ابتدا یک راس را مشخص میکنیم (نام ان را root میگزاریم) و آن را در گروه $ A_0 $ میگزاریم سپس تمام همسایه های ان را در گروه $ A_1 $ میگزاریم و
در $ A_2 $ تمام همسایه های گروه های $ A_0 $ و $ A_1 $ را میگزاریم که تا الان در هیچ گروهی نیامد اند و به همین شکل در گروه $ A_i $ تمام 
راس هایی که همسایه راس های گروه های $ A_j $ که $ 0 \leqslant j < i $ است و در آن ها  نیامده قرار میدهیم.
</p><p>فرض کنید $ Dis_i $ برابر شماره گروهی است که $ i $ در آن امده است(برای مثال $ Dis_{root} = 0 $ است).
واضح است در این روش تمام راس هایی که در مولفه همبندی root است در گروه ها می ایند پس برای راحتی کار فرض میکنیم گراف همبند است ولی هر چه میگوییم در واقع برای مولفه همبندی root درست است.
</p><p>ابتدا ثابت میکنیم برای دو راس $ i,j $ که به هم یال دارند $ 1 $  $ \leqslant $  $ |Dis_{i}-Dis_{j}| $.
</p><p>اثبات:برهان خلف میزنیم،فرض کنید دو راس $ i,j $ است که همسایه هم هستند و $ Dis_{j} - Dis_{i} > 1 $. حال زمانی را در نظر بگیرید که داشتیم گروه 
$ A_{Dis_{i}+1} $ را  پر میکردیم ، آن لحظه $ j $ در هیچ گروهی نیامده بود و همسایه $ i $ بود پس در گروه $ A_{Dis_{i}+1} $
بود و با تناقض بدست امده قضیه ثابت شد.
پس میتوانیم فرض کنیم در گروه $ A_i $ تمام 
راس هایی که همسایه راس های گروه های $ A_{i-1} $ و در آن نیامده قرار میدهیم.
</p><img src="/_static/dot/BFS_Groups.svg"><img src="/_static/dot/BFS_Graph.svg"><p>حال ثابت میکنیم $ Dis_{i} $ = $ dis(i,root) $.
</p><p>اثبات:برهان خلف میزنیم ، راسی که کمترین مقدار Dis را دارد و حکم ما برای آن برقرار نیست(نام آن را i میگزاریم)
حال همسایه i را در مسیری به root که تعداد یال های آن مسیر برابر $ dis(root,i) $ است در نظر بگیرید.(با نام j)
چون راس i کمترین Dis را بین راس هایی که حکم را نقض میکردند داشت پس j حکم را نقض نمیکرد پس:
</p><ul><li><p>$ Dis_{j}=dis(root,i)-1 $
</p></li><li><p>و چون $ Dis_{i} > Dis_{j} $ و $ 1 $ $ \leqslant $ $ |Dis_{i}-Dis_{j}| $ پس:
</p></li><li><p>$ Dis_{i} = Dis_{j}+1 $
</p></li></ul><p>و با تناقض بدست امده قضیه اثبات شد.
</p><p>حال الگوریتم را کمی تغییر میدهیم و ثابت میکنیم باز همان کار را داریم انجام میدهیم :
</p><p>یک گروه جدید میسازیم با نام B که ابتدا راس root را در آن میگزاریم و سپس تا زمانی که B تهی نشده کار زیر را انجام میدهیم:
</p><p>راسی در B که کمترین مقدار Dis را دارد در نظر میگیریم(با نام i) i را از B حذف میکنیم سپس تمام همسایه های آن را که هنوز در هیچ A ای نبود را در گروه $ A_{Dis_i} + 1 $ میگزاریم و آن را داخل B میگزاریم.
این الگوریتم نیز مانند الگوریتم بالایی است فقط بجای آن که همه راس های $ A_i $ با هم در نظر بگیریم و همه همسایه های آن ها که تا بحال در گروهی نیامده در گروه بعدی بگزاریم
, روی راس های داخل گروه $ A_i $ را با ترتیبی که فرقی ندارد چه گونه است حرکت میکنیم و هر راس از گروه بعد در اولین زمانی که یک همسایه از آن در $ A_i $ را
دیدیم وارد $ A_{i+1} $ میشود.
واضح است وقتی یک راس وارد B میشود مقدار Dis آن از بقیه راس های داخل B بیشتر است پس اگر راس های داخل B را به ترتیب ورودشان در B نگه داریم عملا هر دفعه راس ته B را میگیریم آن را حذف میکنیم و راس های همسایه آن را که تابحال در B نیامده ان به سر اضافه میکنیم.
</p><h2>درخت bfs</h2><p>زمانی که الگوریتم bfs  به پایان میرسد را در نظر بگیرید(یعنی زمانی که هر راس مشخص شد در کدام گروه است). حال برای راس i ما $ par_i $ را به دلخواه یکی از همسایه های i مانند j به طوری که 
$ Dis_{i} = Dis_{j}+1 $ است در نظر میگیریم(واضح است par برای root تعریف نمیشود و برای هر راس دیگر هم قطعا تعریف میشود).سپس برای هر راس به غیر از root یال بین i و $ par_i $ را نگه میداریم و بقیه یال ها را حذف میکنیم. تعداد یال های باقی مانده n-1 است و هر راس نیز به root مسیر دارد(چرا؟). پس گراف جدید ما همبند است در نتیجه درخت است.
</p><img src="/_static/dot/BFS_Tree.svg"><p>در واقع درخت
bfs
را میتوان یک زیر درخت فراگیر در گراف در نظر گرفت که از
root
اویزان شده و دارای دو ویژگی زیر است :
</p><ul><li><p>برای هر راس مانند i $ dis(root,i) = h_i $ ($ h_i $ ارتفاع راس i وقتی که درخت را از root اویزان کردیم است).
</p></li><li><p>برای هر یال در <b>گراف اصلی</b> اختلاف ارتفاع دو سر آن حداکثر یک است.
</p></li></ul><p>علاوه از استفاده هایی که در برنامه نویسی از درخت bfs میشود و ممکن است در سوالی به درد شما بخورد درخت bfs در حل برخی مسائل تئوری نیز میتواند راه گشا باشد که در دو مثال زیر آن را نشان میدهیم.
</p><h2>کد bfs</h2><p>نحوه ورودی : ابتدا دو عدد n , m به ما داده میشود که به ترتیب بیانگر تعداد راس ها و تعداد یال های گراف است سپس در m خط بعدی دو عدد i , j میدهند
که نشان میدهد بین i , j در گراف یال وجود دارد.
</p><p>باید n عدد چاپ کنیم که عدد i برابر $ dis(1,i) $ است . تضمین شده گراف همبند است تا فاصله هر راس از 1 عددی حسابی باشد .
</p><p>راه حل :
</p><p>ما از queue که یک صف است در کد استفاده میکنیم queue دارای قابلیت های زیادی است ولی قابلیت های مورد استفاده ما در زیر امده :
</p><ul><li><p>$ queue<int>q $
</p></li><li><p>$ q.size( ) $ برابر تعداد عناصر داخل q است.
</p></li><li><p>$ q.front( ) $ مقدار عنصر ته  q
</p></li><li><p>$ q.pop( ) $ حذف عنصر ته q
</p></li><li><p>$ q.push(x) $ اضافه کردن x به q از سر آن
</p></li><li><p>queue در واقع برای ما نقش گروه B را ایفا میکند.
</p></li></ul><p>همچنین از ارایه Mark استفاده میکنیم که مقدار اولیه آن برای هر راس صفر است و اگه راسی وارد B  شود مقدار آن برای آن راس 1 میشود.
و از ارایه Dis هم استفاده میکنیم که برای هر راس جواب در آن ذخیره میشود.
</p><pre dir="ltr">cpp
const int maxn = 1e5 + 10;// hadeaksar meghdare n
int n, m;// tedad ras ha va tedad yal ha
int Dis[maxn];//javab har ras
bool Mark[maxn];//neshan midahad aya yek ras tabehal varede queue shode ya na
queue &lt;int&gt; q;// toozihe un neveshte shode
vector&lt;int&gt; adj[maxn] ;//list hamsaye haye har ras dar un neveshte shode
void bfs(int root){//fasele harki az root bedast khahad amad
    Dis[root] = 0; // dis(root , root) = 0
    Mark[root] = 1;
    q.push(root); 
    while(q.size()){//ta zamani ke dakhele q ras hast while ra edame bede
        int u = q.front();//rasi dar q ke kamtarin Dis ra darad
        q.pop(); //hazfe un
        for(int i = 0; i &lt; adj[u].size(); i++){//hamsaye haye i ra negah mikonim va agar ta be hal vared q nashodan vared mikonim
            int v = adj[u][i];
              if(!Mark[v]){
                  Mark[v] = 1;
                  Dis[v] = Dis[u] + 1;
                  q.push(v);
              }
        }
    }
}
int main(){
    cin &gt;&gt; n &gt;&gt; m ;
    for(int i = 1; i &lt;= m; i++){//list hamsaye haye ras ha ra por mikonim
        int u, v;
        cin &gt;&gt; u &gt;&gt; v ;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    bfs(1);//yani be ezaye root = 1 tabe bfs ra seda bezan
    for(int i = 1; i &lt;= n; i++)//chupe khrooji
       cout &lt;&lt; Dis[i] &lt;&lt; ' ';
}</pre><p>در این الگوریتم هر راس حداکثر یک بار وارد q میشود و هر یال هم به ازای هر سر حداکثر یک بار صدا میشود پس الگوریتم ما از $ O(n+m) $ است.
</p><h2>نتیجه گیری</h2><p>در این بخش به معرفی الگوریتم bfs و ویژگی های آن پرداختیم . از مهمترین کاربرد های های bfs میتولن به موارد زیر اشاره کرد.
</p><ul><li><p>پیدا کردن فاصله هر راس از راسی خاص
</p></li><li><p>پیدا کردن راس های داخل مولفه همبندی راسی خاص(در نتیجه تشخیص همبند بودن یا نبودن گراف)
</p></li><li><p>پیمایش گراف به منظوری خاص
</p></li><li><p>استفاده از مفهوم bfs و bfs tree در حل سوالات تئوری
</p></li></ul><p>توصیه میشود حتما برای فهم بیشتر  این بخش به تمرینات این بخش سر بزنید.
</p><h1>الگوریتم پیدا کردن قطر درخت</h1><p>یکی دیگر از مسائلی که در حالت کلی گراف np است اما در درخت ها به سادگی حل می شود مسئله پیدا کردن بلندترین مسیر است! از آنجایی که در درخت ها مسیر بین هر دو راس یکتا است می توان نتیجه گرفت قطر درخت همان بلندترین مسیر درخت می باشد. در این بخش روش های پیدا کردن قطر درخت را با پیچیدگی زمانی $ O(n) $ بررسی می کنیم.
</p><h2>استفاده از dp</h2><p>درخت را از راس 1 ریشه دار کنید. با استفاده از برنامه نویسی پویا دو متغیر زیر را به ازای هر راس $ u $ به دست می آوریم.
</p><ul><li><p>مقدار $ dp_u $ برابر است با بیشترین فاصله راس $ u $ با یک راس درون زیردرخت خود $ u $. 
</p></li><li><p>مقدار $ ans_u $ برابر است با اندازه قطر در زیردرخت $ u $.
</p></li></ul><p>واضح است که جواب مسئله برابر است با $ ans_1 $. حالا تنها مسئله باقی مانده این است که چگونه این دو متغیر را به دست آوریم.
</p><p>برای به دست آوردن $ dp_u $ کافی است توجه کنید که در اولین حرکت از $ u $ به یکی از بچه هایش می رویم. پس باید به بچه ای برویم که مقدار $ dp $ آن بیشینه است. 
</p><p>برای به دست آوردن $ ans_u $ حالت بندی کنید که راس $ u $ درون قطر باشد یا نباشد.
</p><ul><li><p>اگر راس $ u $ درون قطر نباشد مقدار $ ans_u $ برابر با بیشینه $ ans $ بچه های $ u $ خواهد بود زیرا که قطر کاملا درون یکی از بچه ها خواهد بود.
</p></li><li><p>در غیر اینصورت اگر راس $ u $ انتهای قطر باشد جواب برابر با $ dp_u $ خواهد بود.
</p></li><li><p>در غیر اینصورت راس $ u $ باید وسط یک مسیر باشد. حالت بندی کنید که دو سر آن به کدام یکی از بچه ها برود. اگر به بچه $ a, b $ برود جواب برابر با $ 2 + dp_a + dp_b $ خواهد بود. پس کافیست $ a, b $ را دو بچه ای انتخاب کنیم که مقدار $ dp $ آن ها بیشینه است.
</p></li></ul><p>در کد زیر در $ mx1, mx2 $ به ترتیب راس های با بیشترین $ dp $ را نگه داری می کنیم.
</p><pre dir="ltr">cpp
const int maxn = 1e5 + 10;
vector&lt;int&gt; g[maxn];
int dp[maxn], ans[maxn];
void dfs(int u, int par = 0){
    int mx1 = -1, mx2 = -1;
    for(int y : g[u]){
        if(y != par){
            dfs(y, u);
            dp[u] = max(dp[u], 1 + dp[y]);
            ans[u] = max(ans[u], ans[y]);
            if(mx1 == -1 || dp[mx1] &lt; dp[y]){
                mx2 = mx1;
                mx1 = y;
            }
            else if(mx2 == -1 || dp[mx2] &lt; dp[y])
                mx2 = y;            
        }
    }
    ans[u] = max(ans[u], dp[u]);
    if(mx1 != -1 &amp;&amp; mx2 != -1){
    ans[u] = max(ans[u], 2 + dp[mx1] + dp[mx2]);
}</pre><p>پس توانستیم الگوریتمی ارائه دهیم که با پیچیدگی زمانی $ O(n) $ قطر درخت را پیدا می کند.
</p><h2>dfs up/down</h2><p>گاهی هدف ما به دست آوردن یک متغیر مثل $ dp $ به ازای هر راس درخت است اما حساب کردن مقدار $ dp_u $ نیاز به داشتن مقدار $ dp $ تمام مجاور های راس $ u $ (و نه فقط بچه های $ u $) دارد.
</p><p>ساده ترین مثال برای معرفی این تکنیک مسئله پیدا کردن بیشترین فاصله از هر راس است. فرض کنید می خواهیم به ازای هر راس $ u $ خروج از مرکز این راس را داشته باشیم. جواب راس $ u $ را $ ans_u $ بگیرید. برای به دست آوردن جواب یک راس می توان به راحتی درخت را از این ارتفاع آویزان کرد و در $ O(n) $ ارتفاع درخت را حساب کرد. اما آیا می توان مسئله را به ازای تمام راس با هم در $ O(n) $ حل کرد؟
</p><p>اولین مشکل ما این است که چون حساب کردن جواب یک راس به داشتن جواب مجاور هایش نیاز دارد نمی دانیم که محاسبه را از کجا شروع کنیم!
</p><p>درخت را از راس $ u $ ریشه دار کنید. شکاندن مسئله به دو بخش می تواند مفید باشد. فرض کنید $ dpDown_u $ برابر است با بیشترین فاصله از راس $ u $ به راسی درون زیردرخت راس $ u $. همچنین $ dpUp_u $ برابر است با بیشترین فاصله از راس $ u $ به راسی خارج از زیردرخت راس $ u $ (یعنی در اولین گام باید به پدر $ u $ برویم). واضح است که جواب راس $ u $ برابر با بیشینه دو عدد $ dpDown_u $ و $ dpUp_u $ است.
</p><p>همانطور که در قسمت بالا بررسی کردیم $ dpDown_u $ را می توان از روی $ dpDown $ بچه های راس $ u $ حساب کرد.
</p><p>برای حساب کردن $ dpUp_u $ توجه کنید که بعد از اینکه از $ u $ به پدر $ u $ رفتیم می توانیم دو راه در پیش بگیریم.
</p><ul><li><p>می توانیم باز هم به بالا برویم. در اینصورت جواب برابر با $ 1 + dpUp_{par} $ است(فرض کنید $ par $ پدر راس $ u $ است).
</p></li><li><p>می توانیم به پایین برویم یعنی به یکی از برادر های $ u $ مثل $ w $ بریم. سپس باید پایین برویم. در اینصورت جواب برابر با $ 2 + dpDown_w $ می باشد.
</p></li></ul><p>نکته کلیدی این است که نیاز نیست هر بار تمام برادر های $ u $ را بررسی کنیم که راس با $ dpDown $ بیشینه (همان $ w $ را پیدا کنیم). کافی است به ازای $ par $ تنها یک بار دو بچه ای که $ dpDown $ آن ها بیشینه است را به دست بیاوریم. همواره راس $ w $ یکی از دو بچه $ par $ است که $ dpDown $ آنها بیشینه است. (چرا؟)
</p><p>پس فهمیدیم که به چه صورت باید متغیر ها را به دست بیاوریم. اما همچنان یک مشکل حل نشده باقی مانده است. به چه ترتیبی باید به دست آوردن مقادیر را انجام دهیم. برای به دست آوردن $ dpDown $ نیاز داریم که مقادیر بچه ها و برای به دست آوردن $ dpUp $ نیاز داریم که مقادیر پدر را داشته باشیم. پس از کدام یک باید شروع کنیم؟
</p><p>جواب ساده و هوشمندانه است. می توانیم طی دومرحله مقادیر را به دست بیاوریم. یک بار $ dpDown $ ها را با استفاده از dfsDown و سپس $ dpUp $ ها را با استفاده از dfsUp به دست بیاوریم! نکته اینجاست که در dfsDown ابتدا مقدار بچه ها به دست می آیند سپس مقدار راس فعلی. اما در dfsUp ابتدا مقدار پدر به دست می آید سپس مقدار بچه ها از روی پدر به دست می آیند!
</p><p>توجه کنید که در تابع dfsUp وقتی روی یک راس هستیم فرض کرده ایم که $ dpUp $ آن راس به دست آمده است و سپس $ dpUp $ بچه های آن را به دست می آوریم.
</p><pre dir="ltr">cpp
const int maxn = 1e5 + 10;
vector&lt;int&gt; g[maxn];
int dpUp[maxn], dpDown[maxn];
void dfsDown(int u, int par = 0){ // aval bayad in taabe ra ejra konim
    for(int y : g[u]){
        if(y != par){
            dfsDown(y, u);
            dpDown[u] = max(dpDown[u], dpDown[y] + 1);
        }
    }
}
void dfsUp(int u, int par = 0){
   int mx1 = -1, mx2 = -1;
   for(int y : g[u]){
if(y != par){
           if(mx1 == -1 || dpDown[mx1] &lt; dpDown[y]){
                mx2 = mx1;
                mx1 = y;
           }
           else if(mx2 == -1 || dpDown[mx2] &lt; dpDown[y]){
                mx2 = y;
           }            
       }
   }
   for(int y : g[u]){
if(y != par){
            if(y == mx1){
                dpUp[y] = dpUp[u] + 1;
                if(mx2 != -1)
                    dpUp[u] = max(dpUp[u], doDown[mx2] + 2);
            }
            else{
                dpUp[y] = max(dpUp[u]+1, doDown[mx1] + 2);
            }
            dfsUp(y, u);
       }
   }
}</pre><h2>یک الگوریتم ساده تر</h2><p>قطر درخت یک خاصیتی دارد که به ما کمک می کند تا آن را ساده تر پیدا کنیم. آن
خاصیت این است: دور ترین راس نسبت به هر راس، سر یکی از خطر های درخت است.
</p><p>برای اثبات، درخت را از این راس ریشه دار کنید. یکی از قطر های درخت را در
نظر بگیرید. این قطر که یک مسیر هم هست، دقیقا یک راس دارد که نزدیک ترین راس
به ریشه است. (پایین ترین جد مشترک سر و ته مسیر) اگر دور ترین راس مورد نظر
ما درون ریزدرخت این راس باشد، یکی از شاخه ها را حذف می کنیم و شاخه مربوط به
این راس را اضافه می کنیم و طول مسیر کوچک تر نمی شود پس هم چنان قطر می ماند. حالت
دیگر ممکن نیست چون در این صورت از راس دورتر نسبت به جد مشترک شروع کرده و به این
راس می رویم و قطر بزرگ تری پیدا می شود که تناقض است. پس این راس سر یکی از قطر
های درخت است.
</p><p>از این خاصیت می توان استفاده کرد و قطر درخت را پیدا کرد. تابعی می نویسیم که
یک راس ورودی بگیرد و به کمک الگوریتم دی اف اس یکی از دور ترین رئوس نسبت به این
راس را برگرداند. این تابع را از یک راس دلخواه اجرا می کنیم و نتیجه را
$ u $
می نامیم. یکبار هم این تابع را از
$ u $
اجرا می کنیم و نتیجه را
$ v $
می نامیم. چون از قضیه بالا می دانستیم که راس
$ u $
سر یکی از قطر های درخت است، پس مسیر
$ uv $
یکی از قطر های درخت است.
</p><h1>DFS Start/Finish Time</h1><p>در این بخش می خواهیم با ترفندی گراف را به آرایه تبدیل کنیم.
</p><p>ایده های مختلفی وجود دارد که بتوان گراف را به یک آرایه تبدیل کرد که starting time یکی از آن ها است. با استفاده از این ایده می توان گراف داده شده را به آرایه تبدیل کرد و با آن انواع سوال ها را با سادگی بیشتری حل کرد.
</p><p>می توان برای هر راس اولین زمانی که الگوریتم dfs بر روی آن وارد شده است را در نظر گرفت. به این صورت هر راس عددی یکتا دارد و می توان راس ها را بر حسب این زمان مرتب کرد و به یک آرایه رسید.
</p><p>فرض کنید آرایه ای که می خواهیم از راس های گراف درست کنیم a[i] باشد و زمانی که الگوریتم dfs وارد راس u می شود برابر st[u] باشد. در این صورت راس u را در خانه st[u] قرار می دهیم یا به عبارتی a[st[u]] = u است.
</p><p>مشخص است که هر زیر درخت از درخت dfs آن یک بازه از آرایه است.
</p><p>finishing time هم مانند starting time تعریف می شود با این تفاوت که زمان خارج شدن الگوریتم dfs از راسی را نشان می دهد.
</p><p>حال به بررسی چند سوال می پردازیم.
</p><h2>چک کردن جد و نواده بودن در زمان اجرای خطی</h2><p>درخت 
$ n $
راسی به همراه 
$ q $
کوئری به ما داده شده. در هر کوئری باید چک کنیم ایا راس 
$ u $
جد راس 
$ v $
است یا نه.
$ O(n+q) $
</p><h3>حل</h3><p>از این لم استفاده میکنیم که شرط لازم و کافی برای جد و نواده بودن به این شکل است:
$ stt[u]<=stt[v] and fnt[v]<=fnt[u] $
یا 
$ stt[u]<=stt[v] and stt[v]<fnt[u] $
</p><p>به سادگی میتوان درستی این لم را بررسی کرد.
پس برای حل مساله ابتدا روی درخت 
dfs
میزنیم و سپس به ازای هر کوئری شرط گفته سده را در 
$ O(1) $
چک میکنیم.
</p><h2>پیدا کردن kامین پدر</h2><p>درخت 
$ n $
راسی به همراه 
$ q $
کوئری به ما داده شده. در هر کوئری باید 
$ k $
امین پدر راس 
$ v $
را پیدا کنیم.
$ O(n+q.log(n)) $
</p><h3>حل</h3><p>تمام ریوس با ارتفاع
$ h[v]-k $
را در نظر بگیرید. با استفاده از لم سوال قبل میتوان نتیجه گرفت جواب راس با بیشترین استارتینگ تایم کمتر از استارتینگ تایم راس 
$ v $
در بین ریوس در ارتفاع 
$ k $
تا بالاتر است. به بیان دیگر
</p><ul><li><p>u with maximum stt such that h[u] = h[v] - k and stt[u] <= stt[v]
</p></li></ul><p>به ازای هر ارتفاع یک وکتور از تمام ریوس ان ارتفاع بسازید که ریوس هر وکتور بر حسب استارتینگ تایم مرتب شده اند.
$ O(n) $
</p><p>حال هر کوئری سوال به یک باینری سرچ روی یکی از این وکتور ها تبدیل میشود!
</p><h2>`Blood Cousins <https://codeforces.com/problemset/problem/208/E>`_</h2><p>درخت 
$ n $
راسی با 
$ m $
کوئری به شکل 
v p
داده شده. در هر کوئری باید تعداد 
$ u $
هایی را خروجی دهید که pامین پدر vوu یکسان اند.
$ O(n+qlg(n)) $
</p><h3>حل</h3><p>ابتدا 
pامین
پدر راس 
v
را مشابه مساله قبل پیدا کنید.
اسم این راس را 
w
بگذارید.
حال جواب تعداد 
u
هایی است که 
$ h[u] = h[v] , stt[w]<=stt[u] , stt[u] < fnt[w] $
.
یعنی در وکتور مربوط به راس 
v
تعداد استارتینگ تایم های مربوط به یک بازه را میخواهیم که با باینری سرچ ساده قابل حل است.
</p><h2>دوهمبند کردن با مینیمم تعداد مسیر</h2><p>درخت 
$ n $
راسی و 
$ 2k $
برگی داده شده. در هر عملیات میتوانیم دو برگ را انتخاب کرده و تمام یالهای مسیر بین ان دو را رنگ کنیم. کمترین تعداد عملیات لازم و یک روش با کمترین تعداد عملیات برای رنگ کردن تمام یالها را پیدا کنید.
$ O(n) $
</p><h3>حل</h3><p>جواب=k
در ادامه روش ارایه میدهیم و درستی روش را نشان میدهیم.
اگر n=2 سوال بدیهی حل میشود.
پس فرض کنید n>2 و حداقل یک راس غیربرگ داریم.
از یک راس غیربرگ درخت را ریشه دار کرده و برگ ها را بر حسب استارتینگ تایم شماره گذاری کنید.
حال روی این جفت برگ ها عملیات را انجام دهید:
</p>$$ (1, k+1) $$$$ (2, k+2) $$$$ (3, k+3) $$$$ ... $$$$ (k, 2k) $$<p>به وضوح پیچیدگی این جفت بندی 
$ O(n) $
است.
</p><p>حال باید نشان دهیم همه یالها رنگ میشوند..
زیردرخت هر یال یک بازه از برگها را شامل میشود و برای اینکه یک یال رنگ شود باید جفت برگی داشته باشیم که یک سرش داخل این بازه و سر دیگرش خارج ان باشد.
فرض کنید بازه یال مورد نظر
$ [l, r] $
است.
دو حالت را بررسی میکنیم.
اول اینکه
$ l<=k && k+<=r $
در این حالت اگر 
$ l!=1 $
بود جفت 
(1, k+1)
داخل بازه میافتد. وگرنه جفت
(k, 2k)
.
</p><p>اگر بازه متناظر یال مشابه حالت قبل نبود بدون کم شدن کلیت فرض میکنیم
$ l,r<=k $
در این حالت هم جفت 
(r, r+k)
این یال را رنگ میکند.
</p><p>پس در هر دو حالت یال مورد نظر رنگ میشود و جفت هایی که ساختیم معتبراند.
</p><h1>الگوریتم های راس و یال برشی</h1><h2>پیدا کردن یال برشی</h2><p>برای پیدا کردن یال برشی، ابتدا بر روی گراف الگوریتم DFS را اجرا می کنیم. در هنگام اجرا شدن الگوریتم DFS به ازای هر راس u یک مقدار dp[u] نگه می داریم که برابر است با کمترین ارتفاعی که به آن backedge از بین رئوس زیر درخت راس u داریم. مقدار dp[u] برای هر راس این گونه حساب می شود که مقدار یک راس برابر با کمترین مقدار فرزندان آن راس و ارتفاع backedge های خود آن راس می باشد. حال یک یال بین راس v و parent[v] برشی است اگر و تنها اگر dp[v] مقدارش کمتر از ارتفاع v نباشد. یعنی یالی در زیر درخت v وجود نداشته باشد که به راسی بالا تر از v وصل باشد.
</p><p>زمان اجرای این الگوریتم O(n+m) است که در آن n نشان دهنده تعداد راس ها و m نشان دهنده تعداد یال ها است.
</p><pre dir="ltr">cpp
const int maxn = 1e6 + 10;
bool mark[maxn], is[maxn];
int dp[maxn], height[maxn];
pair&lt;int, int&gt; edge[maxn];
vector&lt;pair&lt;int, int&gt; &gt; adj[maxn];
void dfs(int v,int parent,int index){
    dp[v] = height[v];
    mark[v] = true;
    for(int i = 0; i &lt; adj[v].size(); i++){
        int u = adj[v][i].first;
        int ind = adj[v][i].second;
        if(!mark[u]){
            height[u] = height[v] + 1;
            dfs(u, v, ind);
            dp[v] = min(dp[v], dp[u]);
        }
        else{
            if(u != parent){
                dp[v] = min(dp[v], height[u]);
            }
        }
    }
    if(v != 1 &amp;&amp; dp[v] == height[v])
        is[index] = true;
    return;
}
int main(){
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++){
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        edge[i] = {u, v};
        adj[u].push_back({v, i});
        adj[v].push_back({u, i});
    }
    dfs(1, 0, 0);
    for(int i = 0; i &lt; m; i++)
        if(is[i])
            cout &lt;&lt; edge[i].first &lt;&lt; &quot; &quot; &lt;&lt; edge[i].second &lt;&lt; endl;
    return 0;
}</pre><h2>پیدا کردن راس برشی</h2><p>در این قسمت نیز به مانند یال برشی مقدار dp[u] را با همان تعریف برای راس u به دست می آوریم. حال یک راس برشی است اگر وقتی آن را جدا می کنیم گراف به بیش از یک مولفه تقسیم شود بنابراین در درخت DFS که ساختیم راس v برشی است اگر مقدار dp همه فرزندانش بیشتر از مقدار ارتفاع راس v بود یعنی یالی به بالای آن نداشت. توجه کنید که ریشه زمانی برشی است که درجه یک نباشد.
</p><p>زمان اجرای این الگوریتم نیز O(n+m) است.
</p><pre dir="ltr">cpp
const int maxn = 1e6 + 10;
bool mark[maxn], is[maxn];
int dp[maxn], height[maxn];
vector&lt;int&gt; adj[maxn];
void dfs(int v,int parent){
    dp[v] = height[v];
    mark[v] = true;
    int num = 0;
    for(int i = 0; i &lt; adj[v].size(); i++){
        int u = adj[v][i];
        if(!mark[u]){
            height[u] = height[v] + 1;
            dfs(u, v);
            if(v != 1 &amp;&amp; dp[u] &gt;= height[v])
                is[v] = true;
            dp[v] = min(dp[v], dp[u]);
            num++;
        }
        else if(u != parent)
            dp[v] =min(dp[v], height[u]);
    }
    if(v == 1 &amp;&amp; num &gt; 1)
        is[v] = true;
    return;
}
int main(){
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i++){
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(1, 0);
    for(int u = 1; u &lt;= n; u++)
        if(is[u])
            cout &lt;&lt; u &lt;&lt; &quot; &quot;;
    return 0;
}</pre><h1>کارگاه پرورش ایده</h1><p>درخت ها به عنوان ساده ترین گراف های همبند شناخته می شوند. به عبارتی دیگر یک درخت مثل اسکلت گراف است. می دانیم هر گراف همبند دارای حداقل یک درخت پوشا است زیرا می توانیم آن را بسازیم. به این صورت که تا زمانی که دوری وجود داشت یکی از یال های آن را حذف کنیم. اینکه در هر مرحله چه یال هایی را حذف کنیم در ساختار درخت پوشای نهایی نقش خواهد داشت. به صورت خاص دو الگوریتم dfs , bfs به ما دو درخت پوشای متفاوت و جالب با خواص جالب می دهند!
</p><p>در این بخش در مورد مسائلی بحث می کنیم که به شما کمک می کند شهود بهتری نسبت به درخت ها پیدا کنید همچنین دید و قدرت حل مسئله شما را افزایش می دهد. حتما قبل از خواندن حل سوالات، به اندازه کافی روی آنها فکر کنید!
</p><h2>مربع پاک کن</h2><p>یک دستگاه مربع پاک کن در اختیار داریم که در هر مرحله می تواند $ C_4 $ از گراف را در نظر گرفته و یکی از یال های آن را حذف کند. در ابتدا یک $ K_n $ با $ n \geq 4 $ داریم. هدف ما این است که طوری از مربع پاک کن استفاده کنیم که در نهایت تعداد یال های باقی مانده در گراف کمینه شود. این تعداد کمینه را بیابید.
</p><h3>حل</h3><p>مربع پاک کن به دو ویژگی لطمه نمی زند. 
</p><ol><li><p>همبندی گراف حفظ می شود.
</p></li><li><p>همواره دور فرد خواهد داشت. 
</p></li></ol><p>شاید مورد دوم کمی سخت تر به ذهن برسد. احتمالا شما هم در ابتدا حدس زدید که جواب باید $ n-1 $ باشد (به دلیل ویژگی اول) اما هر طور که از مربع پاک کن استفاده بکنید یک دور مزاحم باقی می ماند!
</p><p>برای ویژگی دوم ابتدا توجه کنید که چون $ n \geq 3 $ پس حتما در ابتدا یک دور فرد داریم. فرض کنید که از مربع $ ABCD $ یال $ AB $ را حذف کردیم و دور فردی که در مرحله قبل داشتیم از بین رفت. حالا دور فرد قبلی را طی کنید فقط به جای استفاده از یال $ AB $ از گشت $ ACDB $ استفاده کنید. واضح است که در نهایت به یک گشت فرد می رسیم که همانطور که در فصل 1 گفتیم درون هر گشت فرد دور فردی وجود خواهد داشت!
</p><p>از دو مورد گفته شده می توانیم نتیجه بگیریم که به دلیل همبندی گراف باید حداقل $ n-1 $ یال داشته باشیم و از آنجایی که اگر دقیقا $ n-1 $ یال همبند داشته باشیم یک درخت داریم که دور فرد ندارد، پس باید حداقل $ n $ یال داشته باشیم.
</p><p>ساخت مثال با دقیقا $ n $ یال را به عهده خواننده می گذاریم!
</p><h2>عدد گذاری روی یال</h2><p>یک گراف همبند  داریم که $ m $ یال دارد. می خواهیم یال های این گراف جایگشتی از اعداد 1 تا $ m $ را نسبت بدهیم به طوری که به ازای هر راس $ v $ که درجه آن بیشتر از 1 است، ب.م.م اعداد روی یال های مجاور $ v $ برابر با 1 باشد.
</p><h3>حل</h3><p>برای حل سوال از این نکته استفاده می کنیم که ب.م.م هر دو عدد متوالی برابر با 1 است.
</p><p>از یک راس دلخواه شروع به اجرای dfs بکنید و به اولین یالی که می بینیم عدد 1، به دومین یالی که می بینیم عدد 2 و به همین ترتیب. منظور از دیدن یال این چیست؟ فرض کنید روی راس $ u $ هستیم و در حال انجام dfs هستیم. لیست کل یال های مجاور $ u $ را به ترتیب نگاه می کنیم. وقتی به یال $ uv $ می رسیم در صورتیکه قبلا به این یال عددی نسبت داده نشده بود ما یک عدد نسبت می دهیم. سپس اگر راس $ v $ غیرتکراری بود dfs(v) را صدا می زنیم.
</p><p>پس عددی که به هر یال نسبت می دهیم برابر است با اینکه این یال، چندمین یال دیده شده است. ب.م.م اعداد یال های مجاور ریشه 1 است زیرا که اولین یالی که طی می کنیم 1 است و مجاور ریشه می باشد. به ازای هر راس غیر ریشه مثل $ u $ ب.م.م اعداد مجاور $ u $ برابر با 1 است، زیرا که اگر با یال با شماره $ x $ به $ u $ وارد شده باشیم طبق منطق بازگشتی dfs بلافاصله روی یکی از یال های مجاور $ u $ عدد $ x+1 $ را خواهیم نوشت (مگر اینکه درجه راس $ u $ برابر با 1 باشد که در اینصورت روی این راس محدودیت خاصی نداریم).
</p><img src="/_static/dot/DFS_Magic.svg"><p>توجه کنید که به خاطر ساختار dfs هر کدام از backedge ها که جزو یال های درخت نیستند را از راس پایینی آن می بینیم! (چرا؟) بنابرین برای برگ های درخت که درجه آنها 1 نیست مشکلی پیش نمی آید.
</p><h2>برگ برگ برگ</h2><p>ثابت کنید در درختی $ n > 1 $ راسی که راس درجه 2 ندارد تعداد برگ ها بیشتر از غیر برگ هاست.
</p><h3>حل</h3><p>برای حل سوال از استقرا استفاده می کنیم. پایه استقرا را $ n = 2 $ می گذاریم که درستی آن واضح است. درخت $ T $ را از یک راس دلخواه آویزان می کنیم و پایین ترین برگ را $ u $ می نامیم. فرض کنید پدر پایین ترین برگ $ v $ باشد. در اینصورت همه بچه های $ v $ برگ هستند (چرا؟). اگر $ v $ همان ریشه باشد که حکم واضح است (چون به جز $ v $ بقیه راس ها برگ هستند). در غیراینصورت با حذف تمام بچه های $ v $ که برگ هستند به درخت $ T' $ با تعداد راس کمتر می رسیم که حداقل 2 راس دارد و راس درجه 2 ندارد پس فرض استقرا برای آن برقرار است. فرض کنید در این درخت تعداد برگ ها $ A' $ و تعداد غیربرگ ها $ B' $ باشد و طبق فرض استقرا $ A' > B' $ است.
</p><p>حالا دوباره بچه های $ v $ را اضافه کنید. اگر $ d $ تا بچه داشته باشد آنگاه تغییراتی که در درخت اعمال می شود به اینصورت است.
</p><ul><li><p>راس $ v $ از برگ بودن خارج می شود.
</p></li><li><p>تمام بچه های $ v $ به مجموعه برگ ها اضافه می شوند.
</p></li></ul><p>پس اگر تعداد برگ ها و غیر برگ های جدید را به ترتیب $ A, B $ بنامیم داریم $ A = A' + d - 1 $ و $ B = B' + 1 $ و از آنجایی که $ d>1 $ است پس همچنان $ A > B $ برقرار است.
</p><h3>نکته</h3><p>مسئله ای که گفته شد یک لم کلاسیک بود که در حل بعضی مسائل به ما کمک می کند. به طور کلی در بعضی از مسائل می توانیم راس های درجه 2 را فشرده کرده و آنها را از بین ببریم. یعنی اینکه اگر تمام راس های درجه 2 درخت را قرمز کنیم، راس های درجه 2 تشکیل تعدادی مسیر مجزا می دهند (چرا؟). حالا فرض کنید به ازای هر مسیر متشکل از راس های درجه 2 که از راسی مثل $ A $ شروع شده و به راسی مثل $ B $ ختم می شود این مسیر را حذف کنیم و فقط یالی از $ A $ به $ B $ بگذاریم. بعد از انجام این عملیات ها تمام راس های درجه 2 از بین می روند و ساختار کلی درخت حفظ می شود. حالا اگر درخت مسئله به گونه ای باشد که تعداد برگ ها کم باشد می توان نتیجه بگیریم تعداد کل راس های درخت هم کم است!
</p><h2>جادوی bfs</h2><p>یک گراف همبند داریم.می دانیم اگر هر دور فردی از این گراف را در نظر بگیرید و یال های این دور را حذف کنید گراف ناهمبند می شود. ثابت کنید می توان راس های این گراف را با 4 رنگ، رنگ آمیزی کرد به طوریکه هر دو راس مجاور رنگ متفاوت داشته باشند!
</p><h3>حل</h3><p>اگر نمی دانستیم باید به bfs فکر کنیم این سوال چقدر سخت می شد؟
</p><p>حالا از یک راس دلخواه bfs بزنید. حالا گراف به تعدادی لایه افراز شده است که یال های گراف یا درون یک لایه اند یا بین دو لایه مجاور هستند.
</p><p>ادعا می کنیم زیرگراف شامل راس های هر کدام از لایه ها دوبخشی است. برهان خلف بزنید و فرض کنید یک لایه داریم که دوبخشی نیست. پس باید دور فرد داشته باشد. حالا اگر لایه های این دور فرد را حذف کنید طبق صورت سوال باید گراف ناهمبند شود اما می دانیم که این اتفاق نمی افتد! زیرا که گراف توسط یال های درخت bfs همبند شده است و یال های درخت bfs تنها بین لایه های مجاور است.
</p><p>پس اثبات کردیم که هر کدام از لایه ها دوبخشی است. پس هر لایه را می توانیم با دو رنگ، رنگ آمیزی کنیم که مجاور ها رنگ متفاوت داشته باشند. حالا لایه های فرد را با رنگ 1, 2 و لایه های زوج را با رنگ 3, 4 رنگ کنید. مشکلی پیش نمی آید زیرا دو راس که همرنگ اند یا درون یک لایه اند‌ (که با دوبخشی بودن مشکل را برطرف کردیم) یا در لایه های مجاور نیستند (که یالی بین آنها وجود ندارد).
</p><p>به همین سادگی!
</p><h1>تعاریف</h1><h2>تعریف 3.1.1 (گراف جهت دار)</h2><p>فرض کنید تعدادی شهر داریم که توسط جاده هایی به هم متصل هستند و شما در شهر D هستید و می‌خواهید به شهر A بروید(شکل ۱).
برای رسیدن به شهر A باید از تعدادی جاده عبور کنیم ولی از آنجا که جاده‌ها می‌توانند یک‌طرفه باشند، به گرافی نیاز داریم که جهت هر جاده را به ما نشان دهد که به آن گراف جهت دار گوییم(شکل ۲).
</p><img src="/_static/dot/Simple_Graph.svg"><img src="/_static/dot/Simple_Directed_Graph.svg"><p>به بیان دقیق تر، گراف جهت دار 
$ G $
یک زوج مرتب
$ (V, E) $
است که $ V $ مجموعه راس های گراف است. همچنین $ E $ یک مجموعه شامل زوج مرتب هایی به فرم
$ (u, v) $
است به این معنا که یک یال جهت دار از 
$ u $
به 
$ v $
در گراف وجود دارد.
</p><p>به گراف جهت دار 
$ G $
ساده می‌گوییم اگر شامل یال های جهت دار چند گانه و طوقه نباشد. البته توجه داشته باشید که ممکن است 
$ G $
ساده باشد و $ E $ شامل 
$ (u, v) $
و
$ (v, u) $
باشد، ولی نمی‌تواند ۲ تا از زوج مرتب 
$ (u, v) $
را داشته باشد.
</p><p>توجه داشته باشید که از این به بعد ما با گراف های جهت دار ساده کار خواهیم داشت و منظور ما از گراف جهت دار گراف جهت دار ساده خواهد بود، مگر اینکه در صورت سوال ذکر شود.
</p><h2>درجه در گراف جهت دار</h2><p>در یک گراف جهت دار، هر راس یک درجه ورودی و یک درجه خروجی دارد. برای مثال در شکل۲، درجه ورودی راس D برابر با ۳ و درجه خروجی آن برابر با ۱ است!
</p><p>درجه ورودی راس $ v $ را با نماد 
$ d^{−}(v) $
یا
$ deg^{−}(v) $
و درجه خروجی را با 
$ d^{+}(v) $
یا
$ deg^{+}(v) $
نمایش می‌دهیم.
</p><p>منظور از 
$ \delta^{+}, \delta^{-} $
به ترتیب مینیمم درجه ورودی و مینیمم درجه خروجی است.
</p><p>به طور مشابه منظور از 
$ \Delta^{+}, \Delta^{-} $
به ترتیب ماکسیمم درجه ورودی و ماکسیمم درجه خروجی است.
</p><h2>دور و مسیر در گراف جهت دار </h2><p>مشابه گراف های ساده، در گراف های جهت دار هم تعاریفی مانند گشت، گشت بسته، گذر، دور و مسیر داریم. 
برای مثال در شکل۲، یک مسیر جهت دار می‌تواند مسیری به شکل (D -> C -> B -> A)
باشد که راس شروع همان مبدا سفر(D) و راس پایان همان مقصد سفر(A) می‌باشد. دقت کنید در طی کردن یال ها، باید جهت یال رعایت شود. برای مثال هنگامی که در راس D هستیم، نمی‌توانیم به راس A به صورت مستقیم برویم!
</p><p>همچنین یک دور در شکل۲ می‌تواند به صورت (D -> C -> B -> D) باشد. بدیهتا در هنگام طی کردن دور، باید جهت یال ها رعایت شود.
</p><p>به طور مشابه، طول هر کدام از تعاریف بالا، برابر با تعداد یال های آن است.
</p><p>به بیان دقیق تر : 
</p><p><b>گشت :</b>
دنباله
$ v_{1}, v_{2}, ..., v_{l} $
یک گشت در گراف جهت دار 
$ G $
است، اگر به ازای هر 
$ 1 \leq i < l $
یال
$ (v_{i}, v_{i+1}) $
در $ G $ باشد(به عبارتی یال فوق متعلق به مجموعه $ E $ باشد) .
</p><p><b>گشت بسته :</b>
اگر در دنباله ای که تعریف کردیم،
$ v_{1} = v_{l} $
باشد، به این گشت یک گشت بسته گوییم.
</p><p><b>گذر :</b> اگر در دنباله ای که تعریف کردیم، هیچ یال تکراری نباشد، به این گشت یک گذر گوییم.
</p><p><b>مسیر :</b> اگر در دنباله ای که تعریف کردیم، هیچ راس تکراری نباشد(و در نتیجه یال تکراری هم نباشد)، گشت حاصل یک مسیر است.
</p><p><b>دور :</b> در آخر اگر در یک مسیر، راس شروع و پایان یکسان باشند(
$ v_{1} = v_{l} $
)
به گشت حاصل یه دور گوییم.
</p><p>دقت کنید که تعاریف بالا دقیقا مانند تعاریف در گراف ساده هستند با این تفاوت که در گراف جهت دار باید جهت یال ها درست طی شوند!
</p><h2>قضایا و لم های مورد استفاده در این بخش </h2><h3><b>قضیه 3.1.2</b></h3><p><b>صورت قضیه :</b> در گراف جهت دار $ G $، داریم 
$ \sum d^{-}(v) = \sum d^{+}(v) $
</p><p><b>اثبات قضیه :</b> برهان این قضیه ساده است(این قضیه مشابه با زوج بودن مجموع درجات در گراف ساده است). هر یال از این گراف را که در نظر بگیرید، به راس شروع یک درجه خروجی اضافه می‌کند و به راس پایان یک درجه ورودی اضافه میکند. در نتیجه یک واحد به طرف راست تساوی و یک واحد به طرف چپ تساوی اضافه می‌شود!
</p><h3><b>قضیه 3.1.3</b></h3><p><b>صورت قضیه :</b> اگر در گراف جهت دار $ G $، درجه خروجی(یا درجه ورودی) هر راس حداقل ۱ باشد، آنگاه این گراف حداقل یک دور جهت‌دار دارد.
</p><p><b>اثبات قضیه :</b> این قضیه مشابه با دور داشتن گراف ساده‌ای است که درجه هر راس آن حداقل ۲ است. بلند ترین مسیر گراف را در نظر بگیرید.
</p><p>فرض کنید این بلند ترین مسیر به صورت 
$ v_1, v_2, ..., v_l $
باشد. طول این مسیر طبق تعاریف بالا برابر با‌ 
$ l-1 $
است.
</p><p>حال راس
$ v_l $
را در نظر بگیرید. از آنجا که این راس حداقل یک درجه خروجی دارد، پس راسی مانند 
$ x $
وجود دارد به طوری که از
$ v_l $
به 
$ x $
یک یال جهت دار است. از طرفی راس
$ x $
نمی‌تواند خارج از مسیر بالا باشد(چرا؟).
</p><p>پس راس
$ x $
یکی از راس های مسیر است. برای مثال فرض کنید  
$ x = v_j $
</p><p>در نتیجه دنباله
$ v_{j}, v_{j+1}, ..., v_{l}, v_{j} $
تشکیل یک دور می‌دهد!
</p><h3><b>قضیه 3.1.4</b></h3><p><b>صورت قضیه :</b> اگر در گراف جهت دار $ G $، درجه خروجی(یا درجه ورودی) هر راس حداقل $ k $ باشد، آنگاه این گراف یک دور به طول حداقل $ k+1 $ دارد.
</p><p><b>اثبات قضیه :</b> این قضیه تعمیم قضیه 3.1.2 می‌باشد. اثبات این قضیه هم مشابه با قضیه 3.1.2 می‌باشد.
</p><p>به طور مشابه بلند ترین مسیر در $ G $ را در نظر بگیرید. فرض کنید دنباله ای به صورت 
$ v_1, v_2, ..., v_l $
باشد.
</p><p>حال ادعا میکنیم 
$ l > k $
(به عبارتی می‌گوییم طول بلند ترین مسیر حداقل برابر با $ k $ است).
</p><p>برهان ادعا واضح است، زیرا اگر راس $ v_l $ را در نظر بگیریم، حداقل  $ k $ یال از $ v_l $ خارج می‌شود. که همه این راس ها(راس هایی که یال ورودی از $ v_l $ دارند) داخل بلندترین مسیر هستند(چرا؟). پس این بلند ترین مسیر حداقل $ k+1 $ راس دارد(k تا از همسایه های $ v_l $ و خود $ v_l $).
</p><p>حال کم‌ترین
$ j $
را در نظر بگیرید به طوری از 
$ v_l $
به
$ v_j $
یال باشد(به عبارتی سمت چپ ترین راس از مسیر را در نظر می‌گیریم تا در حد امکان طول دور را افزایش دهیم).
حال دور رو به رو را در نظر بگیرید 
$ v_{j}, v_{j + 1}, ..., v_{l}, v_{j} $
ادعا می‌کنیم طول این دور حداقل برابر با $ k+1 $ است(چرا؟).
</p><h2>چند تعریف دیگر</h2><p><b>گراف زمینه  :</b>
اگر یال های یک گراف جهت دار را بی جهت کنیم، آنگاه به گراف به دست آمده گراف زمینه گوییم. برای مثال شکل۱ یک گراف زمینه برای شکل۲ است.
</p><h1>تورنومنت</h1><h2><b>تعریف 3.2.1 (تورنمنت)</b></h2><p>تورنمنت، گراف ساده و کاملی است که یال‌های آن جهت‌دار شده‌اند (شکل 1 تورنمنتی با 5 راس می‌باشد).
</p><img src="/_static/tournament_1.png"><p>یک تورنمنت 
$ n $
راسی می‌تواند مدلی برای مسابقات بین 
$ n $
تیم باشد به طوری که از راس 1 به راس 2 یال جهت‌دار است اگر و تنها اگر تیم 1 از تیم 2 برده باشد (مانند شکل 1).
</p><h2>شاه در تورنمنت‌ها</h2><h3><b>تعریف 3.2.2 (شاه)</b></h3><p>شاه، راسی درتورنمنت است که به تمام راس‌های تورنمنت مسیری جهت‌دار به طول حداکثر 2 دارد. به عنوان مثال راس 3، یک شاه در شکل 1 می‌باشد.
</p><h3><b>قضیه 3.2.3</b></h3><p><b>صورت قضیه :</b> هر تورنمنت حداقل یک شاه دارد.
</p><p><b>اثبات قضیه :</b> فرض کنید 
$ v $
راسی با درجه خروجی 
$ \Delta^{+} $
در تورنمنت باشد، یعنی راسی باشد که بیشنیه درجه خروجی را دارد. اگر راسی مانند 
$ u $
وجود داشته‌باشد که نتوان از 
$ v $
به آن با مسیری با طول حداکثر 2 برسیم، در این صورت 
$ u $
باید به 
$ v $
و تمام راسی‌های مانند 
$ w $
که 
$ (v,w) \in E $
، یال جهت‌دار داشته‌باشد (شکل 2) که در این صورت 
$ d^{+}(u) \geq \Delta^{+}+1 $
که با بیشینه بودن درجه خروجی 
$ v $
در تناقض است. پس درنتیجه راسی وجود ندارد که از 
$ v $
نتوان با حداکثر دو یال به آن رسید  و 
$ v $
، شاه است.
</p><img src="/_static/tournament_2.png"><p>قضیه 3.2.3 مانند این می‌باشد که به عنوان مثال در یک تورنمنت مسابقات، فردی مانند 
$ v $
وجود دارد که به ازای هر نفر مانند 
$ u $
یا آن را برده است یا شخصی را برده که 
$ u $
را برده است.
</p><h2>مسیر همیلتونی در تورنمنت‌</h2><h3><b>تعریف 3.2.4(مسیر همیلتونی در گراف جهت‌دار)</b></h3><p>یک مسیر همیلتونی در گراف جهت‌دار، مسیر جهت‌داری است که از تمام راس‌ها بگذرد.
</p><h3><b>قضیه 3.2.5</b></h3><p><b>صورت قضیه :</b> هر تورنمنت دارای حداقل یک مسیر همیلتونی است.
</p><p><b>اثبات قضیه :</b> فرض کنید راس‌های 
$ a_1 $
تا 
$ a_k $
بلندترین مسیر جهت‌دار در تورنمنت را تشکیل دهند (شکل 3).
</p><img src="/_static/tournament_3.png"><p>اگر 
$ k = n $
که حکم اثبات می‌شود، در غیر این صورت راسی مانند 
$ v $
وجود دارد که در این مسیر نمی‌باشد. از 
$ v $
به 
$ a_1 $
و از 
$ a_k $
به 
$ v $
نمی‌تواند یال جهت‌دار باشد (چرا؟)، پس فرض کنید 
$ a_i $
راسی با کوچک‌ترین 
$ i $
بین تمام راس‌ها از 
$ a_1 $
تا 
$ a_k $
باشد که 
$ v $
به آن‌ها یال دارد. در این صورت راس‌های
$ a_1,...,a_{i-1},v,a_i,...,a_k $
مسیری با طول 
$ k+1 $
تشکیل می‌دهند، در صورتی که طول بلندترین مسیر برابر
$ k $
می‌باشد. در نتیجه 
$ k = n $
و 
$ a_1 $
تا 
$ a_k $
تشکیل یک مسیر همیلتونی می‌دهند.
</p><h1>گراف جهت‌دار بدون دور</h1><h2>تعریف 3.3.1 (DAG)</h2><p>فرض کنید یک بازی تفنگی داریم. سازنده بازی قرار است برای هر دست از بازی, تاریخچه آن دست از بازی را ذخیره کند. به عبارتی اگر نفر 
$ A $
نفر  
$ B $
را کشت, یک یال جهت دار از 
$ A $
به
$ B $
رسم می‌کنیم.
</p><p>با فرض اینکه دو نفر نمی‌توانند همزمان همدیگر را بکشند, گرافی که این کاربر ها با یکدیگر تشکیل می‌دهند یک گراف جهت دار بدون دور است(چرا؟).
</p><p>همانطور که از اسم بخش مشخص است, به گراف جهت داری که دور نداشته باشد یک گراف جهت دار بدون دور یا به اصطلاح
$ DAG $
(directed acyclic graph)	
گوییم.
</p><h2>یک خاصیت مهم</h2><h3><b>قضیه 3.3.2</b> </h3><p><b>صورت قضیه :</b> اگر 
$ G $
یک گراف جهت دار بدون دور باشد, آنگاه میتوان راس های 
$ G $
را طوری به ترتیب 
$ v_{1}, v_{2}, ..., v_{n} $
نوشت به طوری که اگر یال 
$ (v_{i}, v_{j}) $
در گراف باشد, انگار
$ i < j $
باشد. (شکل۱ و شکل۲ را ببینید. شکل۲ یک ترتیب مرتب کردن راس ها برای گراف شکل۱ می‌باشد.)
</p><img src="/_static/dot/DAG_Random.svg"><img src="/_static/dot/DAG_Sorted.svg"><p><b>اثبات قضیه :</b> برای اثبات این قضیه از استقرا کمک می‌گیریم. پایه استقرا 
$ n = 1 $
می‌باشد. که گرافی یک راسی می‌باشد. که حکم برای این گراف واضح است.
</p><p>طبق قضیه
$ 3.1.2 $
که در تعاریف گراف ثابت کردیم, در 
$ G $
یک راس وجود دارد که درجه ورودی آن  
$ 0 $
می‌باشد(زیرا اگر درجه ورودی همه راس ها حداقل یک باشد, آنگاه این گراف دور دارد که با فرض سوال در تناقض است).
</p><p>حال  فرض کنید 
$ d^{-}(x) = 0 $
. راس 
$ x $
را در جایگاه 
$ v_{1} $
قرار میدهیم و از گراف حذف میکنیم(به همراه تمام یال های متصل به آن).
</p><p>چون گراف اولیه دور نداشت, با حذف راس 
$ x $
دوری ایجاد نمی‌شود و شرایط استقرا برقرار است. پس طبق استقرا گراف باقی‌مانده را می‌توان طوری در یک ردیف چید که شرط سوال برقرار باشد. این ترتیب چیدن راس ها را به ترتیب در 
$ v_{2}, v_{3}, ..., v_{n} $
قرار می‌دهیم. از طرفی 
$ v_{1} = x $
است.
</p><p>اکنون کافی است ثابت کنیم این ترتیب راس ها, از شرط سوال پیروی می‌کند.
راس های 
$ v_{2}, v_{3}, ..., v_{n} $
که تکلیفشان مشخص است چون طبق استقرا چیده شده اند. حال کافی است راس 
$ v_{1} $
شرط را رعایت کند. که این هم واضح است. چون این راس یال ورودی ندارد. پس حکم ثابت شد!
</p><p><b>پی نوشت :</b> صورت شهودی تر این قضیه به این‌صورت است که می‌توان راس های گراف بدون دور را در یک ردیف چید به طوری که همه یال ها از چپ به راست(یا از راست به چپ) باشند! هم‌چنین به این ترتیب از راس ها یک 
topological sort 
یا ترتیب توپولوژیک
گوییم!
</p><h2>مرتب سازی توپولوژیک</h2><h3>الگوریتم مرتب سازی توپولوژیک</h3><p>این الگوریتم همان الگوریتم 
$ DFS $
است. صرفا هنگام تمام شدن پیمایش از یک راس, آن را در یک پشته(در اینجا برای افزایش سرعت برنامه از پشته استفاده نکردیم. توصیه می‌شود استفاده از پشته به حداقل برسد), می‌اندازیم.
</p><h3>اثبات درستی الگوریتم</h3><p>فرض کنید ترتیبی که الگوریتم به ما می‌دهد اینگونه باشد $ v_{1}, v_{2}, ..., v_{n} $
به لم زیر توجه کنید :
</p><p><b>لم ۱ :</b> وقتی راسی مانند
$ x $
را در آرایه می‌اندازیم که همه راس هایی که از x می‌توان به آنها رسید(یعنی همه راس هایی مثل
$ v $
که از 
$ x $
به
$ v $
مسیر هست) , پیمایش آنها تمام شده باشد و در آرایه انداخته شده باشند!(چرا؟)
</p><p>برای اثبات الگوریتم بالا از برهان خلف و <b>لم ۱</b> استفاده می‌کنیم. فرض کنید ترتیبی که به دست آوردیم مطلوب نباشد. یعنی وجود دارند 
$ i < j $
به طوری که یال 
$ (v_{i}, v_{j}) $
متعلق به گراف باشد(یعنی یک یال از چپ به راست).
</p><p>اما این ممکن نیست! زیرا وقتی 
$ v_{i} $
در آرایه انداخته شده, طبق <b>لم ۱</b>, تمام راس هایی که از 
$ v_{i} $
به آنها مسیر هست, باید در آرایه انداخته شده باشند. اما از 
$ v_{i} $
به
$ v_{j} $
یک یال است(و بدیهتا مسیر هم هست), و 
$ v_{j} $
هنوز در آرایه انداخته نشده! که این خلاف <b>لم ۱</b> می‌باشد. پس حکم باطل است و چنین
$ i, j $
وجود ندارند!
</p><h3>پیچیدگی الگوریتم</h3><p>پیچیدگی الگوریتم بالا, همان پیچیدگی الگوریتم 
$ DFS $
است یعنی
$ O(n + m) $
که 
$ m, n $
به ترتیب تعداد راس ها و یال ها می‌باشند.
</p><h3>پیاده‌سازی الگوریتم</h3><pre dir="ltr">cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MX = 5e5 + 5;
int n, m; /// Tedad ra's ha va yal ha
vector&lt;int&gt; gr[MX]; /// vector mojaverat
vector&lt;int&gt; topologic; /// topological sort
bool mark[MX];
void dfs(int v){
mark[v] = 1;
for(int u: gr[v]){
if(!mark[u])
dfs(u);
}
topologic.push_back(v); // in array yek topological sort baraie DAG ast!
}
int main(){
cin &gt;&gt; n &gt;&gt; m;
for(int i = 0; i &lt; m; i++){
int v, u;
cin &gt;&gt; v &gt;&gt; u; // Ra's ha 0-based hastand!
gr[v].push_back(u);
}
// Graph vorodi bayad DAG bashad!
for(int i = 0; i &lt; n; i++)
if(!mark[i])
dfs(i);
// topological sort ro khoroji midahim!
for(int i = 0; i &lt; topologic.size(); i++)
cout &lt;&lt; topologic[i] &lt;&lt; ' ';
cout &lt;&lt; endl;
return 0;
}</pre><p><b>پی نوشت۱ :</b> دقت کنید که الگوریتم بالا در صورتی جواب درست را می‌دهد که گرافی بدون دور به عنوان ورودی بگیرد. بعد‌ها الگوریتم پیدا کردن دور در گراف جهت دار را شرح خواهیم داد.
</p><p><b>پی نوشت۲ :</b> در آخر ترتیب توپولوژیکی که به دست می‌اوریم, یال ها از راست به چپ هستند(به عبارتی یال ها از ایندکس بزرگ تر به ایندکس کوچک تر هستند. برعکس ترتیبی که در <b>قضیه 3.3.2</b> آوردیم).
</p><h1>مولفه‌های قویا همبند</h1><h2>مفاهیم اولیه</h2><h3><b>تعریف 3.4.1 (جفت راس قویا همبند)</b></h3><p>در گراف جهت‌­دار به جفت راس 
$ (v, u) $
قویا همبند گوییم اگر و تنها اگر مسیری از 
$ v $
به 
$ u $
و مسیری از 
$ u $
به 
$ v $
وجود داشته باشد.
</p><p>به عنوان مثال در شکل 1، راس­‌های 2 و 4 یک جفت راس قویا همبند هستند.
</p><h3><b>تعریف 3.4.2 (گراف قویا همبند)</b></h3><p>گراف قویا همبند، گراف جهت­‌داری است که هر جفت راس آن قویا همبند باشند (شکل 1).
</p><img src="/_static/scc_1.png"><h3><b>تعریف 3.4.3 (مولفه قویا همبند (strongly connected component یا به اختصار scc))</b></h3><p>یک مولفه قویا همبند در گراف جهت­‌دار 
$ G $
، زیرمجموعه­‌ای از رئوس 
$ G $
می­‌باشند که در زیرگراف القایی آن­‌ها تشکیل یک گراف قویا همبند را دهد و همچنین ماکسیمال باشد، یعنی نتوان راس دیگری به آن اضافه کرد.
</p><h3><b>لم 3.4.4</b></h3><p><b>صورت لم:</b> هر راس 
$ v $
در گراف جهت­‌دار 
$ G $
، تنها در یک مولفه قویا همبند یکتا قرار دارد.
</p><p><b>اثبات:</b> از برهان خلف استفاده می­‌کنیم. فرض کنید که 
$ v $
در دو مولفه قویا همبند 
$ H $
و 
$ L $
قرار دارد و 
$ u $
راسی در 
$ L $
باشد که در 
$ H $
قرار ندارد. چون 
$ u $
و 
$ v $
در یک مولفه قویا همبند قرار دارند، در نتیجه از هر راسی در 
$ H $
می­‌توان با مسیری به 
$ v $
آمد و سپس با مسیری به 
$ u $
رفت و همچنین با مسیری از 
$ u $
به 
$ v $
آمد و با مسیری به هر راس دلخواه در 
$ H $
رفت. پس درنتیجه می­‌توان راس 
$ u $
را به مولفه 
$ H $
اضافه کرد که این با ماکسیمال بودن 
$ H $
در تناقض است. از تناقض حاصل درستی حکم نتیجه می‌­شود.
</p><h3><b>نتیجه 3.4.5</b></h3><p>می­‌توان هر گراف جهت‌­دار 
$ G $
را به مولفه‌­های قویا همبند افراز کرد. شکل 2 گراف جهت­‌داری را نمایش می­‌دهد که مولفه‌­های قویا همبند آن مشخص شده­‌اند.
</p><img src="/_static/scc_2.png"><h3><b>تعریف 3.4.6 (گراف معکوس)</b></h3><p>گراف معکوس 
$ G $
، گرافی است که از معکوس کردن جهت یال‌های گراف 
$ G $
بدست می‌آید. توجه کنید یک گراف قویا همبند است اگر و تنها اگر معکوس آن نیز قویا همبند باشد.
</p><h2>بدون دور بودن مولفه‌­های قویا همبند</h2><h3><b>تعریف 3.4.7 (گراف فشرده شده مولفه­های قویا همبند)</b></h3><p>فرض کنید 
$ G $
، یک گراف جهت­‌دار دلخواه باشد و گراف جهت­‌دار 
$ H $
گرافی باشد که هر راس آن متناظر با یک مولفه قویا همبند در 
$ G $
است و هر مولفه قویا همبند در 
$ G $
به دقیقا یک راس در 
$ H $
متناظر شود. اگر 
$ v $
راسی در 
$ H $
باشد، مولفه قویا همبند متناظر با راس 
$ v $
در 
$ G $
را با 
$ F(v) $
نمایش می‌­دهیم. اگر 
$ v $
و 
$ u $
دو راس از 
$ H $
باشند، به ازای هر یال جهت‌­دار از رئوس 
$ F(v) $
به رئوس 
$ F(u) $
، یالی جهت­‌دار از 
$ v $
به 
$ u $
قرار دارد و همچنین هر یالی که از 
$ v $
به 
$ u $
است، متناظر با یالی از رئوس 
$ F(v) $
به رئوس 
$ F(u) $
می­‌باشد. در این صورت به 
$ H $
، یک گراف فشرده شده مولفه‌­های قویا همبند 
$ G $
می‌­گوییم.
</p><h3><b>قضیه 3.4.8</b></h3><p><b>صورت قضیه:</b> هر گراف فشرده شده مولفه­‌های قویا همبند، دور ندارد.
</p><p><b>اثبات:</b> فرض کنید 
$ G $
یک گراف جهت‌­دار دلخواه است و 
$ H $
، گراف فشرده شده مولفه­‌های قویا همبند 
$ G $
باشد.از برهان خلف استفاده می‌­کنیم. فرض کنید 
$ H $
دور داشته باشد و دو راس مانند 
$ v $
و 
$ u $
از 
$ H $
در یک دور قرار داشته باشند. چون از هر راس در یک مولفه قویا همبند به هر راس آن مولفه مسیر هست، پس در نتیجه می‌­توان از هر راس در 
$ F(v) $
به هر راس در 
$ F(u) $
رفت و همچنین از هر راس در 
$ F(u) $
به هر راس در 
$ F(v) $
مسیری جهت­‌دار وجود دارد (چرا؟) که یعنی رئوس 
$ F(v) $
و 
$ F(u) $
باید در یک مولفه قویا همبند قرار بگیرند که این با فرض ماکسیمال بودن مولفه‌­های قویا همبند در تناقض است. پس در نتیجه 
$ H $
دور ندارد و حکم اثبات می‌­شود.
</p><h3><b>نتیجه 3.4.9</b></h3><p>طبق قضیه 3.3.2، می­‌توان رئوس هر گراف فشرده شده مولفه­‌های قویا همبند را توپولوژیک سورت کرد. پس در نتیجه می‌­توان مولفه­‌های قویا همبند هر گراف جهت‌داری را به صورت توپولوژیک سورت کنار هم قرار دهیم، یعنی به این صورت که جهت همه یال­‌هایی که بین دو مولفه متفاوت باشند، به یک سمت باشند (شکل 3).
</p><img src="/_static/scc_3.png"><h2>پیدا کردن مولفه­‌های قویا همبند</h2><p>حال قصد داریم الگوریتمی با پیچیدگی زمانی مناسب برای پیدا کردن مولفه­‌های قویا همبند یک گراف ارائه دهیم.
</p><h3><b>الگوریتم کساراجو</b></h3><p><b>شرح:</b> ابتدا روی کل گراف 
$ DFS $
می­‌زنیم و هربار هنگام خروج از هر راس آن را در یک پشته می‌­اندازیم (توجه کنید هر چه از راسی دیرتر خارج شویم، در پشته بالاتر قرار می‌گیرد). حال گراف معکوس را درنظر می­‌گیریم و در هر مرحله از بین تمام راس‌های دیده نشده، راسی که در پشته بالاتر از بقیه قرار دارد (مانند 
$ v $
) را برداشته و از آن در گراف معکوس، 
$ DFS $
می‌­زنیم و 
$ v $
و تمام راس­‌هایی که دیده می‌­شوند (از طریق 
$ DFS $
زدن از راس 
$ v $
) را در یک مولفه جدید قرار می‌­دهیم و این کار را تا پیدا شدن تمام مولفه­‌های قویا همبند ادامه می‌­دهیم. توجه کنید که هنگام 
$ DFS $
زدن بر روی گراف معکوس، زمانی که راسی دیده می‌­شود، آن را به عنوان دیده شده علامت زده و در سری‌­های بعد از آن 
$ DFS $
نمی­‌زنیم و یا به آن وارد نمی‌­شویم.
</p><p><b>اثبات درستی:</b> برای اثبات این الگوریتم, ابتدا به لم زیر که مشابه آن را در بخش قبل داشتیم توجه کنید.
</p><p>تعریف می‌کنیم
$ f(v) $
به معنای زمان تمام شدن پیمایش برای راس 
$ v $
. به عبارتی داریم موقعیت یک راس را در پشته مشخص می‌کنیم(هر چه
$ f(v) $
بیشتر باشد, راس در پشته در جایگاه پایین‌تری قرار می‌گیرد).
</p><p><b>لم ۱:</b> اگر
$ f(u) > f(v) $
و به عبارتی راس
$ u $
در پشته, بالا تر از راس
$ v $
باشد, و همچنین مسیری از 
$ v $
به
$ u $
باشد, آنگاه مسیری از 
$ u $
به 
$ v $
نیز وجود دارد.
</p><p><b>برهان لم۱:</b> از برهان خلف استفاده می‌کنیم. فرض کنید مسیری از
$ v $
به 
$ u $
است و  هیچ مسیری از 
$ u $
به
$ v $
نباشد.
</p><p>آنگاه چون ما در ابتدا راس 
$ u $
را در پیمایش دیده‌ایم(چرا؟) و مسیری از 
$ u $
به
$ v $
نیست, پس هیچگاه راس 
$ v $
را پیمایش نمیکنیم, مگر اینکه پیمایش راس 
$ u $
تمام شود. از طرفی اگر پیمایش راس
$ u $
تمام شود و هنوز راس 
$ v $
را ندیده باشیم, نتیجه می‌شود که اول 
$ u $
به پشته اضافه می‌شود و بعد
$ v $
به عبارتی
$ f(u) < f(v) $
که این خلاف فرض است. پس لم ثابت شد!
</p><p>حال توجه داشته باشید در هنگام پیمایش گراف معکوس, روی معکوس یال‌ها حرکت می‌کنیم. یعنی عضو بالای پشته که راس 
$ v $
باشد را برمی‌داریم و روی همه راس‌هایی مثل
$ x $
که از 
$ x $
به
$ v $
مسیر هست پیمایش می‌کنیم. در این‌صورت طبق لم۱، راس 
$ v $
هم به راس
$ x $
مسیر دارد!
</p><p>پس 
$ v $
و همه رئوسی که در پیمایش گراف معکوس از 
$ v $
دیده شدند در یک مولفه قرار می‌گیرند!
</p><p>از طرفی هیچ راس دیگری در این مولفه نیست. زیرا در غیر این صورت اگر راس دیگری در این مولفه قرار می‌گرفت، باید حداقل یک مسیر به 
$ v $
می‌داشت و جزو ر‌ئوس دیده‌شده از 
$ v $
شمرده می‌شد.
</p><h3><b>پیچیدگی الگوریتم</b></h3><p>در الگوریتم بالا صرفا ۲ بار از 
$ DFS $
استفاده کردیم, در نتیجه پیچیدگی الگوریتم برابر با
$ O(n + m) $
است که
$ m, n $
به ترتیب تعداد راس‌ها و یال‌ها می‌باشند.
</p><h3><b>لم 3.4.10</b></h3><p><b>صورت لم:</b> الگوریتم کساراجو، مولفه‌های قویا همبند را به ترتیب توپولوژیک سورت آن‌ها آن‌ها پیدا می‌کند.
</p><p><b>اثبات:</b> به استقرا بر روی تعداد مولفه‌های قویا همبند حکم را ثابت می‌کنیم. به ازای یک مولفه که درستی حکم بدیهی است. حال اگر فرض بر درستی حکم به ازای 
$ n-1 $
مولفه باشد، حکم را به ازای 
$ n $
مولفه ثابت می‌کنیم. اگر به مولفه اولی که در الگوریتم پیدا می‌کنیم (مانند 
$ H $
) از مولفه دیگری مانند 
$ L $
یالی وارد شود، در این صورت در گراف معکوس، از 
$ H $
به 
$ L $
یال هست و چون در الگوریتم، 
$ L $
بعد از 
$ H $
پیدا می‌شود، پس در هنگام پیمایش 
$ H $
در گراف معکوس، باید تعدادی از راس‌های 
$ L $
دیده شوند و در 
$ H $
قرار گیرند در صورتی که مولفه‌ها نمی‌توانند اشتراک داشته باشند. پس در نتیجه مولفه اولی که پیدا می‌کنیم یالی از سمت مولفه‌های دیگر به آن وارد نمی‌شود و اولین مولفه در توپولوژیک سورت می‌باشد. حال طبق فرض استقرا باقی مولفه‌ها نیز به ترتیب توپولوژیک سورت پیدا می‌شوند (چرا؟) و حکم اثبات می‌شود.
</p><h3><b>پیاده‌سازی الگوریتم</b></h3><p>توجه کنید انتها کد، مولفه ها را به ترتیب توپولوژیک سورت آن‌ها خروجی می‌دهیم.
</p><pre dir="ltr">cpp
const int MX = 5e5 + 5;
int n, m; /// tedad ras ha va yal ha
vector&lt;int&gt; gr[MX], back_gr[MX], comp[MX]; /// vector mojaverat, vector mojaverat(yal haie barax), moalefe haie ghavian hamband
stack&lt;int&gt; sk; /// moratab kardan ras ha barhasbe tamam shodan dfs
bool mark[MX]; /// array mark baraie check kardane dide shodan ras ha
void dfs(int v){  /// dfs mamoli!
mark[v] = 1;
for(int u: gr[v])
if(!mark[u])
dfs(u);
sk.push(v);
}
void back_dfs(int v, int cnt){  /// dfs roie yal haie barax!
mark[v] = 1;
comp[cnt].push_back(v);
for(int u: back_gr[v])
if(!mark[u])
back_dfs(u, cnt);
}
int main(){
cin &gt;&gt; n &gt;&gt; m;
for(int i = 0; i &lt; m; i++){
int v, u;
cin &gt;&gt; v &gt;&gt; u; /// shomare ras ha 0-based hast.
gr[v].push_back(u); /// in vector yal ha ra zakhire mikonad
back_gr[u].push_back(v); /// in vector barax yal ha ra zakhire mikonad
}
for(int i = 0; i &lt; n; i++)
if(!mark[i])
dfs(i);
fill(mark, mark + n, 0); /// chon mikhahim dfs jadid bezanim, mark ra 0 mikonim.
int cnt = 0;
while(sk.size() != 0){ /// stack kheili kond ast. dar inja serfan baraie dark behtar stack estefade shode. behtar ast az vector estefade konid.
if(!mark[sk.top()]){
back_dfs(sk.top(), cnt); /// yek moalefe ra peida mikonim
cnt++;
}
sk.pop();
}
/// moalefe hara be tartib topo sort eshan chap mikonim
for(int i = 0; i &lt; cnt; i++){
cout &lt;&lt; i &lt;&lt; &quot;: &quot;;
for(auto v: comp[i])
cout &lt;&lt; v &lt;&lt; ' ';
cout &lt;&lt; endl;
}
return 0;
}</pre><h1>تشخیص دور داشتن گراف جهت دار</h1><h2>مقدمه</h2><p>در بخش های قبلی, گاهی لازم می‌شد تشخیص دهیم یک گراف جهت‌دار دور دارد یا خیر! برای مثال برای اینکه یک ترتیب توپولوژیک از گراف ارائه دهیم, ابتدا باید مطمئن شویم گراف بدون دور است. زیرا گرافی که دور دارد, هیچ ترتیب توپولوژیکی ندارد!
</p><p>در اینجا به شرح دو الگوریتم می‌پردازیم که می‌توانند دوری بودن گراف را تشخیص دهند. از طرفی در الگوریتم اول, یک دور در گراف خروجی می‌دهیم!
</p><h2>الگوریتم پیدا کردن دور با استفاده از DFS</h2><p><b>شرح:</b> این الگوریتم مشابه با الگوریتم بخش 3.3 می‌باشد با این تفاوت که در اینجا  برای هر راس دو نوع علامت‌گذاری خواهیم داشت. به این صورت که گراف را با استفاده از 
$ DFS $
پیمایش می‌کنیم و هر راس را هنگامی که به آن وارد می‌شویم، به عنوان یک راس دیده شده و زمانی که از آن راس خارج می‌شویم، به عنوان یک راسی که از آن خارج شده‌ایم، علامت‌گذاری می‌کنیم. حال اگر در زمان پیمایش به راسی برسیم که از آن را دیده‌ایم ولی از آن خارج نشده‌ایم، به این نتیجه می‌رسیم که گراف دور دارد و در غیر این صورت گراف بدون دور است.
</p><p><b>اثبات درستی:</b> زمانی که در حال پیمایش گراف هستیم، اگر در راسی مانند 
$ v $
قرار داشتیم و به راسی مانند 
$ u $
رسیدیم که آن را دیده‌ایم ولی همچنان از آن خارج نشده‌ایم (راس های مسیر خاکستری)، این به این معناست که یالی جهت‌دار از 
$ v $
به 
$ u $
وجود دارد (یال قرمز) و 
$ u $
مسیری جهت‌دار به 
$ v $
دارد که در این صورت گراف دور خواهد داشت. همچنین اگر گراف دور داشته باشد، این الگوریتم حتما آن را پیدا خواهد کرد، زیرا در غیر این صورت اگر فرض کنیم 
$ G $
گرافی با حداقل یک دور باشد که الگوریتم دور را در آن پیدا نکرده باشد، اگر 
$ v $
اولین راسی باشد که از دور 
$ C $
به آن وارد شده‌ایم و 
$ e $
یالی از 
$ u $
به 
$ v $
باشد که در دور 
$ C $
قرار دارد، در این صورت در پیمایش، قبل از خارج شدن از 
$ v $
به 
$ u $
می‌رسیم (زیرا این دو راس در یک دور هستند و حتما از 
$ v $
به 
$ u $
مسیر هست) و با استفاده از یال 
$ e $
دوباره به 
$ v $
می‌رسیم که یعنی دور پیدا کرده‌ایم. پس از تناقض حاصل نتیجه می‌شود که الگوریتم دور را در هر گرافی که دور دارد، پیدا می‌کند.
</p><img src="/_static/dot/Cycle_DFS.svg"><h3>پیچیدگی الگوریتم</h3><p>در الگوریتم یک بار از 
$ DFS $
استفاده کردیم که در نتیجه پیچیدگی آن برابر با 
$ O(m+n) $
است که 
$ n $
تعداد راس‌ها و 
$ m $
تعداد یال‌ها می‌باشد.
</p><h3>پیاده‌سازی الگوریتم</h3><p>توجه کنید که در پیاده‌سازی زیر در صورت داشتن دور، دور پیدا شده و در صورت نداشتن دور، ترتیب توپولوژیک راس‌ها را خروجی می‌دهیم.
</p><pre dir="ltr">cpp
const int MX = 5e5 + 200;
int n, m;
vector&lt;int&gt; gr[MX], topo, cycle;
bool st[MX], ed[MX];
bool dfs(int v){
st[v] = 1;
for(int u: gr[v]){
if(st[u] &amp;&amp; !ed[u]){
cycle.push_back(u);
cycle.push_back(v);
return 0;
}
if(!st[u] &amp;&amp; !dfs(u)){
if(cycle[0] != cycle[cycle.size() - 1])
cycle.push_back(v);
return 0;
}
}
ed[v] = 1;
topo.push_back(v);
return 1;
}
int main(){
cin &gt;&gt; n &gt;&gt; m;
for(int i = 0; i &lt; m; i++){
int v, u;
cin &gt;&gt; v &gt;&gt; u;
gr[v].push_back(u);
}
bool check = 1;
for(int i = 0; i &lt; n; i++){
if(!st[i] &amp;&amp; !dfs(i)){
check = 0;
break;
}
}
if(check){
cout &lt;&lt; &quot;no cycle \ntopo order: &quot;;
for(int v: topo)
cout &lt;&lt; v &lt;&lt; ' ';
}
else{
cout &lt;&lt; &quot;cycle: &quot;;
for(int i = cycle.size() - 2; i &gt;= 0; i--)
cout &lt;&lt; cycle[i] &lt;&lt; ' ';
}
return 0;
} </pre><h2>الگوریتم کان (kahn)</h2><p><b>شرح:</b> روش دیگری برای فهمیدن اینکه یک گراف دور دارد یا نه, الگوریتم کان است. این الگوریتم بر پایه استقرا عمل می‌کند. این روش با قضیه 3.3.2 بسیار شبیه می‌باشد!
</p><p>الگوریتم به اینصورت است که در ابتدا یک مجموعه خالی از راس ها داریم که آن را 
$ zero $
می‌نامیم. این مجموعه, مجموعه راس هایی هست که در گراف کنونی درجه ورودی‌شان 0 است.
</p><p>در ابتدا, راس هایی که درجه ورودی‌شان 0 است را به 
$ zero $
اضافه می‌کنیم.
</p><p>در هر مرحله, مجموعه راس هایی که در 
$ zero $
هستند را به همراه یال‌هایشان از گراف حذف می‌کنیم و به دنبال این‌کار, ممکن است یک سری راس جدید درجه ورودی‌شان 0 شود و به 
$ zero $
اضافه شوند. این‌کار را آنقدر ادامه می‌دهیم تا یا تعداد راس های گراف برابر با 0 شود و یا اینکه مجموعه 
$ zero $
خالی شود.
</p><p>اگر در یک مرحله اندازه مجموعه
$ zero $
برابر با 0 بود و گراف کنونی هنوز شامل تعدادی راس بود, آنگاه گراف حتما دور دارد و اگر این اتفاق نیفتاد و همه راس ها از گراف حذف شدند, آنگاه گراف دور ندارد.
</p><img src="/_static/dot/Cycle_Kahn.svg"><p>برای درک بهتر, شکل روبرو را ببینید. در این شکل, دور آبی رنگ هیچگاه به مجموعه 
$ zero $
وارد نمی‌شود و بنابراین گراف دوری تشخیص داده می‌شود!
</p><p><b>اثبات درستی:</b> برای اثبات الگوریتم دو حالت از گراف را در نظر می‌گیریم. ابتدا فرض کنید گراف 
$ G $
دور داشته باشد, آنگاه ادعا می‌کنیم الگوریتم به درستی دور داشتن را تشخیص می‌دهد.
</p><p>اگر 
$ G $
دور داشته باشد, آنگاه اگر این دور را 
$ C $
بنامیم, هیچکدام از راس های
$ C $
هیچگاه به 
$ zero $
اضافه نمی‌شوند(چرا؟). پس به جایی می‌رسیم که گراف هنوز شامل تعدادی راس است, اما 
$ zero $
خالی است! پس الگوریتم دور داشتن را تشخیص می‌دهد.
</p><p>حال اگر گراف دور نداشته باشد, با استقرا روی تعداد راس ها ثابت می‌کنیم که همه راس ها حذف می‌شوند!
</p><p>اولا که اگر گراف دور نداشته باشد, طبق قضیه 3.1.3 تعداد راس در گراف
$ G $
هستند که دردجه ورودی‌شان 0 است. پس این راس ها به مجموعه 
$ zero $
اضافه می‌شوند, سپس به همراه یال‌هایشان از گراف حذف می‌شوند. پس تعداد راس ها کم شد. از طرفی شرایط استقرا برقرار است و گراف کنونی دور ندارد. پس طبق استقرا همه راس ها از گراف حذف ‌می‌شوند و الگوریتم به درستی دور نداشتن را تشخیص می‌دهد.
</p><h3>پیچیدگی الگوریتم</h3><p>برای بررسی پیچیدگی الگوریتم, باید ببینیم که روی راس ها و یال ها چه مقدار پیمایش کردیم. ما زمانی روی یال ها پیمایش می‌کنیم که راسی در مجموعه
$ zero $
باشد, آنگاه روی یال های مجاور آن راس پیمایش می‌کنیم. از طرفی هر راس فقط یکبار در
$ zero $
می‌آید و پس از آن از گراف حذف می‌شود. پس ما روی هر یال یکبار پیمایش میکنیم.
</p><p>از طرفی هنگامی روی راس ها پیمایش میکنیم که  راس در مجموعه
$ zero $
قرار گیرد. و مشابها, هر راس فقط یک بار به این مجموعه اضافه می‌شود و پس از آن از گراف حذف می‌شود.
</p><p>پس پیچیدگی الگوریتم بالا برابر است با
$ O(n + m) $
است که مشابه با الگوریتم قبلی است!
</p><h3>پیاده‌سازی الگوریتم</h3><pre dir="ltr">cpp
const int maxn = 5e5 + 5;
int n, m; // tedad ras ha va yal ha
int in_edge[maxn]; // in_edge[v] daraje vorodi rase v hast!
vector &lt;int&gt; g[maxn]; // vector e mojaverat
vector &lt;int&gt; zero; // ras haie ke daraje vorodi 0 daran va baiad hazf shan!
bool has_cycle(){
for(int i = 0; i &lt; n; i++){
if(in_edge[i] == 0){
zero.push_back(i); 
}	   
}
for(int i = 0; i &lt; n; i++) {
if(zero.size() == 0){
return true;
}
int v = zero[zero.size() - 1]; // ozve akhar az remove_set
zero.pop_back();
for(int u : g[v]){
in_edge[u]--;
if(in_edge[u] == 0){
zero.push_back(u);
}
}
}
return false;
}
int main(){
cin &gt;&gt; n &gt;&gt; m;
for(int i = 0; i &lt; m; i++){
int u, v;
cin &gt;&gt; u &gt;&gt; v; // u, v 0-based hastan
g[u].push_back(v);
in_edge[v]++; // yale (u, v) dar graph ast. pas daraje vorodi v yeki ziad mishe!
}
if(has_cycle())
cout &lt;&lt; &quot;graph has at least one cycle!&quot; &lt;&lt; endl;	    
else 
cout &lt;&lt; &quot;graph is acyclic!&quot; &lt;&lt; endl;
return 0;
}</pre><h1>بازی‌ها و گراف جهت‌دار</h1><h2>مقدمه</h2><p>در این قسمت، به بررسی ارتباط بازی ها و گراف های جهت دار می‌پردازیم.
</p><p>کار را با یک مثال ساده شروع می‌کنیم:
</p><p>علی و متین مشغول بازی هستند. یک کیسه سنگریزه شامل 10 سنگریزه جلوی آن‌ها قرار دارد. در هر مرحله، کسی که نوبش است، 1 یا 2 سنگریزه از کیسه بر می‌دارد. بازنده بازی کسی است که با کیسه خالی مواجه شود و نتواند سنگریزه بردارد.
</p><p>فرض کنید متین بازی را شروع می‌کند. اگر هر دو نفر به بهترین نحو بازی کنند، برنده بازی چه کسی خواهد بود؟
</p><h2>بررسی یک مثال</h2><p>در این بخش، مثالی که در بخش مقدمه مطرح کردیم را توضیح می‌دهیم.
</p><p>یک گراف 11 راسی می‌سازیم که شماره راس های آن، از 0 تا 10 هستند. از راس
$ i $
به راس
$ j $
یک یال جهت‌دار رسم می‌کنیم، اگر بتوان با برداشتن 1 یا 2 سنگریزه از
$ i $
به
$ j $
رسید.
</p><p>کنار هر راس یک حرف
$ L(Lose) $
یا 
$ W(Win) $
می‌نویسیم(یا اینکه هیچی نمی‌نویسیم،‌ که یعنی وضعیت این راس، هنوز مشخص نشده).
</p><p>فرض کنید کنار راس با شماره 
$ i $
حرف
$ L $
را نوشته‌ایم. معنای آن این است که اگر کیسه اولیه که دو نفر روی آن بازی می‌کنند،
$ i $
سنگریزه داشته باشد،‌ اگر هر دو نفر به بهترین شکل بازی کنند،‌ نفر اول بازنده آن بازی است.
</p><p>و برعکس،‌ فرض کنید کنار راس با شماره 
$ i $
حرف
$ W $
را نوشته‌ایم. معنای آن این است که اگر کیسه اولیه که دو نفر روی آن بازی می‌کنند،
$ i $
سنگریزه داشته باشد،‌ اگر هر دو نفر به بهترین شکل بازی کنند،‌ نفر اول برنده آن بازی است.
</p><p>حال در ابتدای بازی، به کدام راس می‌توان
$ L $
یا 
$ W $
را نسبت داد؟!
</p><p>با کمی فکر، متوجه می‌شیم راس با شماره 0. به این معنا که اگر کیسه اولیه، شامل 0 سنگریزه باشد، طبق قوانین بازی، نفر اول، بازنده است. چون نمی‌تواند سنگریزه ای بردارد.
</p><p>پس به راس 0،
$ L $
را نسبت می‌دهیم.
</p><p>حال راس بعدی  که تکلیف آن مشخص می‌شود کدام است؟
</p><p>راس 1 را در نظر بگیرید. اگر کیسه فقط 1 سنگریزه داشته باشد، نفر اول می‌تواند فقط یک سنگریزه بردارد. حال اگر دقت کنیم، میبینیم کیسه ای که بعد از حرکت نفر اول مانده است، شامل 0 سنگریزه است که قبلا تکلیف آن را مشخص کردیم.
</p><p>قبلا گفتیم که وضعیت راس 0، 
$ L $
می‌باشد. پس وضعیت راس 1، برابر با
$ W $
می‌شود. چون اگر دقت کرده باشید، وقتی نفر اول، یک سنگریزه برداشت،‌ جای نفر اول و دوم بازی عوض شده(چون نوبت عوض شد). بنابراین راس 0، نشان دهنده باخت نفر دوم بازی(علی) است.
</p><h3><b>نتیجه</b></h3><p>وضعیت راس ها، یعنی همان
$ L $
یا 
$ W $
را، به ترتیب شماره راس ها مشخص می‌کنیم.
</p><p>برای این کار، اگر راس
$ u $
بین راس هایی که
$ v $
به آن یال جهت دار دارد وجود داشت که وضعیتش برابر با 
$ L $
بود، آنگاه وضعیت راس 
$ v $
برابر با
$ W $
می شود. و اگر همه راس هایی که
$ v $
به آنها یال داشت، وضعیت شان
$ W $
بود، آنگاه وضعیت راس
$ v $
برابر با
$ L $
می شود.
</p><p>با این روش، می‌توان وضعیت همه راس ها را مشخص کرد. حال کافی است به حالت اولیه بازی نگاه کنیم و ببینیم
$ L $
است یا
$ W $.
اگر
$ L $
بود، یعنی نفر اول بازنده بازی است. و اگر وضعیت
$ W $
بود، یعنی نفر اول برنده است. با این کار، می‌توان فهمید در بازی‌ای که بالا تر مشخص کردیم، علی برنده بازی است یا متین!
</p><h2>بازی حرکت مهره روی گراف </h2><p>بازی ما به این صورت است که یک گراف داریم و در ابتدا یک مهره روی راس شروع است. بازیکنان به نوبت حرکت می کنند و هر بازیکن در نوبتش مهره را روی یک راس مجاور می برد. کسی که نتواند حرکتی کند بازنده بازی است.
</p><h3>تعمیم</h3><p>اگر به ماهیت اکثر بازی ها توجه کنید درون آن ها چنین گرافی خواهید دید! در واقع ذات بازی های ترکیبیاتی به این صورت است که دو نفر یا بیشتر روی منابعی مشترک تغییراتی اعمال می کنند (منابع مشترک می تواند صفحه شطرنج باشد که مهره ها را روی آن حرکت می دهیم یا می تواند یک کیسه باشد که از آن سنگ بر می داریم).
</p><p>حالا فرض کنید به ازای هر وضعیت از منابع مشترک و اینکه نوبت چه کسی است یک راس بسازیم و راس $ A $ را به $ B $ یال جهت دار بزنیم اگر و تنها اگر فردی که در وضعیت $ A $ نوبتش است بتواند در نوبتش به $ B $ برود. حالا یک گراف داریم! ما توانستیم بازی خود را روی یک گراف تعریف کنیم. 
</p><p>پس به صورت شهودی قبول می کنیم که اکثر بازی ها می توانند به بازی حرکت مهره روی گراف (که در بالا گفتیم) تبدیل شود. برای مثال، بازی شطرنج را در نظر بگیرید. هر وضعیت از این بازی، یک صفحه شطرنج با چینش مختلف مهره‌ها است.
</p><h3>حل بازی روی گراف</h3><p>اگر بتوانیم بازی حرکت مهره روی گراف را حل کنیم گام بزرگی در فهم روش حل اکثر بازی ها برداشته ایم. برای حل این بازی به این صورت عمل می کنیم. به هر راس یک برچسب برد (W)، باخت(L) یا تساوی(D) نسبت می دهیم. به سه نکته زیر توجه کنید.
</p><ul><li><p>راسی که یال خروجی نداشته باشد حتما L است.
</p></li><li><p>راسی که مجاور L داشته باشد حتما W است.
</p></li><li><p>اگر بازیکنی استراتژی نباختن داشته باشد امکان ندارد که مهره را به یک راس با برچسب W ببرد (زیرا در اینصورت حریفش می تواند ببرد).
</p></li></ul><p>پس این الگوریتم را روی گرافمان پیاده می کنیم. تا زمانی که راسی مثل $ u $ بود که یال خروجی نداشت روی آن برچسب $ L $ می زنیم سپس روی تمام راس هایی مثل $ v $ که $ v $ به $ u $ یال دارد برچسب W می زنیم.
سپس تمام راس هایی که روی آنها برچسب زدیم را از گراف حذف می کنیم. چرا؟ چون مطمئنیم که اگر بازیکن بخواهد مهره را به $ v $ برساند باید قبل از آن به راسی که روی آن W نوشته شده برسد و هیچکدام از بازیکنان دوست ندارند که مهره را روی راس های W ببرند. 
</p><p>در نهایت زمانی می رسد که هر راس از گراف باقی مانده حداقل یک خروجی دارد. از هر کدام از راس های گراف که شروع کنیم بازی هیچگاه تمام نخواهد شد و هر دو بازیکن می توانند بازی را تا ابد ادامه دهند! پس توانستیم راس ها را به سه دسته افراز کنیم و به ازای هر دسته می دانیم که اگر از راسی روی آنها شروع کنیم نتیجه بازی چه خواهد بود (برد، باخت یا تساوی). پس ما بازی حرکت مهره روی گراف را به صورت الگوریتمی حل کردیم.
</p><h3>چند نتیجه گیری سودمند</h3><p>اگر راسی به خودش یال داشته باشد آنگاه قطعا این راس
L
نخواهد بود. زیرا طبق الگوریتم تنها زمانی به یک راس برچسب
L
می زنیم که یال خروجی نداشته باشد. به صورت دقیق تر کسی که در حال حاضر
مهره اش روی این راس است می تواند به راحتی استراتژی نفر مقابل را
بدزدد. یعنی اگر تشخیص دهد نفر دیگر می تواند ببرد به راحتی از یال
طوقه استفاده می کند و این حرکت مثل این است که نوبت خودش و نفر بعد
را عوض کرده است، بعد از این می تواند از استراتژی نفر دیگر استفاده
کند. در مسائل این بخش مثال هایی از دزدیدن استراتژی آورده شده است.
</p><p>الگوریتمی که مطرح کردیم به شیوه دیگری برای گراف های بدون دور قابل بررسی است. این موضوع به خاطر ویژگی DAG ها یعنی داشتن ترتیب توپولوژیکی است. راس های گراف را به ترتیب توپولوژیکی می چینیم. حالا از آخر شروع می کنیم و یکی یکی راس ها را حذف می کنیم. اگر راسی که حذف می کنیم به یک L که جلو تر است یال داشته باشد روی آن W می نویسیم در غیر اینصورت L می نویسیم و در نهایت به تمام راس ها برد یا باخت نسبت داده می شود زیرا چنین بازی هایی همیشه پایان پذیر هستند.
</p><h2>حرف آخر</h2><p>به نظر می آید تبدیل کردن بازی ها به گراف راه موثری برای حل کردن آن ها می باشد اما در حقیقت اینطور نیست. 
</p><p>زیرا که در عمل خیلی از بازی ها بعد از تبدیل شدن به گراف تعداد راس های بسیار زیادی (یا حتی نامتناهی) خواهند داشت و از آنجایی که ما برای حل کردن بازی ها به اندازه تعداد راس ها و یال ها حافظه و زمان اجرا نیاز خواهیم داشت، حل کردن بسیاری از بازی ها به این شیوه امکان پذیر نیست.‌ (می توانید تخمین بزنید که بازی شطرنج بعد از تبدیل به گراف چند راس متفاوت خواهد داشت؟!).
</p><p>از طرف دیگر در خیلی از بازی ها تبدیل کردن به گراف می تواند شهود بهتری برای حل مسئله به ما بدهد و یا اینکه گراف ما بسیار خاص خواهد شد. پس نتیجه گیری این است که تبدیل کردن به گراف ابزار نسبتا قدرتمندی در حل و شهود پیدا کردن روی بازی ها می باشد اما همیشه پاسخگوی نیاز ما نخواهد بود.
</p><h1>گراف تابعی و گراف‌جایگشت</h1><h2>تعریف 3.7.1 (گراف‌جایگشت)</h2><p>جایگشت
$ P: p_{1}, p_{2}, p_{3}, ..., p_{n} $
از اعداد 1 تا n را در نظر بگیرید.
</p><p>گراف
$ n $
راسی
$ G $
را در نظر بگیرید که راس های آن از 1 تا n شماره‌گذاری شده‌اند.
</p><p>به ازای هر
$ 1 \le i \le n $
یک یال جهت‌دار از
$ i $
به
$ p_{i} $
می‌زنیم. به این گراف، گراف‌جایگشت می‌گوییم که از جایگشت
$ P $
ساخته شده.
</p><p>برای مثال، جایگشت 
$ P: 2, 3, 1, 5, 4, 6 $
را در نظر بگیرید. گراف‌ زیر، یک گراف‌جایگشت برای این جایگشت است:
</p><img src="/_static/dot/Permutation_Graph.svg"><h2>قضیه 3.7.2</h2><p><b>صورت قضیه :</b> راس‌های گراف‌جایگشت، به تعدادی دور افراز می‌شوند.
</p><p><b>اثبات قضیه :</b> برای هر راس از گراف‌جایگشت، درجه ورودی و خروجی آن،‌ دقیقا یک می‌باشد و می‌دانیم گراف جهت داری که درجه ورودی و خروجی هر راس آن، برابر با یک باشد، به تعدادی دور افراز می‌شود(چرا؟)!
</p><h2>قضیه 3.7.3</h2><p><b>صورت قضیه :</b> اگر در یک جایگشت، جای 2 تا از اعضای آن جابه‌جا شود، آن‌گاه در گراف جایگشت آن، تعداد دور ها دقیقا یکی تغییر می‌کند.
</p><p><b>اثبات قضیه :</b> اثبات قضیه برعهده خودتان می‌باشد.
</p><h1>انتخاب های اکسترمالی</h1><p>در فصل های قبل دیدیم که چگونه می توان با انتخاب یک چیز که خاصیت بزرگترین یا کوچکترین
بودن را دارد، می توان مسائل را به راحتی اثبات کرد. برای مثال بلند ترین مسیر یک
انتخاب اکسترمالی متداول است که خاصیت های آن در حل مسائل به ما کمک می کند. در این
بخش با انتخاب های اکسترمالی دیگر آشنا می شویم.
</p><p>هر انتخاب اکسترمالی خواصی دارد که می تواند در حل مسائل به ما کمک کند. در ادامه صرفا
خواص را ذکر می کنیم و اثبات این خواص (که عموما ساده است) به خواننده واگذار می شود.
</p><h2>کوتاه ترین مسیر بین دو راس</h2><h3>خواص</h3><ul><li><p>هیچ راسی از خارج این مسیر به دو راس در این مسیر که ۳ یال یا بیشتر فاصله دارند یال ندارد
</p></li><li><p>در نتیجه گزاره بالا، هر راس از خارج به حداکثر ۳ راس درون این مسیر یال دارد
</p></li><li><p>زیر گراف القایی رئوس این مسیر خود این مسیر است و هیچ یال دیگری در آن وجود ندارد
</p></li></ul><h2>بلند ترین مسیر گراف</h2><h3>خواص</h3><ul><li><p>تمام رئوس مجاور راس های ابتدا و انتهای این مسیر، درون این مسیر هستند.
</p></li><li><p>هیچ دو راس متوالی همسایه مشترک خارج از مسیر ندارند.
</p></li><li><p>اگر سر و ته این مسیر به هم متصل باشند، این مسیر تمام رئوس مولفه اش را داراست.
</p></li></ul><h2>کوچک ترین دور</h2><h3>خواص</h3><ul><li><p>زیر گراف القایی رئوس این دور خود این دور است و هیچ یال دیگری در آن وجود ندارد
</p></li><li><p>اگر طول این دور از ۴ بیشتر باشد، هر راس از بیرون این دور حداکثر به یک راس از این دور یال دارد.
</p></li></ul><h2>کوچک ترین دور فرد</h2><h3>خواص</h3><ul><li><p>زیر گراف القایی رئوس این دور خود این دور است و هیچ یال دیگری در آن وجود ندارد
</p></li><li><p>اگر طول این دور از سه بیشتر باشد، هر راس از بیرون این دور حداکثر به دو راس از این دور یال دارد.
</p></li></ul><h2>پایین ترین برگ در درخت ریشه دار</h2><p>منظور برگی از درخت است که بیشترین ارتفاع را دارد.
</p><h3>خواص</h3><ul><li><p>تمام فرزندان پدر این برگ، برگ هستند.
</p></li></ul><h1>منقبض کردن</h1><p>منقبض کردن یک دور عملی در گراف است که در آن یک دور را در نظر می گیریم و به جای رئوس
آن یک راس می گذاریم و به ازای هر راسی که در بیرون دور به یکی از راس های این دور یال داشته
باشد یالی بین این راس و راس جدیدی که گذاشتیم قرار می دهیم.
</p><h2>انتخاب مناسب برای منقبض کردن</h2><p>دوری که می خواهیم منقبض کنیم بهتر است یالی درون خودش نداشته باشد و بعد از منقبض کردن آن
گراف همچنان ساده بماند. برای مثال مثلث در یک گراف بدون بادبادک یا کمر گراف اگر بیش از
چهار راس داشته باشد این خواص را دارند و در نتیجه کاندید مناسبی برای منقبض کردن هستند.
</p><h2>یک مثال</h2><p>یک گراف ساده داریم که دور هایش اشتراک یالی ندارند و
$ 2n+1 $
راس دارد. بیشینه میزان یال های این گراف چیست؟
</p><p>پاسخ
$ 3n $
است.
</p><h3>مثال</h3><p>برای مثالی با این میزان یال، می توانید یک راس را در وسط گراف بگذارید و به ازای
هر دو راس، یک مثلث که شامل این راس هست نیز بسازید.
</p><h3>اثبات بیشینه بودن</h3><p>در این جا با استقرا ثابت می کنیم که در هر گرافی که دور هایش اشتراک یالی ندارند، 
$ 2m \le 3n-1 $
برقرار است.
کوچک ترین مثال نقض این قضیه را در نظر بگیرید. این گراف نمی تواند بدون دور باشد چون در این
صورت تعداد یال هایش از راس هایش کمتر است و یعنی حکم برایش برقرار است. واضح است که دور
های این گراف نمی توانند وتر داشته باشند. (یعنی یالی درون آن ها وجود داشته باشد) چون
در این صورت دو دور با اشتراک یالی به وجود می آید. و هم چنین یک راس نمی تواند به دو راس
از یک دور یال داشته باشد. پس یکی از دور های این گراف را منقبض می کنیم. گراف همچنان ساده
می ماند و می توان نشان داد که دور هایش همچنان اشتراک یالی ندارند. (این مطلب را ثابت کنید
تا روی انقباض شهود بگیرید. ) و چون کوچک ترین مثال نقض را در نظر گرفته بودیم، در گراف جدید
حکم برقرار است. اگر دوری به طول k را منقبض کرده باشیم، k یال و
$ k-1 $
راس از گراف حذف می شوند. پس داریم:
</p>$$ 2(m - k) \le 3(n - k + 1) - 1 $$<p>و از قبل می دانستیم که:
</p>$$ 2m > 3n - 1 $$<p>از این دو گزاره در می یابیم که:
</p>$$ 2k < 3(k + 1) $$<p>که یعنی دوری که حذف کردیم کم تر از ۳ راس داشته که در گراف های ساده ممکن نیست. از این مطلب
به تناقض می رسیم. با کمی دقت می توان دریافت که برابری تنها زمانی رخ می دهد که k دقیقا برابر
3 باشد و این یعنی تمام دور های گراف مثلث باشند. (همانگونه که مثال ما این شرط را داشت)
</p><h1>گراف و جادو</h1><p>بعضی از اوقات مسائل ترکیبیاتی با ایده های بسیار جذاب به گراف مدل سازی می شوند. در فضای گراف ها با ابزار های قدرتمندی که داریم (قضیه ها و شهود خوب روی گراف) می توان مسائل را به راحتی حل کرد.
</p><p>در این بخش قصد داریم شما را با چند مثال با جادوی مدل سازی با گراف آشنا کنیم!
</p><h2>درخت؟</h2><p>مجموعه $ S $ را مجموعه اعداد 1 تا $ n $ تعریف می کنیم و $ n $ زیرمجموعه $ A_1,A_2,...,A_n $ را از مجموعه $ S $ در نظر می گیریم که همه متمایزند. ثابت کنید عددی مثل $ x $ وجود دارد که اگر $ x $ را از $ A_i $ ها حذف کنیم همچنان $ A_i $ ها با هم متمایز باشند.
</p><h3>جواب</h3><p>چه زمان حذف کردن عددی مثل $ x $ از مجموعه ها موجب ایجاد دو مجموعه مساوی می شود؟ تنها زمانی که دو مجموعه مثل $ A_i, A_j $ وجود داشته باشند که تنها تفاوت آن ها در $ x $ باشند. یعنی همه اعداد به جز $ x $ یا در هر دو آمده باشند یا در هیچکدام نیامده باشند. 
</p><p>حالا مسئله را به اینصورت به گراف مدل سازی می کنیم که $ n $ راس در نظر می گیریم که هر کدام نماینده $ A_i $ ها هستند. بین دو راس $ u,v $ یالی با وزن $ w $ بکشید اگر تنها تفاوت $ A_u, A_v $ در عضو $ w $ باشد. حالا مسئله معادل این است که ثابت کنیم وزنی وجود دارد که بین یال ها نیامده است!
</p><p>طبق مدل سازی گرافمان هر بار که یالی با وزن $ w $ را طی کنیم عضو $ w $ از مجموعه فعلی مان حذف یا به آن اضافه می شود. پس در هر گذر بسته باید از هر وزن زوج تا داشته باشیم (زیرا وضعیت بودن یا نبودن هر عضو باید زوج بار تغییر کند تا بعد از طی کردن گذر به همان مجموعه اولیه برسیم).
</p><p>حالا برهان خلف بزنید که از هر وزن حداقل یک یال با این وزن داشته باشیم. پس از هر وزن یک یال دلخواه با این وزن را انتخاب کنید و گراف $ n $ یالی $ G $ را تشکیل دهید.
</p><p>ابتدا واضح است که گراف $ G $ دور ندارد. زیرا در صورت وجود دور باید از هر وزن زوج تا داشته باشیم که چون از هر وزن دقیقا یکی داریم ممکن نیست. پس $ G $ باید جنگل باشد. از طرفی گفتیم $ G $ دقیقا $ n $ یال دارد و می دانیم این ممکن نیست (زیرا بیشینه یال در جنگل مربوط به درخت است که $ n-1 $ یال دارد).
</p><p>پس می توانیم از تناقض حاصل نتیجه بگیریم وزنی هست که در بین یال ها ظاهر نشده است که حکم مسئله مان را ثابت می کند.
</p><h2>مثلث ها؟</h2><p>فرض کنید $ S $ مجموعه ای $ 2^n+1 $ عضوی باشد و $ f({x,y}) $ تابعی باشد که ورودی آن یک زیرمجموعه دو عضوی از $ S $ است و خروجی آن یک عدد بین 0 تا $ 2^{n-1}-1 $ می باشد. همچنین می دانیم به ازای هر $ x,y,z $ که سه عضو متفاوت $ S $ هستند از بین $ f({x,y}), f({x,z}), f({y,z}) $ یکی از آنها برابر جمع دو تای دیگر است. شما باید ثابت کنید $ x,y,z $ وجود دارند که $ f({x,y}), f({x,z}), f({y, z}) $ هر سه برابر با 0 هستند.
</p><h1>معرفی</h1><h2>تعاریف</h2><p>تور اویلری گذر بسته ای است که در آن هر یال دقیقا یک بار طی شود.
دور همیلتونی دور ای است که در آن هر راس دقیقا یک بار دیده شود همچنین مسیر همیلتونی مسیری است که در آن هر راس دقیقا یک بار دیده شود.
</p><p>به تفاوت گذر، گشت و مسیر توجه کنید!
</p><p>تعریف تور اویلری و دور همیلتونی بسیار شبیه به هم است اما همین یک تفاوت ریز (جایگزینی راس به جای یال) باعث شده است که مسئله پیدا کردن دور همیلتونی الگوریتم چند جمله ای نداشته باشد و در مقابل برای پیدا کردن تور اویلری می توان الگوریتم خطی ارائه داد!
</p><h2>پل های کونیگسبرگ</h2><p>در داستان ها آمده است که به وجود آمدن مفهوم گراف به مسئله پل های کونیگسبرگ بر می گردد.
کونیگسبرگ شهری بود که توسط رودخانه به چند ناحیه تقسیم شده بود و ارتباط بین ناحیه ها از طریق پل ها صورت می گرفت. بعد از مدتی برای شهروندان این سوال پیش آمد که آیا می توان از یکی از ناحیه ها شروع کرد و هر پل را دقیقا یک بار طی کرد و در انتها به شهر شروع بازگشت؟!
می توانید ببینید که مسئله دقیقا معادل پیدا کردن یک تور اویلری است.
</p><img src="/_static/Konigsberg_Bridges.png"><img src="/_static/dot/Konigsberg_Graph.svg"><h1>تور اویلری در گراف جهت دار و بی جهت</h1><h2>شرط لازم و کافی</h2><h3>گراف بدون جهت</h3><p>در ابتدا فرض کنید گراف مورد بحث یک گراف بدون جهت است. حالا شرط لازم و کافی وجود داشتن تور اویلری را بررسی می کنیم.
ابتدا راس های ایزوله گراف را حذف کنید. حالا لازم و کافی است که :‌
</p><ul><li><p>الف) گراف همبند باشد.
</p></li><li><p>ب) درجه هر راس زوج باشد.
</p></li></ul><p>ابتدا ثابت می کنیم دو شرط بالا لازم هستند.
</p><p>شرط الف به وضوح لازم است چون اگر دو یال در دو مولفه همبندی متفاوت باشد یک گذر نمی تواند همزمان شامل هر دوی آنها باشد.
</p><p>برای اثبات لازم بودن شرط ب توجه کنید که هر گاه به یک یال وارد می شویم باید بلافاصله از آن خارج شویم.(در مورد راس شروع دقت کنید) بنابرین تعداد یال های مجاور هر راس باید مضربی از ۲ باشند.
</p><p>حالا ثابت می کنیم دو شرط بالا کافی هستند. برای این کار از استقرا روی تعداد یال ها استفاده می کنیم.
</p><p>ابتدا فرض کنید یک گذر بسته داریم که از راس $ start $ شروع شده و به همان راس باز می گردد.
$ a_1 = start, a_2, ..., a_k = start $
که لزوما شامل همه یال ها نیست.
</p><p>حالا یال های این گذر را از گراف حذف کنید. گراف به چند مولفه همبندی افراز می شود. به هر مولفه اولین $ i $ را نسبت دهید که $ a_i $ درون آن مولفه باشد.
</p><p>حالا شروع به طی کردن گشتی که حذف کردیم بکنید. هر گاه به راس $ a_i $ رسیدیم به صورت استقرایی تور اویلری مولفه هایی که $ i $ به آن ها نسبت داده شده است را بسازید و آنها را طی کنید.
</p><p>در نهایت گشتی که طی کرده ایم تور اویلری گراف ما است!
</p><p>تنها یک قسمت از اثبات باقی می ماند. چرا توانستیم فرض کنیم یک گشت بسته شامل $ start $ وجود دارد؟
</p><p>کافیست از $ start $ شروع کنیم و در هر مرحله اگر در راس $ u $ باشیم که
$ u \neq start $
یک یال مجاور $ u $ را طی کنیم که قبلا طی نشده است و این کار را تا زمانی ادامه دهیم که دوباره به $ start $ برسیم.
</p><p>چرا چنین یالی وجود دارد؟ زیرا وقتی به راس $ u $ رسیده ایم فرد بار به این راس وارد شده ایم و زوج بار خارج شده ایم. پس تعداد یال هایی که قبلا طی شده است فرد است و از طرفی طبق فرض درجه هر راس زوج است. پس باید یک یال که قبلا طی نشده است وجود داشته باشد!
</p><h3>گراف جهت دار</h3><p>بررسی تور اویلری در گراف جهت دار بسیار مشابه گراف بدون جهت است. مشابه بالا ابتدا راس های ایزوله را حذف کنید سپس لازم و کافی است که :
</p><ul><li><p>الف) گراف زمینه (جهت دهی ها را در نظر نگیرید) همبند باشد.
</p></li><li><p>ب) $ {d^+}_u = {d^-}_u $
</p></li></ul><p>در اینجا $ {d^+}_u $ درجه خروجی راس $ u $ و $ {d^-}_u $ درجه ورودی راس $ u $ می باشد.
</p><p>اثبات لازم و کافی بودن مشابه اثبات برای گراف های بی جهت انجام می شود.
</p><h3>گراف نیم اویلری</h3><p>هر گرافی که دو راس فرد داشته باشد و بقیه رئوس زوج باشد را نیم اویلری میگویند . زیرا گذر اویلری دارد که راس شروع و پایانش دو راس فرد هستند . 
</p><p>در مورد گراف جهتدار هم به ازای هر راس $ u $ ، :math:`{d^+}_u = {d^-}_u`به جز دو راس که آن دو راس هم خروجی و ورودیشان تفاضلشان یک است و در یکی خروجی بزرگتر و در دیگری ورودی بزرگتر از خروجی است . 
</p><h2>پیاده سازی</h2><p>ابتدا گراف را با لینکد لیست ذخیره سازی می کنیم. در تابع <span class="pre">add_edge</span> (که در اینجا برای گراف جهت دار نوشته شده است) دو راس داده می شود به عنوان ورودی داده می شود و تابع یالی بین آن دو می کشد. (جهت دار یا بی جهت)
</p><p>توجه کنید که تفاوت کد پیدا کردن تور اویلری گراف جهت دار و بدون جهت تنها در تابع <span class="pre">add_edge</span> است.
</p><pre dir="ltr">cpp
const int max_edges = 1010, max_vertices = 1010;
int edge_counter = 1;
int to[max_edges], next[max_edges], top[max_edges];
bool used[max_edges];
void add_edge(int a, int b){
 to[edge_counter] = b;
 next[edge_counter] = top[a];
 top[a] = edge_counter;
 edge_counter++;
}
vector&lt;int&gt; ans;
void build(int start){
 while(top[start] != 0 &amp;&amp; used[top[start]])
top[start] = next[top[start]];
 if(top[start] == 0)
  return;
 vector &lt;int&gt; tmp;
 int u = start;	
 do{
  while(top[u] != 0 &amp;&amp; used[top[u]])
   top[u] = next[top[u]];
  assert(top[u] == 0); // agar shart bargharar bashad graph euleri nist.
  used[top[u]] = 1;
  tmp.push_back(top[u]);
  u = to[top[u]];		
 }while(start != u);
 u = start;
 for(int id : tmp){
  build(u);
  ans.push_back(id);
  u = to[id];
 }	
}
int main(){
// graph ra voroodi begirid va baraye har yal add_edge ra seda bezanid
// taabe build ra seda bezanid
// hala tartib yal ha dar vector ans gharar darad
}</pre><h2>اگر راس شروع و پایان یکسان نباشند چه؟</h2><p>فرض کنید می خواهید یک گذر پیدا کنید که از راس $ a $ شروع شده و به راس $ b $ ختم شود و تمام یال ها را ببینیم و $ a \neq b $.
</p><p>حالا برای تبدیل مسئله جدید به مسئله تور اویلری کافی است یک یال بین $ a $ و $ b $ اضافه کنید. (اگر گراف جهت دار بود از $ b $ به $ a $).
</p><p>حالا اگر فرض کنید در ابتدا یال جدید را طی می کنیم(در تور اویلری مهم نیست که از کدام یال شروع می کنیم) بقیه گذر همان چیزی است که دنبالش بودیم.(چرا؟) پس توانستیم این مسئله را به مسئله تور اویلری تبدیل کنیم.
</p><h1>De Bruijn sequence</h1><p>آیا می توان دور یک دایره $ 2^n $ ارقام 0 و 1 نوشت به طوریکه اگر تمام بازه های متوالی به طول $ n $ را در نظر بگیریم کل اعداد باینری $ n $ بیتی را تولید کند؟
</p><h2>تبدیل به دور همیلتونی</h2><p>اولین ایده ما برای مدل سازی این گراف به این شکل است :
</p><p>یک گراف $ 2^n $ راسی می سازیم که هر راس آن با یک رشته $ n $ تایی از 0 و 1 ها است. و راس $ a $ به راس $ b $ یال جهت دار دارد اگر بتوان رقم آخر رشته $ a $ را حذف کرد سپس یک حرف به اول آن اضافه کرد به طویکه رشته $ b $ حاصل شود. حالا سوال معادل با پیدا کردن یک دور همیلتونی در گرافی که ساختیم می باشد!
</p><p>در اینجا به بن بست می خوریم زیرا که برای تشخیص اینکه یک گراف دور همیلتونی وجود دارد یا خیر روشی نداریم.
</p><h2>تبدیل به تور اویلری</h2><p>یک گراف $ 2^{n-1} $ راسی می سازیم که هر راس آن معادل با یک رشته $ n-1 $ تایی از 0 و 1 ها است. هر راس مانند $ u $ دقیقا دو خروجی دارد. خروجی که عدد 0 روی آن نوشته شده است به راس $ w $ می رود به طوریکه اگر حرف آخر رشته $ u $ را حذف کنیم و به اول آن 0 را اضافه کنیم رشته حاصل همان رشته $ w $ خواهد بود. خروجی که روی آن عدد 1 نوشته شده است را هم می توان به شیوه مشابه تعریف کرد.
</p><p>تفاوت اصلی گراف قبلی با این گراف این است که در گراف قبل هر بازه $ n $ تایی از 0 و 1 های دور دایره معادل با یک راس گراف بود. ولی در اینجا معادل با یک یال گراف است. و مسئله را به پیدا کردن تور اویلری در گراف تبدیل کردیم. (می توان ثابت کرد که همانطور که درجه خروجی هر راس 2 است درجه ورودی هر راس هم 2 است همچنین گراف زمینه همبند است پس گراف اویلری می باشد).
</p><p>حالا اگر یک تور اویلری از گراف را پیدا کنید و ارقام روی یال های آن را به ترتیب دور دایره بنویسید چینش مطلوب ما حاصل خواهد شد!
</p><img src="/_static/dot/De_Bruijn_Graph.svg"><h1>قضیه های وجودی دور همیلتونی</h1><h2>لم اساسی</h2><p>گراف ساده $ n $ راسی  $ G $ را در نظر بگیرید که دارای دو راس نامجاور $ a, b $ می باشد به طوریکه $ d_a + d_b \geq n $. حالا گراف $ H $ را در نظر بگیرید که همان گراف $ G $ است که در آن رئوس $ a, b $ با یک یال به هم متصل شده اند. ادعا می کنیم گراف $ G $ دور همیلتونی دارد اگر و تنها اگر گراف $ H $ دور همیلتونی داشته باشد.
</p><p>طرف اول اثبات واضح است زیرا اگر $ G $ دور همیلتونی داشته باشد $ H $ هم دارای آن دور خواهد بود. (یالی حذف نکردیم)
</p><p>حالا برای اثبات طرف دوم فرض کنید $ H $ دور همیلتونی داشته باشد. اگر این دور از یال $ ab $ استفاده نکند $ G $ هم همان دور را دارد و حکم اثبات می شود. پس فرض کنید این دور از یال $ ab $ استفاده می کند در نتیجه باید مسیری همیلتونی در $ G $ وجود داشته باشد که از $ a $ شروع و به $ b $ ختم می شود.
</p><p>حالا فرض کنید مسیر همیلتونی ما $ a = v_1, v_2, ..., v_n = b $ می باشد. اگر $ v_1 $ به $ v_i $ یال داشته باشد و $ v_n $ به $ v_{i-1} $ یال داشته باشد آنگاه می توانیم یک دور همیلتونی در گراف $ G $ بیابیم. (از $ v_1 $ به مستقیم به $ v_i $ بروید سپس مسیر $ v_i $ تا $ v_n $ را طی کنید سپس از $ v_n $ مستقیم به $ v_{i-1} $ بروید سپس مسیر $ v_{i-1} $ تا $ v_1 $ را طی کنید).
</p><img src="/_static/dot/Ore_Theorem_Proof.svg"><p>حالا به ازای هر راسی مثل $ v_i $ که $ v_1 $ به آن یال دارد $ v_{i-1} $ را قرمز کنید و به ازای هر راسی مثل $ v_i $ که $ v_n $ به آن یال دارد $ v_i $ را آبی کنید. اگر بتوانیم ثابت کنیم راسی وجود دارد که هم قرمز هم آبی شده باشد مسئله حل خواهد شد. می دانیم که طبق فرض $ d_a + d_b \geq n $ پس تعداد راس هایی که رنگ کردیم حداقل $ n $ است. از طرفی راس $ v_n $ هیچگاه رنگ نمی شود (چرا؟). پس $ n-1 $ راس داریم که حداقل $ n $ بار رنگ شده اند پس طبق اصل لانه کبوتری راسی وجود دارد که دو بار رنگ شده باشد. پس راسی وجود دارد که همزمان آبی و قرمز شده باشد در نتیجه در $ G $ دور همیلتونی وجود دارد.
</p><h2>دیگر قضایا</h2><p>در اینجا به بیان چند قضیه می پردازیم که می توانید به راحتی با لم اساسی که بیان شد اثبات کنید.
</p><ul><li><p>اگر در گراف $ G $ درجه هر راس حداقل $ \frac{n}{2} $ باشد آنگاه در این گراف دور همیلتونی وجود دارد.
</p></li><li><p>اگر در گراف $ G $ به ازای هر دو راس نامجاور $ a $ و $ b $ داشته باشیم $ d_a + d_b \geq n $ در این گراف دور همیلتونی وجود دارد.
</p></li></ul><h1>الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</h1><p>در این بخش 4 الگوریتم همراه با پیاده سازی را بررسی خواهیم کرد. این 4 الگوریتم بسیار به هم شبیه هستند اما تفاوت های ریزی دارند که باید به این تفاوت ها و ایده اساسی پشت هر کدام توجه فراوان شود.
</p><h2>مسیر همیلتونی</h2><h3>الگوریتم 1</h3><p>از بخش های قبل متوجه شدیم که شرط لازم و کافی برای برای پیدا کردن دور و مسیر همیلتونی وجود ندارد. به عبارتی این یک مسئله np است و الگوریتم چند جمله ای برای آن وجود ندارد. حالا تلاش می کنیم الگوریتمی نمایی برای آن ارائه دهیم.
</p><p>حالا با استفاده از برنامه نویسی پویا $ dp_{mask, a, b} $ را تعریف می کنیم که یک آرایه boolean می باشد که نشان می دهد آیا با استفاده از راس های عضو مجموعه $ mask $ مسیری همیلتونی که از راس $ a $ شروع شود و به راس $ b $ ختم شود، وجود دارد یا خیر.
</p><p>برای آپدیت کردن این تابع کافی است روی راس قبل از $ b $ حالت بندی کنیم. فرض کنید این راس $ c $ باشد. لازم است $ c $ عضو مجموعه $ mask $ باشد همچنین یالی بین $ b $ و $ c $ وجود داشته باشد.
در نهایت برای فهمیدن اینکه مسیر همیلتونی وجود دارد می توان $ dp_{2^n-1,i,j} $ ها را به ازای همه $ i $ و $ j $ های ممکن بررسی کرد.
</p><p>پس پیاده سازی الگوریتم به این شکل خواهد بود : 
</p><pre dir="ltr">cpp
#define bit(n,k) (((n)&gt;&gt;(k))&amp;1)
const int maxn = 16;
bool dp[1&lt;&lt;maxn][maxn][maxn];
bool adj[maxn][maxn];
int main(){
    // voroodi gereftan graph
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
      for(int j = 0; j &lt; n; j++)
          cin &gt;&gt; adj[i][j];
    // mohasebe dp
    for(int mask = 1; mask &lt; (1&lt;&lt;n); mask++){
 if(__builtin_popcount(mask) == 1){
     dp[mask][__builtin_ctz(mask)][__builtin_ctz(mask)] = 1;
     continue;
 }
 for(int i = 0; i &lt; n; i++){
     for(int j = 0; j &lt; n; j++){
    if(i == j || bit(mask, i) == 0 || bit(mask, j) == 0)
        continue;
    for(int k = 0; k &lt; n; k++){
        if(k == j || bit(mask, k) == 0 || adj[k][j] == 0)
         continue;
        dp[mask][i][j] |= dp[mask ^ (1&lt;&lt;j)][i][k];
    }
     }
 }
    }
    bool ans = 0;
    for(int i = 0; i &lt; n; i++)
    for(int j = 0; j &lt; n; j++)
        ans |= dp[(1&lt;&lt;n)-1][i][j];
    if(ans)
     cout &lt;&lt; &quot;YES\n&quot;;
    else
 cout &lt;&lt; &quot;NO\n&quot;;
    return 0;
}</pre><p>همانطور که مشاهده می کنید الگوریتمی با پیچیدگی زمانی $ O(2^n * n^3) $ ارائه دادیم.
</p><h3>الگوریتم 2</h3><p>حالا می خواهیم با عوض کردن تعریف تابع بازگشتی الگوریتمی بهتر ارائه دهیم.
</p><p>فرض کنید $ dp_{mask,u} $ برابر با زیرمجموعه ای از راس ها مثل $ mask2 $ باشد به طوریکه به ازای هر عضو آن مثل $ v $ مسیری همیلتونی از $ u $ به $ v $ در راس های زیرمجموعه $ mask $ وجود داشته باشد.
</p><p>برای آپدیت کردن این تابع بازگشتی باید روی راسی که بعد از $ u $ می بینیم حالت بندی کنیم. در نهایت برای پیدا کردن جواب مسئله باید $ dp_{2^n-1,u} $ را به ازای همه $ u $ های ممکن بررسی کرد.
</p><pre dir="ltr">cpp
#define bit(n,k) (((n)&gt;&gt;(k))&amp;1)
const int maxn = 16;
int dp[1&lt;&lt;maxn][maxn];
bool adj[maxn][maxn];
int main(){
    // voroodi gereftan graph
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
     for(int j = 0; j &lt; n; j++)
         cin &gt;&gt; adj[i][j];
    // mohasebe dp
    for(int mask = 1; mask &lt; (1&lt;&lt;n); mask++){
    if(__builtin_popcount(mask) == 1){
     dp[mask][__builtin_ctz(mask)] = mask;
     continue;
 }	
 for(int i = 0; i &lt; n; i++){
     for(int j = 0; j &lt; n; j++){
  if(i == j || bit(mask, i) == 0 || bit(mask, j) == 0 || adj[i][j] == 0){
      continue;
  }
  dp[mask][i] |= dp[mask ^ (1&lt;&lt;i)][j];
     }		    
 }
    }
    bool ans = 0;
    for(int i = 0; i &lt; n; i++)
 if(dp[(1&lt;&lt;n)-1][i] != 0){
     ans = 1;
    if(ans)
 cout &lt;&lt; &quot;YES\n&quot;;
    else
 cout &lt;&lt; &quot;NO\n&quot;;
    return 0;
}</pre><p>پس توانستیم پیچیدگی زمانی الگوریتم را به $ O(2^n * n^2) $ کاهش بدهیم.
</p><h2>دور همیلتونی</h2><h3>الگوریتم 1</h3><p>برای چک کردن اینکه در گراف دور همیلتونی وجود دارد یا خیر کافی است یک راس دلخواه مثل $ a $ را در نظر بگیریم. سپس به ازای همه مجاور های راس $ a $ مثل $ b $ بفهمیم که آیا مسیر همیلتونی از $ a $ به $ b $ وجود دارد یا خیر. (اگر وجود داشت ابتدا مسیر همیلتونی را طی کنید سپس یال $ ab $ را طی کنید).
</p><p>می توان با استفاده از تابع بازگشتی که در الگوریتم 1 بخش قبل انجام دادیم این کار را انجام داد.
</p><p>حالا سعی می کنیم الگوریتم را بهبود ببخشیم. از آنجایی که راس $ a $ به صورت دلخواه انتخاب شده بود حدس می زنیم که می توان تعریف تابع بازگشتی را تغییر داد تا به الگوریتمی با پیچیدگی زمانی بهتری برسیم.
</p><p>تعریف می کنیم $ dp_{mask,u} $ یک آرایه boolean است که نشان می دهد آیا می توان از راس $ u $ شروع کرد و تمام رئوس مجموعه $ mask $ را دید و در نهایت به کوچکترین عضو مجموعه $ mask $ رسید یا خیر.
</p><p>تفاوت این تعریف با تعریف قبل این است که حالا راس انتهایی مسیر همیلتونی از روی $ mask $ مشخص می شود و نیازی نیست یک بعد اضافه تر به آن اختصاص داد.
</p><p>برای آپدیت کردن می توانید روی راس بعد از $ u $ حالت بندی کنید.
</p><pre dir="ltr">cpp
#include&lt;bits/stdc++.h&gt;
#define bit(n,k) (((n)&gt;&gt;(k))&amp;1)
using namespace std;
const int maxn = 16;
bool dp[1&lt;&lt;maxn][maxn];
bool adj[maxn][maxn];
int main(){
    // voroodi gereftan graph
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
   for(int j = 0; j &lt; n; j++)
     cin &gt;&gt; adj[i][j];
    // mohasebe dp
    for(int mask = 1; mask &lt; (1&lt;&lt;n); mask++){
 if(__builtin_popcount(mask) == 1){
     dp[mask][__builtin_ctz(mask)] = 1;
     continue;
 }
 int low_bit = __builtin_ctz(mask);
 for(int i = 0; i &lt; n; i++){
     for(int j = 0; j &lt; n; j++){
  if(i == j || bit(mask, i) == 0 || bit(mask, j) == 0 || i == low_bit || adj[i][j] == 0)
      continue;
  dp[mask][i] |= dp[mask ^ (1&lt;&lt;i)][j];
     }		    
 }
    }
    bool ans = 0;
    for(int i = 1; i &lt; n; i++){ // i != 0
 if(dp[(1&lt;&lt;n)-1][i] &amp;&amp; adj[0][i])
     ans = 1;
    }
    if(ans)
 cout &lt;&lt; &quot;YES\n&quot;;
    else
 cout &lt;&lt; &quot;NO\n&quot;;
    return 0;
}</pre><p>پس الگوریتمی با پیچیدگی زمانی $ O(2^n * n^2) $ رسیدیم.
</p><h3>الگوریتم 2</h3><p>حالا با الهام گرفتن از الگوریتم 2 بخش قبل پیچیدگی زمانی راه حل را بهبود می دهیم. 
</p><p>تعریف می کنیم $ dp_{mask} $ زیرمجموعه ای از راس ها مثل $ mask2 $ است که از هر راس $ mask2 $ مثل $ u $ می توان شروع کرد و تمام راس های مجموعه $ mask $ را دید و در نهایت به کوچکترین عضو $ mask $ رسید.
</p><p>برای آپدیت کردن می توان روی راس شروع مسیر همیلتونی حالت بندی کرد.
</p><p>به کد زیر توجه کنید. آرایه $ adj\_mask_u $ مجموعه راس هایی که مجاور راس $ u $ هستند را نشان می دهد.
</p><pre dir="ltr">cpp
#define bit(n,k) (((n)&gt;&gt;(k))&amp;1)
const int maxn = 16;
int dp[1&lt;&lt;maxn];
int adj_mask[maxn];
int main(){
    // voroodi gereftan graph
    int n;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++){
 for(int j = 0; j &lt; n; j++){
     bool x;
     cin &gt;&gt; x;
     if(x){
    adj_mask[i] |= 1&lt;&lt;j;
     }
 }
    }
    // mohasebe dp
    for(int mask = 1; mask &lt; (1&lt;&lt;n); mask++){
 if(__builtin_popcount(mask) == 1){
     dp[mask] = mask;
     continue;
 }
 int low_bit = __builtin_ctz(mask);
 for(int i = 0; i &lt; n; i++){
     if(bit(mask, i) == 0 || i == low_bit)
    continue;
     if(dp[mask ^ (1&lt;&lt;i)] &amp; adj_mask[i])
         dp[mask] |= 1&lt;&lt;i;
 }
    }
    bool ans = 0;
    if(dp[(1&lt;&lt;n)-1] != 0)
 ans = 1;
    if(ans)
 cout &lt;&lt; &quot;YES\n&quot;;
    else
 cout &lt;&lt; &quot;NO\n&quot;;
    return 0;
}</pre><p>پس در نهایت به الگوریتمی با پیچیدگی زمانی $ O(2^n * n) $ رسیدیم.
</p><h1>بلمن فورد</h1><h2>صورت مسئله</h2><p>یک گراف جهت دار وزن دار 
$ G $
داریم. وزن یال های $ G $ میتواند منفی نیز باشد. میدانیم گراف $ G $ دور با مجموع وزن منفی ندارد. 
</p><p>حال میخواهیم به ازای هر راس طول کوتاه ترین مسیر از راس $ sc $ به بقیه رئوس را پیدا کنیم که طول یک مسیر برابر جمع وزن های یال های آن است.
</p><h2>الگوریتم بلمن فورد</h2><p>برای حل این مسئله ابتدا یک $ dp $ با ابعاد
$ |V(G)| * |V(G)| $
تعریف میکنیم که $ dp_{i,j} $ برابر طول کوتاه ترین گشت از راس $ sc $ به راس $ j $ است که تعداد یال های این گشت حداکثر برابر $ i $ است.
</p><p>حال میدانیم طول کوتاه ترین گشت بین 2 راس در گراف $ G $ برابر طول کوتاه ترین مسیر نیز میباشد چون اگر کوتاه ترین گشت دارای 2 راس تکراری باشد یک دور داریم که طول آن مثبت است (طبق فرض سوال نمیتواند طول دور منفی باشد.) پس میتوان ان را حذف کرد و به یک گشت با طول کمتر رسید که تناقض است.
</p><p>حال برای پایه های این دپپی میدانیم که $ dp_{i, sc} = 0 $ و
$ dp_{0, u \neq sc} = \infty $
است. حال برای بدست اوردن $ dp_{i, j} $ روی تمامی یال هایی که به $ j $ وارد میشوند حالت بندی میکنیم. اگر به ازای هر یال $ e $ که از $ u_e $ به $ j $ وارد می شود و وزن آن $ w_e $ است، مقدار
$ dp_{i-1, u_e} + w_e $
را حساب کنیم کمینه این مقدارها جواب 
$ dp_{i, j} $
می شود. در نتیجه :
</p>$$ dp_{i, j} = \displaystyle{\min_{\forall \, e \: \in \: N_{j}^{-}(j)}} dp_{i-1, u_e} + w_e` $$<p>برای بدست آوردن طول کوتاه ترین مسیر از راس $ sc $ به راس $ u $ داشتن مقدار $ dp_{n-1, u} $ کافی است. چون که مسیر از راس $ sc $ به یک راس دیگر حداکثر دارای $ n $ راس و $ n-1 $ یال است و طبق تعریف دیپی و اینکه کوتاه ترین گشت بین 2 راس در $ G $ حتما مسیر است، این مقدار دقیقا همان مقدار مورد نیاز است.
</p><h2>تحلیل اردر</h2><p>برای اپدیت کردن کل خانه های $ dp_i $ به ازای هر راس به اندازه درجه ورودی آن عملیات انجام داده ایم. میدانیم که جمع درجه ورودی تمام راس ها برابر 
$ |E(G)| $
است. پس در کل 
$ \mathcal{O}\left(|V(G)|.|E(G)|\right) $
عملیات انجام داده ایم. اردر حافظه استفاده شده نیز 
$ \mathcal{O}\left(|V(G)|^2\right) $
است.
</p><h2>بهینه سازی اردر حافظه</h2><p>برای بهینه سازی مقدار حافظه مصرفی، میتوان بعد اول را حذف کرد. در نتیجه اردر حافظه مصرفی برابر 
$ \mathcal{O}\left(|V(G)|\right) $
میشود.
</p><p>سپس 
$ |V(E)| - 1 $
مرحله به ازای هر یال مقدار $ dp $ راس ته یال را اپدیت کرد. منظور از اپدیت کردن این است که اگر یال $ e $ از راس $ u_e $ به $ v_e $ برود و وزن آن $ w_e $ باشد،
$ dp_{v_e} = min(dp_{v_e}, dp_{u_e} + w_e) $
را قرار دهیم.
</p><p>حال یک سوال پیش می آید که آیا با انجام این کار مقدار خانه های
$ dp $
همان مقدار مورد نظر باقی می ماند یا نه؟ پاسخ این سوال بله است.
</p><p>اگر دیپی در قسمت قبلی را 
$ dp^{\prime} $
در نظر بگیریم بعد از مرحله $ i`م اپدیت کردن :math:`dp $ میدانیم $ dp_u $ برابر یکی از 
$ dp_{i, u}^{\prime}, dp_{i+1, u}^{\prime}, \dots, dp_{n-1, u}^{\prime} $
است. (اثبات این لم بر عهده خواننده).
</p><p>حال اگر بعد از مرحله $ n-1 $ مین بررسی کنیم میفهمیم که 
$ dp_u = dp_{n-1, u}^{\prime} $
است. در نتیجه بعد از مرحله $ n-1 $ مین مرحله مقدار خانه های $ dp $ همان مقدار های مطلوب است.
</p><h2>پیدا کردن کوتاه ترین مسیر</h2><p>بعد از همه این صحبت ها، یک سوال برایتان پیش می آید و آن این است که اگر خود مسیر بهینه از $ sc $ به یک راس دیگر مانند $ des $ را بخواهیم، چه باید بکنیم؟
</p><p>برای حل این پرسش باید کمی الگوریتم قبلی را تغییر دهیم. یک آرایه
$ |V(G)| $
عضوی کمکی به نام $ par $ در نظر میگیریم. در ابتدا تمامی خانه های $ par $ را برابر 1- قرار میدهیم. حال اگر در وقتی یال $ e $ را در نظر گرفتیم 
$ dp_{v_e} > dp_{u_e} + w_e $
بود، 
$ par_{v_e} $
را برابر $ u_v $ قرار میدهیم.
</p><p>$ par_u $
عملا برابر راس قبلی در مسیر بهینه از $ sc $ به $ u $ است. برای بدست اوردن مسیر از $ sc $ به $ des $، یک متغیر $ nw $ نگه میداریم و تا وقتی که 
$ nw \neq sc $
است، $ nw $ را برابر $ par_{nw} $ قرار میدهیم و $ nw $ را به ابتدا مسیر بدست امده فعلی اضافه میکنیم. 
</p><p>برای اثبات اینکه اثبات کنیم که حتما به راس $ sc $ میرسیم و مسیری که بدست می اوریم مسیری بهینه است، یک ارایه $ lst $ فرض میکنیم. $ lst_u $ برابر شماره اخرین مرحله ای است که $ dp_u $ عوض شده است. میدانیم 
$ lst_u > lst_{par_u} $
است. (اثبات به عهده خواننده) پس هر بار که $ nw $ را برابر 
$ par_{nw} $
می کنیم، $ lst_{nw} $ کاهش میابد پس به دور نمیخوریم و حتما به $ sc $ خواهیم رسید.
</p><p>طول مسیر نیز برابر $ dp_{des} $ خواهد بود چون هر مرحله اگر یک یال با وزن $ w $ را به مسیر اضافه کنیم، مقدار $ dp_{nw} $ دقیقا به انداره $ w $ کاهش میابد. چون $ dp_{sc} = 0 $ است طول مسیر دقیقا برابر $ dp_{des} $ میشود. 
</p><h2>دور منفی</h2><p>ممکن است برایتان سوال شود اگر تضمین نشود که گراف دور منفی دارد یا نه چگونه بفهمیم دور منفی داریم ؟ (در حالتی که حافظه را بهینه سازی کرده ایم).
</p><p>ابتدا فرض کنید به جای 
$ |V(G)| - 1 $
مرحله، 
$ |V(G)| $
مرحله اجرا میکنیم.
به یک مرحله از الگوریتم خوب میگوییم اگر مقدار حداقل یکی از خانه های  $ dp $ عوض شود. حال میدانیم اگر مرحله  $ i $ م خوب نباشد آنگاه مراحل بعدی نیز خوب نیستند. (اگر مقداری عوض نشود مراحل بعدی هم دقیقا همانند مصل مرحله  $ i $ م میشوند و خانه ای عوض نمیشود).
</p><p>حال اگر دور منفی نداشته باشیم طبق استدلال های قبلی مرحله $ |V(G)| $ م حتما خوب نیست.(تمامی خانه ها به مقدار نهایی در مرحله قبل رسیده اند و عوض نخواهند شد).
حال اگر یک دور منفی وجود داشته باشد میدانیم مقدار  $ dp $ رِئوس آن هیچگاه ثابت نخواهد شد. خود دور منفی را میتوان چند بار طی کرد، که باعث میشود مقادیر  $ dp $ رئوس دور به 
$ -\infty $
نزدیک شوند. حال میدانیم اگر یک مرحله خوب نباشد انگاه تمامی مقادیر ثابت شده اند. طبق این حرف ها نتیجه میشود اگر دور منفی داشته باشیم تمامی مراحل خوب خواهند بود.
</p><p>حال میدانیم اگر دور منفی نداشته باشیم مرحله $ |V(G)| $ م خوب نیست و اگر دور منفی داشته باشیم $ |V(G)| $ م حتما خوب است.
پس برای چک کردن داشتن دور منفی کافیست خوب بودن مرحله $ |V(G)| $ م را بررسی کنیم.
</p><p>برای پیدا کردن خود دور منفی مثل حالت بدون دور منفی یک ارایه کمکی به نام  $ par $  بگیرید و از یک راس که در مرحله $ |V(G)| $ م عوض شده مسیر بهینه از  $ sc $  را پیدا کنید دور منفی در این مسیر حتما امده است. (این بخش با توجه به استدلال های همین بخش قابل اثبات است).
</p><h1>دکسترا</h1><h2>صورت مسئله</h2><p>یک گراف جهت دار وزن دار 
$ G $
داریم. وزن تمامی یال های $ G $ نامنفی می باشند.
</p><p>حال میخواهیم به ازای هر راس طول کوتاه ترین مسیر از راس $ sc $ به بقیه رئوس را پیدا کنیم که طول یک مسیر برابر جمع وزن های یال های آن است.
</p><h2>الگوریتم دایکسترا</h2><p>یک آرایه به نام $ dis $ تعریف میکنیم. در هنگام انجام الگوریتم، $ dis_u $ نشان دهنده کوتاه ترین مسیر به راس $ u $ است که راس قبلی مسیر حتما انتخاب شده باشد.(انتخاب شدن در جلوتر توضیح داده میشود). در ابتدا همه خانه های ارایه $ dis $ برابر
$ \infty $
است. ابتدا میدانیم
$ dis_{sc} = 0 $
است. حال $ sc $ را انتخاب میکنیم حال $ dis $ رئوس همسایه $ sc $ را اپدیت میکنیم. 
</p><p>حال در مرحله از الگوریتم از بین رئوسی که تا حالا انتخاب نکرده ایم آن راسی را انتخاب میکنیم که مقدار $ dis $ آن کمینه است و آن را $ v $ مینامیم.
</p><p>حال اثبات میکنیم که طول کوتاه ترین مسیر از $ sc $  به $ v $ همان مقدار فعلی $ dis_v $ است. برای این کار از برهان خلف استفاده میکنیم و فرض میکنیم مسیر کوتاه تری وجود دارد (مسیری به طول $ P $). اخرین راس انتخاب شده در این مسیر را بگیرید و آن را $ last $ بنامید. (حتما وجود دارد چون راس $ sc $ انتخاب شده است.) راس بعدی 
$ last $
را $ u $ مینامیم. (راس بعدی نیز وجود دارن چون راس اخر انتخاب نشده بود). 
</p><p>طبق فرض خلف طول مسیر تا $ v $ کمتر از $ dis_v $ بوده و چون یال ها منفی نیستند طول مسیر تا $ u $ نیز کمتر از $ dis_v $ است. چون راس قبلی $ u $ در مسیر راسی انتخاب شده بوده و فاصله نهایی راس های انتخاب شده همان $ dis $ آن ها است، آنگاه $ dis_u $ در زمان انتخاب شدن $ last $ برابر طول کوتاهترین تا $ u $ شده است. و چون 
$ dis_u < P $ و $ P < dis_v $
است پس
$ dis_u < dis_v $
می باشد که با کمینه بودن $ dis_v $ در بین مقدار های فعلی در تناقض است. پس فرض خلف ما غلط بوده و حکم اثبات میشود.
</p><p>حال که اثبات شد مقدار $ dis_v $ دقیقا برابر طول کوتاهترین مسیر به $ v $ است، آنرا انتخاب کرده سپس به ازای تمام همسایه های آن مانند $ adj $ که یال از $ v $ به $ adj $ وزن $ w $ دارد،
$ dis_{adj} = min(dis_{adj}, dis_v + w) $
را انجام میدهیم. و همین فرآیند را ادامه میدهیم تا همه رئوس انتخاب شده باشند.
</p><h2>تحلیل اردر</h2><p>برای این الگوریتم دو راه کلی پیاده سازی وجود دارد.
</p><h3>راه اول با اردر :math:`\mathcal{O}(n^2)`</h3><p>در هر مرحله روی کل رئوس انتخاب نشده حلقه اجرا کنیم و کمینه را پیدا کنیم. در هر مرحله از فرایند ما 
$ \mathcal{O}(n) $
انجام میدهیم. چون الگوریتم دارای $ n $ مرحله است اردر برنامه ما 
$ \mathcal{O}(n^2) $
میشود.
</p><h3>راه دوم با اردر :math:`\mathcal{O}(n + m.lg(n))`</h3><p>در هر مرحله به جای اجرای حلقه رو کل رئوس، از داده ساختار هایی استفاده میکنیم که کمینه را سریع تر پیدا بکنند. مانند $ set $ و $ priority-queue $ در $ C++ $.( فرض کنید در اینجااز $ set $ استفاده میکنیم)
</p><p>در هر مرحله کمینه مقدار $ dis $ را میتوان با 
$ \mathcal{O}(1) $
پیدا کرد. هر بار که مقدار خانه ای از $ dis $ را عوض میکنیم باید مقدار ان را در $ set $ اپدیت کنیم که  از اردر
$ \mathcal{O}(lg(n)) $
میباشد.
</p><p>چون ممکن است هر مرحله به اندازه تعداد همسایه های راس انتخاب شده خانه های $ dis $ عوض بشود پس ما به انداره مجموع تعداد همسایه های کل رئوس مقادیر $ dis $ را عوض میکنیم. میدانیم جمع تعداد همسایه ها از
$ \mathcal{O}(m) $
است. پس در کل 
$ \mathcal{O}(m.log(n)) $
هزینه زمانی به ازای اپدیت ها میدهیم پس اردر برنامه $ \mathcal{O}(n + m.lg(n)) $ میشود.
</p><h1>فلوید وارشال</h1><h2>صورت مسئله</h2><p>یک گراف جهت دار وزن دار 
$ G $
داریم. وزن یال های $ G $ میتواند منفی نیز باشد. میدانیم گراف $ G $ دور با مجموع وزن منفی ندارد. 
</p><p>در این سوال به ازای هر جفت راس مانند $ (u, v) $ طول کوتاه ترین مسیر از $ u $ به $ v $ را میخواهیم. طول یک مسیر برابر حمع وزن یال های آن است.
</p><h2>الگوریتم فلوید وارشال</h2><p>برای حل این مسئله ابتدا یک $ dp $ با ابعاد
$ |V(G)|.|V(G)|.|V(G)| $
تعریف میکنیم که 
$ dp_{k, i, j} $
برابر طول کوتاه ترین گشتی از راس $ i $ به راس $ j $ است که راس های وسطی آن (راس های مسیر به جز خود $ i $ و $ j $) از بین مجموعه رئوس
$ \lbrace 1, 2, \dots, k \rbrace $
است.
</p><p>حال میدانیم طول کوتاه ترین گشت بین 2 راس در گراف $ G $ برابر طول کوتاه ترین مسیر نیز میباشد چون اگر کوتاه ترین گشت دارای 2 راس تکراری باشد یک دور داریم که طول آن مثبت است (طبق فرض سوال نمیتواند طول دور منفی باشد.) پس میتوان ان را حذف کرد و به یک گشت با طول کمتر رسید که تناقض است.
</p><p>حال برای پایه های این دپپی میدانیم که $ dp_{0, i, i} = 0 $ و به ازای هر جفت از رئوس مانند 
$ (u, v) $
دیپی $ dp_{0, u, v} $ را برابر کوتاه ترین یال از $ u $ به $ v $ این دو راس میزاریم. ( اگر یالی از $ u $ به $ v $ نبود
$ dp_{0, u, sc} = \infty $
است).
</p><p>حال برای بدست اوردن $ dp_{k, i, j} $ دو حالت را در نظر میگیریم یا راس $ k $ در مسیر بهینه وجود ندارد که جواب در این حالت
$ dp_{k - 1, i, j} $
است. 
</p><p>اگر راس $ k $ در مسیر باشد انگاه مسیر بهینه برابر
$ dp_{k - 1, i, k} + dp_{k - 1, k, j} $
است چون که ابتدا از راس $ i $ باید به راس $ k $ برسیم و سپس از راس $ k $ به راس $ j $ برویم و در بین این دو مسیر حتما شماره رئوس از $ k $ کمتر است.
</p><p>برای بدست آوردن طول کوتاه ترین مسیر از راس $ u $ به راس $ v $ داشتن مقدار $ dp_{n, u, v} $ کافی است. 
</p><h2>تحلیل اردر</h2><p>برای اپدیت کردن هر خانه دیپی 
$ \mathcal{O}(1) $
عملیات انجام داده ایم. میدانیم که دیپی دارای
$ \mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right) $
است. پس در کل 
$ \mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right) $
عملیات انجام داده ایم. اردر حافظه استفاده شده نیز همان
$ \mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right) $
است.
</p><h2>بهینه سازی اردر حافظه</h2><p>برای بهینه سازی مقدار حافظه مصرفی، میتوان بعد اول را حذف کرد. در نتیجه اردر حافظه مصرفی برابر 
$ \mathcal{O}\left(\left|V\left(G\right)\right|^{2}\right) $
میشود.
</p><p>منظوز این است که یک 
$ for $
از 1 تا 
$ \left|V\left(G\right)\right| $
بزنیم و متغیر آن را $ k $ بنامیم. سپس در هر مرحله
ازای هر خانه $ dp $ آن را اپدیت کنیم. منظور از اپدیت کردن این است که مثل حالت عادی روی اینکه راس $ k $ جزو راس های میانی مسیر هست یا نه حالت بندی کنیم.
</p><p>حال برای اثبات درست بودن میگوییم که بعد هر مرحله حلقه اول تمامی مقادیر درست هستند. اگر ابتدا میگوییم که خانه های دیپی که یکی از بُعد های آن ها برابر
$ k $
است هیچ گاه تغییری نمی کنند. حال برای آپدیت کردن بقیه خانه های دیپی از مقادیر خانه هایی استفاده میکنیم که حتما یک بُعد از انها $ k $ است. 
</p><p>پس با استقرا میتوان ثابت کرد که بعد مرحله  $ k $ م 
$ dp_{i, j} = dp^{\prime}_{k, i, j} $
است که 
$ dp^{\prime} $
همان دیپی بدون بهینه سازی است. پس بعد مرحله :math:`n`م به مقادیر مطلوب خواهیم رسید.
</p><p>پس با استقرا میتوان ثابت کرد که بعد مرحله  $ k $ م $ dp_{i, j} = dp^{\prime}_{k, i, j} $
است که 
$ dp^{\prime} $
همان دیپی بدون بهینه سازی است. پس بعد مرحله  $ n $  م به مقادیر مطلوب خواهیم رسید.
</p><h2>دور منفی</h2><p>ممکن است برایتان سوال شود اگر تضمین نشود که گراف دور منفی دارد یا نه چگونه بفهمیم دور منفی داریم یا نه ؟ برای این هدف ابتدا 
$ dp_{i, i} = 0 $
قرار میدهیم. حال اگر در حین اجرای الگوریتم یکی از خانه های 
$ dp_{i, i} < 0 $
شد انگاه میدانیم یک گشت با طول منفی از $ i $ به $ i $ وجود دارد که میدانیم در هر گشت بسته با طول منفی دوری به طول منفی وجود دارد. 
</p><p>اگر دور منفی وجود داشت حتما برای راسی مانند $ u $ در دور منفی حتما
$ dp_{u, u} < 0 $
میشد. چون دور منفی ما طبق تعریف $ dp $ ما مشکلی ندارد و در 
$ dp_{u, u} $
تاثیر دارد و انرا منفی میکند.
</p><p>طبق دو تا استدلال بالا وجود داشتن دور منفی با داشتن 
$ dp_{i, i} < 0 $
معادل است. پس کافی است فقط بررسی کنیم در طول فرایند $ dp_{i, i} $ منفی نشود.
</p><h1>ماتریس و عملیات های روی آن</h1><p>ماتریس ها ساختار هایی انتزاعی مانند گراف ها هستند که در بسیاری از علوم کاربرد
دارند. ماتریس ها پایه جبر خطی هستند که در الگوریتم های هوش مصنوعی و یادگیری
ماشین بسیار به کار می روند. در المپیاد نیز ماتریس ها در الگوریتم های پیچیده
مانند
FFT
به کار می روند و آشنایی با آن ها برای یک دانش آموز المپیادی مفید است.
</p><p>در این فصل، با ماتریس ها آشنایی مختصری پیدا می کنیم و سپس به بررسی رابطه بین
ماتریس ها و گراف ها می پردازیم تا به کمک آن ها بتوانیم الگوریتم های سریعی
برای چند مساله ارائه کنیم.
</p><h2>ماتریس</h2><p>هر آرایش مستطیل شکل از عدد های حقیقی، که شامل تعدادی سطر و ستون است یک ماتریس است.
به هر عدد حقیقی واقع در هر ماتریس یک <b>درایه</b> آن ماتریس می گوییم.
</p><p>$ \begin{equation*}
 $
$ \begin{equation*}
 $
$ \begin{equation*}
 $
</p><h2>مرتبه ماتریس</h2><p>ماتریسی که m ستون و n سطر دارد را از <b>مرتبه</b> n × m می خوانیم.
</p><h2>جمع و تفریق ماتریس ها</h2><p>برای جمع دو ماتریس در گام اول باید توجه کنیم که تعداد سطر های دو ماتریس و تعداد ستون های دو ماتریس با هم برابر باشند(لزومی ندارد که تعداد سطر ها با تعداد ستون ها برابر باشد).
در قدم بعدی هر درایه ماتریس A با درایه متانظر در ماتریس B جمع می شود و درایه متانظر در C را می سازد.
عملیات تفریق نیز به همین روش انجام می شود.
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><h2>ضرب ماتریس ها</h2><p>برای ضرب ماتریس ها در ابتدا باید توجه داشت که اگر ماتریس A، n سطر و m ستون داشته باشد ماتریس B باید m سطر و z ستون داشته باشد. در این صورت ماتریس C که حاصل ضرب این دو ماتریس است n سطر و z ستون دارد.
درایه $ c_{ij} $ برابر است با جمع $ a_{ik} × b_{kj} $ که در آن k یک عدد طبیعی است که حداکثر مقدار آن m است.
</p><p>$ \begin{equation*}
 $
</p><h2>ضرب عدد در ماتریس</h2><p>هنگامی که یک عدد حقیقی k در یک ماتریس ضرب می شود تمامی درایه آن ماتریس در k ضرب می شود.
</p><p>$ \begin{equation*}
 $
</p><h1>دترمینان ماتریس ها</h1><p>قبل از هر چیزی باید اشاره کنیم که دترمینان برای ماتریس هایی تعریف می شود که تعداد سطر و ستون آن ها برابر است و دترمینان ماتریسی که یک سطر و یک ستون دارد برابر تک درایه آن است.
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>برای بدست آوردن دترمینان یک ماتریس ابتدا یه سطر یا یک ستون را انتخاب میکنیم. برای مثال سطر i را انتخاب می کنیم.
حال دترمینان برابر است با جمع $ -1^{i + j} × a_{ij} × det(B_{ij}) $ که در آن j عدد طبیعی حداکثر برابر با تعداد ستون ها است و $ det(C) $ برابر با دترمینان ماتریس مربعی C است و $ B_{ij} $ برابر با ماتریسی است که با حذف سطر i و ستون j از A بدست می آید.
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>$ \begin{equation*}
 $
</p><p>دترمینان در میان ماتریس ها عملکرد زیادی دارد. یکی از کاربرد های دترمینان در تئوری کیرشهف (Kirchhoff) است.
</p><h2>تئوری کیرشهف (Kirchhoff)</h2><p>فرض کنید گرافی به ما داده شده و می خواهیم تعداد زیر درخت های فراگیر آن را حساب کنیم.
یکی از روش های محاسبه این مقدار روش کیرشهف برای این کار است.
در ابتدا یک ماتریس n × n می سازیم که در آن $ a_{ij} $ به ازای i = j برابر درجه راس i است و در غیر این صورت برابر با قرینه تعداد یال های بین راس های i و j گراف است‌. تنها نکته ای که باید به آن توجه داشت این است که قبل از درست کردن ماتریس طوقه ها را از گراف حذف کنیم.
حال هر سطر و هر ستونی که بخواهیم که حذف می کنیم و دترمینان ماتریس حاصل(که یک سطر و یک ستون از دست داده) را حساب می کنیم که برابر با تعداد زیر درخت های فراگیر گراف است.
</p><h1>ماتریس وقوع </h1><h2>ماتریس وقوع</h2><p>در گراف های ساده به ماتریس n × m که در آن $ a_{ij} $ یک است اگر راس i یک سر یال j باشد و صفر است اگر راس i یک سر یال j نباشد.
تمامی درایه های این ماتریس صفر یا یک است.
</p><p>اگر یال چندگانه هم وجود داشته باشد ماتریس وقوع مشکلی پیدا نخواهد کرد چرا که فقط به تعداد ستون اضافه می شود و فرقی در ساختار و کلیت ماتریس وقوع نمی کند.
اما اگر طوقه داشته باشیم قضیه کمی فرق می کند چرا که راسی که طوقه دارد بجای عدد یک، عدد دو می گیرد، یعنی $ a_{ij} $ مقدار دو می گیرد اگر راس i طوقه j را داشته باشد.
</p><p>در گراف های جهت دار ساختار متفاوتی در ماتریس وقوع پدیدار می شود. به این صورت که $ a_{ij} $ مقدار یک می گیرد اگر یال j از راس i خارج شود یا یال j طوقه باشد، مقدار منفی یک می گیرد اگر یال j به راس i وارد شود و در صورتی که هیچ کدام از حالات بالا نباشد مقدار صفر را به خود می گیرد.
مجموع مقادیر ماتریس وقوع در یک گراف جهت دار تعداد طوقه ها را به ما می دهد.
</p><img src="/_static/IncidenceMatrixDirected.png"><h1>ماتریس مجاورت</h1><h2>ماتریس مجاورت</h2><p>ماتریس مجاورت ماتریسی است  n × n که برای نمایش گراف های ساده استفاده می شود. در این ماتریس $ a_{ij} $ نشان دهنده تعداد یال های موجود بین راس i و راس j در گراف است. اگر توجه کنید می فهمید که این ماتریس متقارن است. درایه های این ماتریس صفر و یک است.
</p><h3>در گراف هایی با یال چندگانه و طوقه</h3><p>در این گراف ها ماتریس مجاورت با همان تعریف اصلی خود مورد استفاده قرار می گیرید و تفاوت در اینجاست که دیگر درایه ها لزوماً صفر و یک نیستند و می توانند هر مقدار حسابی را بگیرند.
</p><h3>در گراف های جهت دار</h3><p>در گراف های جهت دار ماتریس مجاورت به این صورت تعریف می شود که $ a_{ij} $ به معنای تعداد یال هایی است که از راس i به j می رود.
</p><p>نکته آخر راجب ماتریس مجاورت این است که زمانی که گراف دارای وزن است مورد استفاده قرار نمی گیرد هر چند در بدست آوردن کوتاه ترین مسیر ها از ماتریسی مشابه این ماتریس استفاده می شود و در تمامی تعریف های بالا یال ها وزن دار نیستند.
</p><img src="/_static/AdjacencyMatrix.png"><h1>تعداد گشت ها به طول n</h1><p>به کمک ماتریس مجاورت گراف و عملیات هایی که روی ماتریس ها تعریف می شود می توان
الگوریتمی برای به دست آوردن تعداد گشت ها به طول
n
ارائه داد. برای درک این قسمت، لازم است با عملیات ضرب ماتریسی که یک عملیات معروف است
آشنا باشید و شهود خوبی روی آن داشته باشید. می توانید ضرب ماتریس را درون اینترنت
جستجو کرده تا با آن آشنا شوید.
</p><h2>معنی ضرب ماتریس در گراف ها</h2><p>دو گراف
n
راسی را در نظر بگیرید. برای مثال این دو گراف را گراف آبی با ماتریس مجاورت
A
و قرمز با ماتریس مجاورت B
می نامیم. می خواهیم تعداد گشت های بین دو راس
i و j
را به دست بیاوریم. به طوری که دو یال داشته باشند و یال اول آن ها آبی و یال دوم آن ها قرمز
باشد. این تعداد را
$ C_{i,j} $
می نامیم. واضح است که برای محاسبه این مقدار می توان روی راس میانی این گشت حالت بندی کرد
(راسی مانند k)
و سپس یال های آبی از i به k را در یال های قرمز از k به j ضرب کرد و مقادیر به دست آمده را
به ازای تمام k های ممکن جمع زد. به زبان ریاضی:
</p>$$ C_{i,j} = \sum\limits_{k=1}^{n} A_{i,k}B_{k,j} $$<p>که با کمی دقت می توان دریافت که ماتریس
C
برابر ضرب ماتریس A در B است.
</p><h2>توان ماتریس</h2><p>توان ماتریس را مانند توان اعداد، به این صورت تعریف می کنیم که
$ A^n $
یعنی n بار ضرب A در خودش.
طبق قضیه ای که در بالا نشان دادیم می توان دریافت که تعداد گشت های به طول
n از i به j
برابر درایه (i,j) در
$ A^n $
است. برای اثبات به ازای هر گشت به طول
n-1
یک یال قرمز بگذارید و به ازای هر یال گراف یک یال آبی. به وضوح هر گشت به طول
n
معادل یک گشت با یک یال قرمز و یک یال آبی است. و چون
$ A^n = A^{n-1}A $
حکم را با استقرا می توان ثابت کرد.
</p><h2>الگوریتم و پیچیدگی</h2><p>پس برای حل مساله کافیست تا بتوانیم توان ماتریس را در زمان خوبی محاسبه کنیم.
چون ضرب ماتریس ها خاصیت شرکت پذیری دارد ( یعنی
$ (AB)C = A(BC) $ )
پس مهم نیست که به چه ترتیبی توان را حساب می کنیم. اگر توان زوج باشد داریم:
</p>$$ A^{2k} = (A^k)^2 $$<p>و اگر فرد باشد، داریم:
</p>$$ A^{2k+1} = A(A^k)(A^k) $$<p>اگر ضرب ماتریس را با الگوریتم بدیهی اش، یعنی
$ O(n^3) $
محاسبه کنیم، می توان به صورت بازگشتی برای محاسبه
$ A^k $
ابتدا توان
$ A^{\lfloor\frac{k}{2}\rfloor} $
را محاسبه کنیم و سپس به وسیله روابط بالا جواب مساله را حساب کنیم. زمان اجرای
این الگوریتم بازگشتی برابر است با:
</p>$$ T(k) = T(\frac{k}{2}) + O(n^3) = O(n^3lg(k)) $$<p>نام این الگوریتم الگوریتم توان رسانی سریع است که در جایی که می خواهیم یک عملیات شرکت پذیر
را روی یک عضو چندین بار تکرار کنیم می توانیم از آن استفاده کنیم.
مثلا برای توان اعداد نیز می توانید از همین الگوریتم استفاده کنید.
</p><h2>تعمیم</h2><p>الگوریتمی که در این جا بررسی کردیم تنها برای محاسبه تعداد گشت های به طول ثابت کاربرد
ندارد، بلکه می توان با آن خواص دیگری از گشت های به طول ثابت را نیز
(مانند بزرگ ترین گشت یا گشت با کم وزن ترین یال)
به دست آورد. برای مثال می خواهیم بین دو راس گشتی به طول
k
پیدا کنیم که جمع وزن یال های آن بیشینه باشد.
اگر بخواهیم این مساله را برای گرافی حل کنیم که یال های آن قرمز و آبی باشد و گشت های با
یک یال قرمز و یک یال آبی مد نظر مان باشد پاسخ به این صورت به دست می آید:
</p>$$ C_{i,j} = \max\limits_{k=1}^{n} A_{i,k} + B_{k,j} $$<p>می توانیم ماتریس
C
را به عنوان ترکیب ماتریس
A و B
تعریف کنیم. با کمی دقت می توان دریافت که عمل ترکیب مانند عمل ضرب ماتریس شرکت پذیر است.
برای اثبات می توانید یک گراف با یال های قرمز و آبی و سبز در نظر بگیرید و گشتی که
قرمز - آبی - سبز باشد و جمع وزن یال هایش بیشینه باشد را از دو روش به دست آورید.
پس می توان مشابه قبل توان ماتریس را تعریف کرد و با استقرا ثابت کرد که
$ A^k_{i,j} $
برابر بزرگترین گشت به طول 
k بین دو راس i و j
است و الگوریتم
$ O(n^3lg(k)) $
برای محاسبه این ماتریس وجود دارد.
</p><h1>به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</h1><p>مساله به دست آوردن تعداد گشت های به طول
k
در یک گراف مساله ای است که بسیاری از مسائل شمارشی را می توان حالت خاصی از آن
حساب کرد و چون زمان محاسبه این تعداد متناسب با لگاریتم
k
است، در بسیاری از موارد از الگوریتم های دیگر سریع تر عمل می کند و می توان به جای
راه های دیگر از توان رساندن ماتریس این گراف استفاده کرد.
</p><p>در این بخش خانواده هایی از توابع بازگشتی که در مسائل تئوری و همچنین برنامه نویسی پویا
دیده می شوند را در نظر می گیریم و برای آن ها گراف هایی می سازیم که جمله
n
ام رابطه بازگشتی مورد نظر برابر تعداد گشت های به طول
n
در گرافی باشد که تعداد ثابتی راس دارد. به این ترتیب الگوریتمی به دست می آید که پیچیدگی آن
$ O(lg(n)) $
است و دنباله بازگشتی مورد نظر را حساب می کند.
</p><h2>فیبوناچی</h2><p>یک گراف دو راسی را در نظر بگیرید که در آن دو راس به هم یال دارند و راس اول به خودش یک طوقه
دارد. می خواهیم تعداد گشت های به طول
n
از راس یک به خودش را محاسبه کنیم و این مقدار را
$ f_n $
می نامیم. روی اولین یال گشت حالت بندی می کنیم. اگر اولین یال گشت آن طوقه باشد، در ادامه
طبق تعریف به
$ f_{n-1} $
طریق می توانیم کار را ادامه دهیم. اما اگر در اولین قدم به راس دیگر رفته باشیم، دومین یال
گشت به صورت یکتا معلوم است و مجبوریم که به راس اول برگردیم. در ادامه به
$ f_{n-2} $
طریق می توانیم کار را ادامه دهیم. پس داریم:
</p>$$ f_n = f_{n-1} + f_{n-2} $$<p>و تعداد گشت های ۰ یالی و ۱ یالی از راس یک به خودش برابر ۱ است و بنابراین دنباله
f
همان دنباله فیبوناچی معروف است. پس اگر بخواهیم عدد
n
ام در دنباله فیبوناچی را حساب کنیم می توانیم ماتریس مجاورت این گراف را به توان برسانیم. یعنی
درایه ۱ و ۱ ماتریس
$ \begin{bmatrix}1 & 1\\1 & 0\end{bmatrix} ^ n $
همان فیبوناچی
n ام است.
</p><h2>تبدیل ها</h2><p>نیازی نیست که برای هر رابطه بازگشتی بیاییم و از ابتدا یک گراف بسازیم، بلکه می توانیم
تبدیل های کلی ای پیدا کنیم و گراف را طوری تغییر دهیم که الگوی خاصی از توابع را شامل شود. برای
مثال در ادامه تبدیل جمع جزیی آمده است.
</p><p>فرض کنید گرافی داریم که در آن تعداد گشت های به طول
n
آن از راس
i به j
برابر
$ f_n $
است.
دنباله g را به صورت زیر تعریف می کنیم.
</p>$$ g_0 = 0 $$$$ g_n = g_{n-1} + f_{n-1} $$<p>می خواهیم گراف را به طوری تغییر دهیم که بتوان با آن دنباله بالا را محاسبه کرد. به گراف
یک راس جدید مانند 
k
اضافه می کنیم و یک یال از راس
j به k
اضافه می کنیم و یک طوقه نیز روی راس جدید می گذاریم. تعداد گشت های از راس
i به j
تغییری نمی کند و همان حالت قبل می ماند. ادعا می کنیم که تعداد گشت های به طول
n از i به k
همان مقدار خواسته شده است. ابتدا واضح است که پایه برقرار است و هیچ گشت ۰ یالی
از i به k
وجود ندارد. برای اثبات قسمت دوم روی یال آخر گشت حالت بندی می کنیم. یا یال آخر
گشت همان یال طوقه است که ابتدای گشت
$ g_{n-1} $
حالت دارد و یا یالی است که از راس
j به k
وارد شده است که در این حالت طبق فرض ابتدای گشت می تواند
$ f_{n-1} $
حالت داشته باشد.
</p><h1>درخت دودویی (Binary Tree)</h1><p>ساختار درخت دودویی مانند یک درخت معمولی است با این تفاوت که طبقه ای است.
طبقه ها از صفر شروع می شود و در طبقه صفرم فقط یک راس قرار دارد که به آن ریشه می گویند.
هر دو راسی که بینشان یال وجود دارد در دقیقا دو طبقه متوالی قرار دارند.
دو راس u و v را در نظر بگیرید که به هم یال دارند و راس u در طبقه با شماره کمتر است، به راس u والد یا پدر راس v؛ و به راس v بچه یا پسر راس u گفته می شود.
در این گراف هر راس حداکثر دو بچه دارد و واضح است که یک والد دارد.
راس هایی که هیچ بچه ای ندارند برگ نامیده میشوند.
بلند ترین مسیر از بین تمامی مسیر هایی که از ریشه به یک برگ وجود دارد را ارتفاع می نامند.
زیر درخت به زیر گرافی از درخت دودویی گفته میشود که در آن راس u آمده باشد تمام بچه های u هم در آن آمده باشد.
</p><img src="/_static/dot/Binary_Tree.svg"><p><b>در این قسمت به سه نوع درخت دودویی اشاره می کنیم.</b>
</p><h2>Full Binary Tree</h2><p>درخت دودویی که در آن تمامی راس ها یا دو بچه دارند و یا برگ هستند.
</p><img src="/_static/dot/Full_Binary_Tree.svg"><h2>Complete Binary Tree</h2><p>درخت دودویی که تمام برگ ها در دو طبقه آخر هستند و برگ های طبقه آخر از چپ پر شدند.
</p><img src="/_static/dot/Complete_Binary_Tree.svg"><h2>Perfect Binary Tree</h2><p>به درختی که تمامی برگ ها در طبقه آخر باشند و تعداد بچه های تمامی راس ها در دیگر طبقات دو باشد گویند.
</p><img src="/_static/dot/Perfect_Binary_Tree.svg"><p>یکی از بیشترین استفاده ها از درخت دودویی، درخت جست و جوی دودویی است که جلوتر با آن بیشتر آشنا می شویم.
</p><h1>درخت جست و جوی دودویی (BST یا Binary Search Tree)</h1><p>درخت جست و جوی دودویی یک درخت دودویی خاص است که مقداری که در راس u وجود دارد از تمامی مقدار های موجود در زیر درخت بچه چپش، بزرگتر مساوی و از تمامی مقدار های موجود در زیر درخت بچه راستش بزرگتر مساوی باشد.
BST به ما این اجازه را می دهد تا سریعتر یک مقدار را اضافه، حذف و یا جستجو کنیم.
جست و جو، اضافه کردن و حذف کردن پایه های اصلی BST است.
</p><h2>(Search) جست و جو</h2><p>عملیات جست و جو کردن برای یک مقدار با فرض اینکه مقداری که دنبالش هستیم x به صورت زیر است :
</p><ul><li><p>ابتدا مقدار روی ریشه درخت را نگاه می کنیم، اگر بزرگتر از x بود همین مرحله رو به صورت بازگشتی بر روی زیر درخت بچه چپ انجام می دهیم و اگر کوچک تر بود روی زیر درخت بچه راست.
</p></li><li><p>این مرحله رو تا جایی ادامه میدیم که یا بچه مورد نظر وجود نداشته باشه تا ما بریم توی زیر درختش و یا مقدار راسی که داریم بررسی می کنیم برابر با x باشد.
</p></li></ul><h2>(Insertion) اضافه کردن</h2><p>عملیات اضافه کردن یک مقدار با فرض اینکه مقداری که قرار است اضافه شود x باشد به صورت زیر است :
</p><ul><li><p>ابتدا مقدار روی ریشه درخت را نگاه می کنیم، اگر بزرگتر مساوی از x بود همین مرحله رو به صورت بازگشتی بر روی زیر درخت بچه چپ انجام می دهیم و اگر کوچک تر بود روی زیر درخت بچه راست.
</p></li><li><p>این مرحله رو تا جایی ادامه میدیم که بچه مورد نظر وجود نداشته باشه و ما یک بچه در همون قسمت اضافه می کنیم و مقدارش رو x می گذاریم.
</p></li></ul><h2>(Deletion) حذف کردن</h2><p>بعد از پیدا کردن راسی که قرار است حذف شود به همان روش جست و جو، ۳ حالت ممکن است.
حالت اول این است که راس مورد نظر هیچ بچه ای نداشته باشه و خیلی راحت می توان همان لحظه راس را حذف کرد.
حالت دوم این است که راس مورد نظر یک بچه داشته باشد و می توان راس را حذف و بچش رو جای خودش قرار می دیم.
حالت سوم برای زمانیست که راس مورد نظر دو بچه داشته باشد. به دو روش می توان این راس را حذف کرد. و برای اینکه بهتر متوجه شید اسم راسی که قرار است حذف شود را u می گذاریم.
روش اول به این شکل است که راس v که کوچک ترین مقدار در زیر درخت راست u را دارد بدست میاریم و مقدارش رو بجای مقدار u می گذاریم. حال اگر راس v را به یکی از دو حالت یک و دو حذف می کنیم(واضح است که راس v حالت سوم نمی تواند باشد چون v کوچک ترین راس است و اگر دو بچه داشته باشد یعنی بچه سمت چپ دارد که از خودش کوچک تر است و این تناقض است).
روش دوم همانند روش اول است با این تفاوت که راس v بزرگترین راس در زیردرخت بچه چپ راس u است.
</p><h1>Heap</h1><p>Heap یا پشته به دو دسته min heap و max heap تقسیم می شود.
در min heap یا پشته کمترین مقدار هر راس از بچه هاش کوچک تر است و در max heap یا پشته بیشترین هر راس از بچه هاش بزرگتر است.
در heap برگ ها یا در دو طبقه آخر قرار دارند.
</p><h2>(Insertion) اضافه کردن</h2><p>مراحل اضافه کردن x در min heap به شکل زیر است( در max heap مراحل مشابه است)  :
</p><ul><li><p>x را در آخرین طبقه به یکی از راس های طبقه یکی مانده به آخر که هنوز دو بچه ندارد وصل میکنیم و اگر چنین راسی وجود نداشت یک طبقه جدید اضافه می کنیم و x را به یکی از راس های طبقه بالایش وصل می کنیم.
</p></li><li><p>حال x را با پدرش مقایسه می کنیم و اگر مقدارش از پدرش کمتر بود جاشون رو عوض میکنم. این مرحله را تا جایی ادامه می دهیم تا یا x ریشه شود یا از مقدار پدرش بزرگ تر باشد.
</p></li></ul><h2>(Deletion) حذف کردن</h2><p>مراحل حذف کردن در min heap به شکل زیر است( در max heap مراحل مشابه است) :
</p><ul><li><p>مقدار ریشه را با مقدار یکی از برگ های طبقه آخر عوض می کنیم و آن برگ را حذف می کنیم. در این مرحله مقدار ریشه عوض شده است بنابراین باید چک کنیم که شرایط min heap را داشته باشد،فرض کنید y مقدار کمتر بین بچه های ریشه باشد، اگر ریشه از y بزرگ تر بود جای y و ریشه را عوض میکنیم و حال این مرحله را برای زیر درختی که ریشه در آن قرار دارد انجام می دهیم.
</p></li></ul><h1>DSU</h1><p>DSU یا Disjoint-set/Union-find که به آن مجموعه های مجزا هم می گویند یک الگوریتم کاربردی برای مسائل همبندی گراف و همچنین برای محاسبه MST <https://gtoi.shaazzz.ir/book/11/1.html> است.
</p><p>این الگوریتم دو دستور اصلی ادغام و جستجو دارد. در این الگوریتم هر مجموعه یک نماینده دارد.
</p><h2>روش های اجرای DSU</h2><p>قبل از شروع باید این نکته را ذکر کنم که دو روش مشهور برای اجرای DSU مورد استفاده است که یکی لیست و دیگری جنگل است. در لیست هر عضو مجموعه در یک لیست قرار می گیرند و یک آرایه نیز وجود دارد که نشان می دهد نماینده عضو $ x $ چه عضوی است به طور مثال $ Rep[x] = X $ . و روش دیگر جنگل است که هر عضو را راس در نظر می گیریم و در هر مجموعه یک درخت داریم که تمامی راس های آن تمامی عضو های مجموعه آن است و این مجموعه از یک راس آویخته شده(نماینده مجموعه) و بقیه راس ها هر کدام یک پدر دارند و کافیست که یک آرایه نگه داریم که نشان می دهد که پدر هر کس چه راسی است(پدر راسی که در درخت پدر ندارد(نماینده مجموعه) را هم می توان خودش گذاشت تا بدانیم که نماینده درخت است). $ Par[x] = X $
</p><h2>دستور ها</h2><h3>جستجو (Find)</h3><p>دستور جستجو برای پیدا کردن نماینده یک عضو استفاده می شود. به این صورت که هنگامی که نیاز دارید تا بدانید نماینده مجموعه شامل عضو $ x $ کیست از آن استفاده می کنید.
</p><ul><li><p>روش اول که برای لیست به کار می رود به این نحو است که فقط کافیست مقدار آرایه $ Rep[x] $ را برگردانیم.
</p></li></ul><pre dir="ltr">cpp
int Find(int x){
    return Rep[x];
}</pre><ul><li><p>روش دوم که برای جنگل مورد استفاده قرار می گیرید به این نحو است که باید در هر مرحله از طریق آرایه Par به پدران راس $ x $ برویم تا به ریشه (نماینده مجموعه) برسیم. 
</p></li></ul><pre dir="ltr">cpp
int Find(int x){
    if (Par[x] == x)
        return x;
    return Find(Par[x]);
}</pre><h3>ادغام (Union)</h3><p>دو مجموعه را با هم ادغام می کند و مجموعه جدید را تشکیل می دهد. فرض کنید که دو مجموعه که شامل دو عضو $ x $ و $ y $ است را با هم ادغام کنیم.
</p><ul><li><p>در ابتدا نماینده این دو عضو را پیدا می کنیم. فرض کنید به ترتیب $ X $ و $ Y $ باشند. اگر $ X $ و $ Y $ یکی باشند به این معناست که این دو عضو در یک مجموعه هستند و لازم نیست که ادغامی انجام دهیم. اگر برابر نبودند نماینده اعضای مجموعه ای را برابر با نماینده اعضای مجموعه دیگر میکنیم. نکته ای که وجود دارد این است که نماینده مجموعه ای را تغییر می دهیم که تعداد اعضای کمتری دارد، به این دلیل که اردر این عمل $ O(n lg(n)) $ است (نماینده هر عضو حداکثر $ lg(n) $ بار عوض می شود چون در هر مرحله تعداد اعضای دسته ای که نماینده آن عوض می شود دو برابر می شود). این تکنیک ادغام مجموعه ی کوچکتر در مجموعه ی بزرگتر Union by Rank نام دارد.
</p></li></ul><pre dir="ltr">cpp
void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if (x == y)
        return;
    if (sz[x] &lt; sz[y])
        swap(x, y);
    sz[x] += sz[y];
    for (int z : lst[y]){
        Rep[z] = x;
        lst[x].push_back(z);
    }
    lst[y].clear();
}    </pre><ul><li><p>روش دیگری که برای ادغام موجود است برای زمانیست که مجموعه ها را به صورت جنگل در نظر گرفتیم. و در این صورت مانند قسمت بالا می توان با تعداد راس های هر مولفه (مجموعه) مقایسه انجام داد و نماینده مولفه با تعداد راس کمتر را نماینده مولفه دیگر کرد. در اینصورت برای پیدا کردن ریشه ی مولفه یک راس دلخواه ، حداکثر $ lg(n) $ بار تابع Find صدا می شود (به زبانی دیگر ارتفاع هر کس در جنگل حداکثر $ lg(n) $ است).
</p></li></ul><pre dir="ltr">cpp
void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if (x == y)
        return;
    if (sz[x] &lt; sz[y])
        swap(x, y);
    sz[x] += sz[y];
    Par[y] = x;
}</pre><h3>فشرده سازی مسیر (Path Compression)</h3><p>حال اگر از تکنیک فشرده سازی مسیر یا Path Crompression برای پیدا کردن ریشه در تابع Find استفاده کنیم ، می توانیم اردرمان را بهتر کنیم. به این روش که وقتی به دنبال ریشه $ x $ هستیم در انتها پدر $ x $ را برابر با ریشه می کنیم. این روش که Path Compression نام دارد باعث می شود تمام راس هایی که در مسیر $ x $ تا ریشه هستند پدر خود را به ریشه تغییر دهند، در این صورت تعداد بچه های ریشه زیاد می شود. با این روش مسیر $ x $ به ریشه کوتاه تر می شود (برای درک بهتر این قسمت تابع Find را ببینید) و باعث می شود اردر سرشکن هر عملیات مان $ O(lg^*n) $ شود. این یعنی برای  $ n = 10^6 $ پنج عملیات انجام می شود ($ lg^*n $ به معنی  تعداد دفعاتیست که باید از  $ n $، لگاریتم بگیریم تا به یک برسیم. برای مثال $ lg^*4 = 2 $ است چون با یک بار لگاریتم گرفتن 4 به 2 تبدیل می شود و با لگاریتم گرفتن دوباره به 1 که در این جریان دو بار لگاریتم گرفتیم پس جواب 2 است). در کل $ lg^*n $ برای $ n $ های کوچک تر از $ 2^{65536} $ حداکثر 5 است و این نشان از سریع بودن عملکرد روش Path Compression است.
نکته ای که حائز اهمیت است این است که حتی اگر Path Compression را بدون استفاده از Union by Rank به کار ببریم ، اردر سرشکن هر عملیات مان $ O(lg(lg(n))) $ خواهد بود و در عمل تفاوتی با استفاده از Union by Rank ندارد!
</p><pre dir="ltr">cpp
int Find(int x){
    if(Par[x] != x)
        Par[x] = Find(Par[x]);
    return Par[x];
}</pre><h3>آندو (Undo)</h3><p>آخرین عملیات ادغام را آندو می کند و دو مجموعه ای که ادغام شده بودند را از هم جدا می کند. فرض کنید که از روش Path Compression استفاده نکنیم. در اینصورت با هر بار صدا شدن تابع ادغام ، تنها دو مقدار $ sz_x $ و $ Par[y] $ تغییر می کنند. پس می توانیم تغییراتی که انجام داده ایم را ذخیره کنیم تا در صورت نیاز به آندو ، به آنها رجوع کنیم و مقدار پیشین این دو متغیر را جایگزین مقدار فعلی شان کنیم. بدین شکل می توانیم هر عملیات آندویمان را در $ O(1) $ پیاده سازی کنیم.
</p><p>دقت کنید که در صورت داشتن تابع آندو دیگر نمی توانیم از Path Compression استفاده کنیم زیرا دیگر اردرمان خوب  نمی شود (به خاطر بیاورید که اردر Path Compression به صورت سرشکن خوب می شود و هر بار صدا شدن تابع Find به تنهایی ممکن است حتی $ O(n) $ باشد).
</p><pre dir="ltr">cpp
int Find(int x){
    if(Par[x] == x)
        return x;
    return Find(Par[x]);
}
void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if (x == y)
        return;
    if (sz[x] &lt; sz[y])
        swap(x, y);
    operations.push_back(make_pair(y, sz[y]));
    sz[x] += sz[y];
    Par[y] = x;
}
void Undo(){
    int y = operations.back().first;
    sz[y] = operations.back().second;
    operations.pop_back();
    int x = Find(y);
    sz[x] -= sz[y];
    Par[y] = y;
}</pre><h2>لیست یا جنگل؟</h2><p>شاید برایتان سوال شود که الآن برای اجرای الگوریتم به کدام روش عمل کنیم؟
مجموعه را لیست کنیم یا به شکل گراف دراریم؟
در برخی از مسائل ممکن است نیاز به نگه داشتن مجموعه (مولفه) هر راس و یا امکان آندو کردن عملیات های ادغام پیشین داشته باشیم که در این صورت نیاز به روش لیستی داریم.
در سایر مواقع بهتر است که از روش جنگل استفاده کنیم. چرا که هنگامی که از Path Compression استفاده می کنیم اردر دو دستور Find و Union به شدت پایین میاد و به $ O(lg^*n) $ می رسد .
</p><h1>Segment Tree</h1><p>یکی از پرکاربرد ترین داده ساختار های مورد استفاده در المپیاد کامپیوتر بی شک Segment Tree است.
نوع درخت دودویی آن Full Binary Tree <https://gtoi.shaazzz.ir/book/8/1.html#full-binary-tree> است.
</p><p>با استفاده از این داده ساختار می توان جمع یک بازه از آرایه و بیشترین یا کمترین مقدار یک آرایه را بدست آورد.
</p><h2>ساختار</h2><p>هر راس این درخت بیانگر یک بازه از آرایه مورد پرسش است.
بچه های هر راس (اگر موجود باشد طبیعتاً دو تا است) بازه پدر خود را نصف می کنند یا به عبارت دیگر اگر بازه راسی $ [Begin, End) $ باشد بازه دو پسر چپ و راست آن به ترتیب $ [Begin, Middle) $ و $ [Middle, End) $ است.
راس های بدون بچه هم حاوی تک عضوی از آرایه است.
</p><p>برای بهتر فهمیدن رابطه ی بین راس ها و بازه ها به شکل زیر نگاه کنید.
</p><img src="/_static/SegmentTree.png"><p>در هر کدام از این راس ها یک اطلاعات مشخصی از بازه متناظر آن راس در آرایه در دسترس است که بسته به استفاده ما از این داده ساختار می تواند متفاوت باشد.
برای نمونه اگر دنبال جمع یک بازه از آرایه هستیم هر کدام از راس ها در خود مجموع بازه متناظرشان را ذخیره می کنند.
</p><p>برای درک بیشتر از این قسمت به شکل زیر نگاه کنید که چطور هر راس مقداری را ذخیره کرده.
</p><img src="/_static/construction.png"><p>ارتفاع این درخت $ lg n $ و تعداد راسی که مورد استفاده قرار می دهد حداکثر $ 2n $ است بنابراین شما با حافظه $ 2n $ می توانید این داده ساختار را ذخیره کنید. لازم به ذکر است که بعضی افراد حافظه $ 4n $ را در نظر می گیرند که بخاطر نوع پیاده سازی برای هر برگ درخت(راس های تک عضوی) دو بچه بدون هیچ مشخصه ای قرار می دهند که باعث می شود حافظه دو برابر شود.
</p><p>برای شماره گذاری راس ها هم می توان به ریشه عدد یک داد و به بچه های راست و چپ هر راس به ترتیب $ 2k $ و $ 2k + 1 $ داد.
</p><h2>الگوریتم</h2><p>نحوه اجرای این الگوریتم برای انواع سوال های قابل حل با این داده ساختار تقریبا یکسان است و ما با استفاده از یکی از پرسش های مشهور این داده ساختار، به توضیح این الگوریتم می پردازیم.
</p><p>در ابتدا به ما یک آرایه داده شده و در هر مرحله از ما می خواهند که یا مقدار یک عضو آرایه را تغییر دهیم و یا جمع یک بازه را گزارش دهیم.
</p><h3>ساخت</h3><p>برای حل ابتدا Segment Tree را از روی آرایه می سازیم. برای اینکار اول ساختار اصلی Segment Tree را می سازیم و بعد مقدار هر راس را برابر جمع مقدار بچه هایش می گذاریم و مقدار راس های تک عضوی را مقدار عضو متناظر می گذاریم.
</p><pre dir="ltr">cpp
void build(int u = 1, int ul = 0, int ur = n){
    if(ur - ul &lt; 2){
        seg[u] = a[ul];
        return;
    }
    int mid = (ul + ur) / 2;
    build(u * 2, ul, mid);
    build(u * 2 + 1, mid, ur);
    seg[u] = seg[u * 2] + seg[u * 2 + 1];
}</pre><h3>تغییر دادن مقدار یک عضو</h3><p>مقدار تمام راس هایی که بازه آن ها شامل این عضو می شود را تغییر می دهیم. توجه کنید که تعداد این بازه ها حداکثر برابر ارتفاع درخت است چرا که هر طبقه از درخت، آرایه را افراز می کند بنابراین در هر طبقه باید مقدار حداکثر یک راس تغییر کند بنابراین اردر این عملیات $ O(lg n) $ است.
</p><pre dir="ltr">cpp
void update(int i, int x, int u = 1, int ul = 0, int ur = n){
    seg[u] += x - a[i];
    if(ur - ul &lt; 2){
        a[i] = x;
        return;
    }
    int mid = (ul + ur)/2;
    if(i &lt; mid)
        update(i, x, u * 2, ul, mid);
    else
        update(i, x, u * 2 + 1, mid, ur);
}</pre><h3>گزارش دادن جمع یک بازه از آرایه</h3><p>از روش بازگشتی استفاده می کنیم و در هر مرحله جمع بازه خواسته شده را با فرض روی راس u بودن بدست می آوریم.
سه حالت برای بازه خواسته شده و بازه راس u وجود دارد. حالت اول این است که این دو بازه برابر باشند که خب جواب مقدار راس u است. حالت دوم زمانیست که بازه خواسته شده به صورت کامل در بازه یکی از بچه های راس u باشد که آنگاه جواب را در بچه ای که بازه خواسته شده در آن است پیدا می کنیم.
حال آخر زمانیست که مقداری از بازه خواسته شده در بازه بچه چپ و بقیه آن در بازه بچه راست u باشد، بدین منظور به صورت بازگشتی ابتدا مقدار قسمتی از بازه خواسته شده که در بازه بچه چپ u است را بدست می آوریم و بعد مقدار قسمتی که در بازه بچه راست u است و بعد جمع این دو جواب است.
برای بدست آوردن جمع بازه خواسته شده کافیست با همین روش از راس یک شروع کنیم.
</p><p>برای فهم بهتر فرض کنید $ F(u,ul,ur,l,r) $ تابع بازگشتی بالا باشد که با گرفتن راسی که روی آن هستیم و بازه این راس و بازه خواسته شده، جواب را به ما بدهد(با فرض اینکه بازه خواسته شده درون بازه راس u باشد) و $ sum[u] $ به معنای مقدار ذخیره شده در راس u باشد. خلاصه سه حالت بالا به صورت زیر می شود.
</p>$$ Middle = (ul + ur) / 2 $$$$ (ul = l, ur = r) => F(u,ul,ur,l,r) = sum[u] $$$$ (r < Middle) => F(u,ul,ur,l,r) = F(2*u,ul,Middle,l,r) $$$$ (l > Middle) => F(u,ul,ur,l,r) = F(2*u,Middle,ur,l,r) $$$$ (l < Middle, Middle < r) => F(u,ul,ur,l,r) = F(2*u,ul,Middle,l,Middle) + F(2*u+1,Middle,ur,Middle,r) $$<p>اردر این عملیات $ O(lg n) $ است به این دلیل که در هر طبقه حداکثر ۴ راس در تابع بازگشتی مورد استفاده قرار می گیرند. برای اثبات کافیست توجه کنید که فقط راست ترین و چپ ترین راس های یک طبقه می توانند بچه های خود را صدا کنند و این یعنی در هر طبقه حداکثر ۴ راس صدا زده می شوند.
</p><pre dir="ltr">cpp
int sum(int l, int r, int u = 1, int ul = 0, int ur = n){
    if(x &gt;= ur || ul &gt;= y)return 0;
    if(x &lt;= ul &amp;&amp; ur &lt;= y)return seg[u];
    int mid = (ul + ur) / 2;
    return sum(l, r, u * 2, ul, mid) + sum(l, r, u * 2 + 1, mid, ur);
}</pre><h2>انتشار با تاخیر (Lazy propagation)</h2><p>فرض کنید در عملیات اول بجای تغییر یک مقدار، تغییر یک بازه مطرح باشد. به طور مثال به ما بگوید به بازه $ L $ تا $ R $ دو واحد اضافه کنیم. اگر بخواهیم تمامی عنصر های این بازه را عوض کنیم کار سخت است و تعداد عملیات هایمان بالا می رود. حال با استفاده از تکنیک انتشار با تاخیر می توانیم تعداد عملیات ها را پایین بیاوریم. به این صورت که به ازای هر راس یک مقدار دیگر هم در نظر می گیریم که بر فرض در آرایه Lazy ذخیره می شود. بازه داده شده برای تغییر را مانند روشی که در عملیات دوم برای بازه خواسته شده انجام دادیم افراز می کنیم به بازه های کوچک تر (روی درخت) و مقدار آرایه Lazy تمامی این راس ها (راس هایی که بازه روی آن ها افراز شده) را عوض می کنیم. و هر هنگام که در کل این الگوریتم بر روی راسی از درخت بودیم Lazy آن را به مقدار خود راس اضافه می کنیم و Lazy آن را به Lazy بچه هایش اضافه می کنیم و بعد آن را صفر می کنیم.
</p><pre dir="ltr">cpp
void upd(int u, int ul, int ur, int x){
    lazy[u] += x;
    seg[u] += (ur - ul) * x;
}
void shift(int u, int ul, int ur){
    int mid = (ul + ur) / 2;
    upd(u * 2, ul, mid, lazy[u]);
    upd(u * 2 + 1, mid, ur, lazy[u]);
    lazy[u] = 0;
}
void increase(int l, int r, int x, int u = 1, int ul = 0, int ur = n){
    if(l &gt;= ur || ul &gt;= r)return;
    if(l &lt;= ul &amp;&amp; ur &lt;= r){
        upd(u, ul, ur, x);
        return;
    }
    shift(u, ul, ur);
    int mid = (ul + ur) / 2;
    increase(l, r, x, u * 2, ul, mid);
    increase(l, r, x, u * 2 + 1, mid, ur);
    seg[u] = seg[u * 2] + seg[u * 2 + 1];
}
int sum(int l, int r, int u = 1, int ul = 0, int ur = n){
    if(l &gt;= ur || ul &gt;= r)return 0;
    if(l &lt;= ul &amp;&amp; ur &lt;= r)return seg[u];
    shift(u, ul, ur);
    int mid = (ul + ur) / 2;
    return sum(l, r, u * 2, ul, mid) + sum(l, r, u * 2 + 1, mid, ur);
}</pre><h1>Trie</h1><p>ترای یک درخت ریشه دار است که برای نگه داشتن چند کلمه استفاده می شود.
هر کلمه به صورت زنجیره ای از حروف است که از ریشه شروع می شود.
اگر دو کلمه پیشوند یکسانی داشته باشند، یک زنجیر یکسان هم در درخت دارند.
فرض کنید تعداد حروف مورد استفاده در کلمات X باشد.
در این صورت هر راس حداکثر X بچه دارد.
دقت کنید که در راس ها حروف وجود ندارند بلکه یال بین هر دو راس دارای حرف است برای فهم بهتر به شکل زیر نگاه کنید.
</p><img src="/_static/dot/Trie.svg"><p>هر راس می تواند یک علامت هم داشته باشد و اگر راسی علامت داشته باشد به این معنی است که در این راس کلمه ای به پایان رسیده است و مسیر ریشه تا این راس آن کلمه است.
اگر ممکن بود چند کلمه یکسان بین کلمات وجود داشته باشد می توان بجای علامت از عدد استفاده کرد و تعداد کلمات پایان یافته در هر راس را نگه داشت.
</p><h2>جست و جو (Search)</h2><p>شما می توانید در $ O(n) $ چک کنید که یک کلمه به طول n در درخت ترای وجود دارد یا نه.
</p><p>به این صورت که از ریشه شروع می کنید و حرف به حرف جلو می رید و اگر در راسی مانند u هستید و حرف بعدی در کلمه X است اگر راس u با یال X به بچه v می رفت به راس v و حرف بعدی در کلمه می رویم، اگر راس u یال X نداشت به این معناست که کلمه در درخت وجود ندارد.
این عملکرد را تا جایی ادامه می دهیم تا کلمه تمام شود(حرف بعدی وجود نداشته باشد). فرض کنید کلمه روی راس w تموم شده است، اگر راس w علامت داشت (و یا مقدار عددی آن طبیعی بود) به این معناست که کلمه وجود دارد و در غیر این صورت کلمه وجود ندارد.
</p><h2>اضافه کردن (Insertion)</h2><p>شما می توانید در $ O(n) $ یک کلمه به طول n را در درخت ترای اضافه کنید.
</p><p>به این صورت که از ریشه شروع می کنید و حرف به حرف جلو می رید و اگر در راسی مانند u هستید و حرف بعدی در کلمه X است اگر راس u با یال X به بچه v می رفت به راس v و حرف بعدی در کلمه می رویم،
اگر کلمه تمام شده راسی که روی آن هستیم را علامت می زنیم(یا به عدد آن یک واحد اضافه می کنیم) و اگر یال X وجود ندارد راس جدیدی می سازیم و راس فعلی را با یال X به آن وصل می کنیم و به حرف بعدی و راس بعدی(راس تازه ساخته شده) می رویم.
این روند را ادامه می دهیم تا جایی که یا کلمه تموم شود.
</p><h2>کاربردها</h2><p>برای برخی سیستم‌ های تکمیل خودکار رشته (autocomplete) استفاده می‌ شود.
برای ذخیره ‌سازی و دسترسی سریع به رشته های یک لغت‌نامه کاربرد فراوانی دارد.
می‌تواند در بعضی شرایط به عنوان جایگزینی برای جدول ‌های درهم ‌سازی استفاده بشود.
از ترای برای مرتب‌ سازی داده ‌ها در زمان خطی استفاده می‌ شود. مثلاً اگر مجموعه‌ ای از رشته ‌ها را در ترای درج کنیم و نمایش پیش‌ ترتیب آن را چاپ کنیم، رشته‌ها به ترتیب لغتنامه‌ ای مرتب می‌شوند. همچنین اگر ترای را با مجموعه‌ ای از اعداد بسازیم، جستجوی سطح اول اعداد را به ترتیب می‌ پیماید.
</p><h1>تعریف np و np کامل</h1><p>ممکن است شنیده باشید که فلان مساله
np
است و نمی توان آن را حل کرد. اما واقعا یعنی چه؟ و چرا نمی توان آن را حل
کرد؟ در این فصل به بررسی این مسائل می پردازیم.
</p><p>هدف از این فصل، تعیین تکلیف مسائلی از گراف است که به ارائه الگوریتمی برای آن ها
نپرداختیم. این فصل، عدم موفقیت ما برای ارائه الگوریتم پرکتیکال برای این مسائل
را توجیه می کند.
</p><p>این مبحث، یکی از مباحث علوم نظری کامپیوتر است. اگر چه خواندن این فصل به طور مستقیم
کمکی به موفقیت شما در آزمون های المپیاد کامپیوتر نخواهد کرد، اما خواندن آن به
دلایل زیر توصیه می شود:
</p><ul><li><p>این مبحث یکی از جالب ترین مباحث علوم نظری کامپیوتر است و شما که علاقه مند به
المپیاد کامپیوتر هستید قطعا از آن لذت خواهید برد.
</p></li><li><p>خواندن این مبحث به شما کمک می کند تا از باور های غلط رایج در میان دانش آموزان
درباره مسائل np دور بمانید.
</p></li><li><p>خواندن این مبحث به شما کمک می کند که راحت تر مسائل
np
را تشخیص دهید و در آزمون به حل آن ها نپردازید.
</p></li></ul><h2>مسائل تصمیم</h2><p>مسائل تصمیم، مسائلی هستند که پاسخ آن ها تنها یک بیت است. یعنی پاسخ آن ها بله
یا خیر است. مثلا مساله یک عدد را تجزیه کنید یک مساله تصمیم نیست اما یک عدد اول
است یا خیر یک مساله تصمیم است.
</p><p>عموما برای مسائل، یک مساله تصمیم وجود دارد که می توان با آن، مساله اصلی را حل کرد. مثلا
مساله کوچک ترین عامل اول این عدد، بزرگ تر از
k
است یا خیر می تواند به کمک یک جستجوی دو دویی مساله تجزیه را حل کند. در حالت کلی، مساله
تصمیم آیا بیت کا ام خروجی ۱ است، می تواند مساله اصلی را حل کند.
</p><p>در این بخش ما با مسائل تصمیم سر و کار داریم، اما از نتیجه می توان به طور گسترده
در مسائل دیگر نیز استفاده کرد.
</p><h2>کلاس P</h2><p>مسائل کلاس
P
دسته ای از مسائل تصمیم هستند که الگوریتمی وجود دارد که می تواند در
$ O(|s|^k) $
نتیجه را معین کند. در این جا
$ s $
رشته ورودی،
$ |s| $
طول رشته ورودی و
$ k $
یک عدد ثابت مستقل از ورودی است. به عبارت دیگر، مسائلی که در زمان چند جمله ای بر حسب
طول ورودی حل می شوند، در این کلاس هستند. توجه کنید که طول ورودی همیشه پارامتری نیست
که ما برحسب آن پیچیدگی الگوریتم را تحلیل می کنیم، مثلا مساله تصمیم تجزیه یک عدد، یعنی
آیا عدد
$ n $
عامل اولی کوچک تر از
$ k $
دارد یا خیر، الگوریتمی با پیچیدگی زمانی
$ O(\sqrt{n}) $
یا همان
$ n^{\frac{1}{2}} $
دارد اما این مساله در کلاس
P
قرار ندارد. زیرا طول ورودی از
$ O(lg(n)) $
بوده است و یعنی الگوریتم ما بر حسب طول ورودی، چند جمله ای نبوده است.
</p><h2>کلاس NP</h2><p>این مسائل، دسته ای از مسائل هستند که لزوما یک راه حل چند جمله ای ندارند، اما
یک تایید کننده چند جمله ای دارند.
</p><h3>تایید کننده</h3><p>تایید کننده یک مساله، خود یک مساله تصمیم است که ورودی مساله اصلی را به همراه یک
رشته کمکی (که یک جواب یا اثبات خوانده می شود) می گیرد و تعیین می کند که آیا این
جواب درستی برای مساله است یا نه. اگر یک رشته کمکی وجود داشته باشد که تایید کننده آن را
تایید کند، یعنی جواب مساله اصلی مثبت بوده است و اگر جواب مساله اصلی منفی باشد، هیچ
رشته ای وجود ندارد که تایید کننده آن را تایید کند.
</p><p>به عبارت دقیق تر، اگر مساله اصلی را با
$ X $
نشان دهیم که
$ X(s) $
یا تایید و یا رد است، به یک مساله مانند
$ C(s,t) $
یک تایید کننده برای مساله ایکس می گوییم اگر و تنها اگر دو شرط زیر برقرار باشد:
</p><ul><li><p>اگر
$ X(s) = 0 $
باشد آن گاه به ازای هر رشته ممکن t
$ C(s,t) = 0 $
است.
</p></li><li><p>اگر
$ X(s) = 1 $
باشد آن گاه حداقل یک رشته وجود دارد که
$ C(s,t) = 1 $
باشد.
</p></li></ul><h3>تعریف</h3><p>حال به تعریف کلاس
NP
باز می گردیم. یک مساله عضو این کلاس است، اگر و تنها اگر یک تایید کننده داشته باشد
که در زمان چند جمله ای به نتیجه برسد و هم چنین اگر جواب مساله اصلی مثبت است، یک رشته
کمکی با طول چند جمله ای نسبت به ورودی وجود داشته باشد که تایید کننده آن را تایید کند.
</p><h3>مثال</h3><p>طیف گسترده ای از مسائل در این کلاس قرار دارد. مثلا مساله این که آیا گراف دور همیلتونی
دارد یا خیر را در نظر بگیرید. یک تایید کننده، می تواند جایگشتی از رئوس را در ورودی
بگیرد و بررسی کند که آیا هر عضو این جایگشت به عضو بعدی اش یال دارد یا خیر. اگر
جواب مساله اصلی منفی باشد هیچ جایگشتی وجود ندارد و اگر مثبت باشد جایگشتی وجود دارد که
طول آن از گراف اصلی کمتر است و تایید کننده می تواند در زمان خطی، این بررسی را انجام
دهد. پس مساله دور همیلتونی یک مساله در کلاس
NP
است.
</p><p>مساله تصمیم متناظر تجزیه اعداد نیز یک مساله
NP
است. یک تایید کننده می تواند یک عدد کوچکتر از
k
را ورودی بگیرد و تشخیص دهد که آیا ورودی به این عدد بخش پذیر است یا نه. این تشخیص
می تواند در زمان چند جمله ای تقسیم را انجام دهد (با کمک الگوریتمی که در دبستان
خواندیم) و طول اثبات (همان عدد کوچکتر از
k)
از طول ورودی کمتر است بنابراین این
مساله نیز در کلاس
NP
قرار دارد.
</p><h2>کاهیدن چند جمله ای</h2><p>تعریف می کنیم مساله
A
به مساله
B
در زمان چند جمله ای کاهیده می شود، اگر
و تنها اگر بتوان به کمک یک الگوریتم 
و یک ماشین پیشگوی مساله
B
مساله
A
را در زمان چند جمله ای حل کرد. کاهیدن از این جهت مورد توجه است که
اگر A به B کاهیده شود و B
در زمان چند جمله ای حل شود،
A نیز در زمان چند جمله ای حل می شود.
</p><h2>مسائل NP سخت و NP کامل</h2><p>به یک مساله
NP سخت
می گوییم اگر و تنها اگر هر مساله در کلاس
NP
را بتوان در زمان چند جمله ای به این مساله کاهید. اگر یک مساله
NP سخت
خود در کلاس
NP
باشد، به آن
NP کامل
گفته می شود.
شاید عجیب به نظر برسد که همه مسائل که گستره و تنوع عظیمی دارند را به یک مساله
کاهید، اما در ادامه این فصل با مسائل
NP سخت و NP کامل
زیادی آشنا می شوید.
</p><h2>P=NP</h2><p>این مساله بزرگترین مساله باز در کل علوم کامپیوتر است. این مساله بیان می کند که آیا
همه مسائل کلاس
NP
در زمان چند جمله ای حل می شوند یا خیر؟ این مساله معادل این است که یکی از مسائل
NP
سخت را بتوان در زمان چند جمله ای حل کرد.
</p><p>جواب مثبت به این مساله، تمام الگوریتم های رمز نگاری را می شکند و پتانسیل فروپاشی
اقتصاد را دارد. از طرفی دیگر، مسائل محاسباتی که اکنون میلیارد ها سال طول می کشند را
در زمان کوتاهی محاسبه می کند. می تواند کلید حل سرطان را ها پیدا کند و ...
</p><p>جواب منفی به این مساله اگرچه کاربرد عملی ندارد
و باور عمومی این است که جواب منفی است، ولی یک پیشرفت شگرف در علوم نظری
کامپیوتر است. برای اثبات این مساله، یک میلیون دلار جایزه در نظر گرفته شده است.
</p><h1>اثبات np کامل بودن مساله sat</h1><p>در قسمت قبل با تعریف مسائل
np کامل
و
np سخت
آشنا شدیم. شاید فکر کنید که ممکن نیست مساله
np کاملی
وجود داشته باشد اما در این قسمت، ثابت خواهیم کرد که مساله
sat
یک مساله
np کامل
است. این اثبات، راه را برای اثبات بقیه مسائل
np کامل
و
np سخت
هموار می کند.
</p><h2>تعریف مساله ها</h2><p>در این قسمت چند مساله از خانواده مسائل
sat
را می بینیم که در ادامه به آن ها اشاره خواهیم کرد. کلمه
sat
مخفف
satisfiablity
به معنای توانایی برآورده کردن شرایط است. هر مساله یک مساله تصمیم است که ما باید
در آن الگوریتمی ارائه کنیم که بررسی کند آیا می توان خروجی ها را به گونه ای قرار داد
تا ورودی یک شود یا خیر.
</p><p><b>circuit-sat</b>:
در این مساله یک مدار منطقی ورودی می گیریم که از گیت های اور و اند و نات تشکیل شده است. این
مدار تعدادی ورودی و دقیقا یک خروجی دارد. الگوریتم باید تشخیص دهد که آیا ممکن است ورودی
ها را به گونه ای تنظیم کرد که خروجی برابر یک شود؟
توجه کنید که مدار هایی که این مساله به عنوان ورودی می گیرد، یک مدار منطقی ترکیبی است
یعنی دوری وجود ندارد و خروجی یک گیت روی ورودی های آن تاثیر نمی گذارند.
</p><img src="/_static/logic_circuit.png"><p><b>sat</b>:
این مساله حالت خاصی از مساله بالا است که در آن خروجی به یک گیت اند بزرگ متصل است و
هر پایه از گیت اند، به یک گیت اور بزرگ وصل است که هر پایه از آن، یا به خود ورودی
وصل است و یا به نقیض ورودی. به عبارت دیگر، یک عبارت به صورت
$ (x_1 \lor x_7 \lor \overline{x_3}) \land ... \land (x_2 \lor \overline{x_1} \lor ... \lor x_7) $
به شما داده می شود و شما باید تعیین کنید که آیا می توان متغیر ها را با اعداد
0 و 1
جایگزین کرد به طوری که نتیجه
عبارت (علامت شبیه هفت به معنای
یای منطقی، علامت هشت به معنای و منطقی و
خط روی متغیر به معنای نقیض منطقی است) برابر یک شود.
</p><p><b>‪3-sat‬</b>:
این مساله حالت خاصی از مساله بالا است که در آن، هر پرانتز دقیقا ۳ متغیر دارد. به طور
مشابه،
<b>‪2-sat‬</b>
تعریف می شود که در فصل های دیگر با الگوریتم حل آن آشنا می شوید.
</p><h2>اثبات np کامل بودن circuit-sat</h2><p>یک مساله
np
دلخواه را در نظر بگیرید. این مساله، یک تایید کننده در زمان چند جمله ای دارد. هر
تایید کننده، خود یک مساله تصمیم است. نکته کلیدی این است که هر الگوریتم تصمیم که
زمان اجرای چند جمله ای داشته باشد را می توان به یک مدار منطقی ترکیبی تبدیل کرد. اگرچه
اثبات دقیق این مطلب، نیاز به شناخت دقیق تری از الگوریتم دارد و مناسب این کتاب نیست، اما
می توانید آن را روی مسائل کنار دستتان امتحان کنید. مثلا یک مدار برای تایید کننده مساله
دور همیلتونی یا مساله عدد رنگی ارائه کنید.
</p><p>پس تصمیم کننده را به ازای ورودی با طول ثابت، به یک مدار منطقی ترکیبی تبدیل می کنیم
که تعداد گیت هایش برحسب ورودی، چند جمله ای باشد. حال اگر بتوان به تایید کننده
ورودی داد که آن را تایید کند، می توان به مدار معادل آن نیز ورودی داد تا خروجی اش
یک شود. بنابراین جواب مساله اصلی، معادل با نتیجه
circuit-sat
روی این مدار است. پس هر مساله در کلاس
np
را می توان به مساله
circuit-sat
در زمان چند جمله ای کاهش داد و بنابراین مساله
circuit-sat
یک مساله
np کامل
است.
</p><h2>کاهش مساله circuit-sat به sat</h2><p>در این قسمت ثابت خواهیم کرد که مساله
‪3-sat‬
نیز یک مساله
np کامل
است و از آن نتیجه می شود که حالت کلی تر مساله، یعنی مساله
sat
نیز
np کامل
است. ابتدا توجه کنید که دقیقا سه متغیره بودن جملات، اهمیت چندانی ندارد زیرا می توان
جملات را با اضافه کردن متغیر های تکراری بزرگ کرد، مثلا
$ (x \lor \overline{y}) $
را به
$ (x \lor \overline{y} \lor \overline{y}) $
تبدیل کرد.
</p><p>حال یک مدار ترکیبی را در نظر بگیرید. ابتدا تمام گیت های اند یا اور که بیشتر از
دو ورودی دارند را تبدیل به گیت های دو ورودی کنید. با این کار طول ورودی به صورت
خطی زیاد می شود که اهمیتی برای ما ندارد. حال به ازای هر دسته از نقاط هم پتانسیل
(یعنی نقاطی که با سیم به هم متصل هستند)
یک متغیر در نظر می گیریم. حالا به ازای هر گیت، چند شرط اضافه می کنیم به طوری که
رفتار گیت را تضمین کند. یعنی شرط ها تنها در صورتی برقرار باشند که خروجی گیت
متناظر با ورودی های گیت و تابع گیت باشد. برای مثال فرض کنید
$ a $
و
$ b $
ورودی های یک گیت اند و
$ x $
خروجی آن باشد. با اضافه کردن شرط های
$ \overline{a} \lor \overline{b} \lor x $
و
$ a \lor \overline{x} $
و
$ b \lor \overline{x} $
می توانیم تضمین کنیم که مقدار
$ x $
حتما برابر و منطقی
$ a $ و $ b $
باشد. به همین ترتیب می توان برای گیت اور و گیت نات نیز چنین شرط هایی تعریف
کرد. با اند گرفتن از این شرط ها و خروجی مدار که خود یک متغیر است، می توان یک ورودی برای
3-sat
ساخت که حواب داشتنش معادل جواب داشتن همان مدار در
circuit-sat
است. پس این مساله و حالت کلی آن یعنی
sat
هر دو
np کامل
هستند.
</p><h1>مسائل np کامل گراف</h1><p>np
کامل بودن مساله های خانواده
sat
کلیدی برای اثبات
np کامل و np سخت
بودن دیگر مسائل است. در این فصل مسائلی از گراف که
np کامل یا np سخت
هستند را بررسی می کنیم. روند کار به این شکل است که هر مساله جدید را به یکی از
مسائلی که قبلا ثابت کرده بودیم در زمان چند جمله ای کاهش می دهیم و به این ترتیب
np کامل یا سخت
بودن آن ها اثبات می شود.
</p><p>این اثبات ها عموما در مقاله کارپ در سال
1972
آمده اند. کارپ در این مقاله ۲۱ مساله
np
کامل را معرفی و اثبات کرده است.
</p><p>این اثبات ها چندان سخت نیستند و به عنوان یک تمرین فکری، خوب است که قبل از مطالعه
راه حل ها، خودتان به مسائل فکر کنید و آن ها را ثابت کنید.
</p><h2>بزرگ ترین مجموعه مستقل</h2><p>در این قسمت ثابت می کنیم که مساله آیا گراف یک زیرگراف القایی با
$ k $
راس و بدون یال دارد یا خیر، یک مساله تصمیم
np
کامل است که نشان می دهد محاسبه
$ \alpha $
گراف یک مساله
np
سخت است.
</p><p>این مساله را به مساله
3sat
کاهش می دهیم. به ازای هر جمله در ورودی
3sat
سه راس متناظر با اعضای آن عبارت بگذارید و آن ها را به هم وصل کنید. سپس
هر دو راسی که یکی متغیر و دیگری نقیض آن است را به هم وصل کنید. گرافی با
$ 3k $
راس و چند یال ساخته می شود. واضح است که مجموعه مستقل این گراف از
$ k $
نمی تواند بیشتر باشد. حال این گراف یک مجموعه مستقل به این اندازه دارد
اگر و تنها اگر مساله اصلی بتواند برقرار شود. چون در هر جمله باید حداقل
یکی انتخاب شود که مقدارش برابر یک باشد و این اعضای انتخاب شده نمی توانند
نقیض هم باشند، پس در گراف اصلی به هم یال ندارند و یک مجموعه مستقل تشکیل می دهند.
</p><p>لازم به ذکر است که اگر
$ k $
یک عدد ثابت باشد (مثلا مساله این باشد که آیا گراف یک مثلث دارد) آنگاه این مساله
np کامل
نیست و راهی چند جمله ای در زمان
$ O(n^k) $
خواهد داشت.
</p><h2>خوشه گراف و مینیمم پوشش راسی</h2><p>بزرگترین خوشه همان بزرگ ترین مجموعه مستقل گراف مکمل است. بنابراین محاسبه
$ \omega $
یک گراف هم
np
سخت است.
</p><p>کوچک ترین پوشش راسی نیز برعکس بزرگ ترین مجموعه مستقل است. یعنی راس های بیرون
بزرگ ترین مجموعه مستقل، کوچک ترین مجموعه پوشش راسی را تشکیل می دهد و بلعکس، پس
$ \beta $
گراف هم یک مساله
np سخت
است.
</p><h2>عدد رنگی</h2><p>مساله تصمیم آیا این گراف ورودی سه بخشی است، یک مساله
np کامل
است. از این مطلب نتیجه می شود که محاسبه عدد رنگی یا
$ \chi $
گراف یک مساله
np سخت
است.
</p><p>این مساله را نیز به مساله
3sat
کاهش می دهیم. گرافی به این شکل می سازیم:
</p><ul><li><p>سه راس درست، غلط و خنثی می سازیم و آن ها را دو به دو به هم وصل می کنیم. این
کار را به این دلیل انجام می دهیم که این رئوس همرنگ نشوند و رنگشان نماینده درستی
یا غلطی متغیر باشند.
</p></li><li><p>به ازای هر متغیر و نقیضش، یک راس می گذاریم و این دو را با یال به هم متصل
می کنیم. هم چنین جفت آن ها را به راس خنثی وصل می کنیم تا یکی از دو رنگ درست
یا غلط را برگزینند.
</p></li><li><p>سپس به ازای هر جمله، یک گجت به گراف اضافه می کنیم. گجت گرافی است که
سه یال به بیرون و یک راس نهایی دارد. گجت این خاصیت را دارد که اگر راس های
بیرونی آن سه یال همرنگ راس غلط باشند، نمی توان راس نهایی را هم رنگ درست
قرار داد و در غیر این صورت، می توان این کار را کرد. به ازای هر جمله سه
یال بیرونی گجت را به رئوس مربوط به متغیر وصل می کنیم و راس نهایی را به
راس خنثی و غلط وصل می کنیم تا رنگ آن مجبور شود همرنگ راس درست باشد.
</p></li></ul><p>به این ترتیب جوابی وجود دارد اگر و تنها اگر گراف را بتوان با سه رنگ رنگ آمیزی
کرد. تنها نکته ای که باقی می ماند، طراحی گراف گجت است. یک کاندید ممکن برای گراف
گجت، گراف زیر است.
</p><img src="/_static/dot/Gadget.svg"><p>که در آن سه یال بیرونی با رنگ آبی و راس نهایی با رنگ قرمز معلوم شده است. صحت این
گراف گجت را خودتان می توانید بررسی کنید. شاید برای شما سوال شود که این گراف از کجا
ظاهر شد؟ ایده پشت طراحی این گراف این است که هر کدام از مثلث ها مانند یک گیت یای منطقی
عمل می کنند و با ترکیب دو گیت دو ورودی، یک گیت سه ورودی به دست آورده ایم.
</p><p>از فصل های گذشته می دانید که مساله دو رنگ پذیری، بر خلاف مساله سه رنگ پذیری که
np کامل
است، در زمان خطی به کمک الگوریتم
dfs
قابل حل است.
</p><h2>مسیر همیلتونی</h2><p>این مساله را به مساله
sat
کاهش می دهیم. به ازای هر جمله، یک راس و به ازای هر متغیر، یک شکل لوزی مانند قرار
می دهیم.
</p><p>بقیه اثبات در
https://www.geeksforgeeks.org/proof-hamiltonian-path-np-complete/
</p><h2>دور همیلتونی</h2><p>این مساله را به مساله مسیر همیلتونی کاهش می دهیم. یک گراف دلخواه ساده را در نظر
بگیرید مانند
$ G $
سپس به آن یک راس اضافه کنید و آن را به تمام رئوس قبلی متصل کنید. گراف جدید را
$ G^{\prime} $
بنامید. هر مسیر همیلتونی در گراف
$ G $
را می توان با عبور از راس جدید به یک دور همیلتونی در گراف
$ G^{\prime} $
تبدیل کرد و هر دور همیلتونی در گراف
$ G^{\prime} $
با حذف راس جدید به یک مسیر همیلتونی در گراف
$ G $
تبدیل کرد. بنابراین اگر الگوریتمی داشته باشیم که بتوان با آن دور همیلتونی را
تشخیص داد، با اضافه کردن یک راس می توان با آن مسیر همیلتونی را نیز تشخیص داد
و چون مسیر همیلتونی
np کامل
است و دور همیلتونی هم به وضوح جز مسائل
np
است، دور همیلتونی نیز
np کامل
است.
</p><h2>بلند ترین مسیر و دور</h2><p>این مسائل مساله تصمیم نیستند ولی چون تمام مسائل کلاس
np
به آن ها کاهیده می شوند (چون مسیر و دور همیلتونی حالت خاص این دو مساله اند) پس
این مسائل
np سخت
هستند.
</p><h1>چگونه از این کتاب استفاده کنیم؟</h1><p>این کتاب جهت آمادگی برای شرکت در المپیاد کامپیوتر طراحی شده است اما
همه علاقه‌مندان می توانند از آن استفاده کنند.
</p><p>درون کتاب مباحث گراف مربوط به المپیاد کامپیوتر اعم از تعاریف و مباحث تئوری، الگوریتم ها
و داده ساختار ها گنجانده شده است. همراه با هر الگوریتم یا داده ساختار، کد آن به زبان
C++
نیز قرار داده شده است. با توجه به این که در مراحل نهایی المپیاد کامپیوتر شما باید
این زبان را بلد باشید و از آن استفاده کنید، اکیدا توصیه می شود که پیش از شروع
به مطالعه این کتاب، آشنایی مختصری با این زبان داشته باشید که هم بتوانید
از نمونه کد های موجود در کتاب استفاده کنید و هم بتوانید مسائل برنامه نویسی که به صورت
لینک در کتاب قرار داده شده است را حل کنید.
</p><p>سیر کتاب به صورت مقدماتی به پیشرفته چیده شده است و ممکن است که مباحث جلوتر
به مباحث قبل نیاز داشته باشند. بنابراین توصیه می‌شود که کتاب را به ترتیب بخوانید
و خوب است که حتی اگر مبحثی را بلد هستید، نگاهی به درس نامه داشته باشید تا زیر مبحثی
از دست شما در نرود.
</p><h2>مسائل</h2><p>مسائل از اهمیت دو چندانی نسبت به درس نامه قرار دارند. حل مساله ذهن شما را پرورش می‌دهد
و باعث تسلط بیشتر شما می‌شود. مهارت حل مساله چیزی است که از شما در المپیاد خواسته می‌شود
و در زندگی نیز به شما کمک می‌کند. به مسائل مثل یک پازل نگاه کنید و از حل آن ها لذت ببرید.
</p><p>هر جای این کتاب که از شما خواسته می شود که چیزی را اثبات کنید، نشان دهید، تعیین کنید
یا محاسبه کنید، شما باید یک اثبات ریاضی ارائه کنید. در برخی از مسائل شما شهود خوبی
دارید که حکم باید برقرار باشد یا می توانید جواب را با مثال های کوچک حدس بزنید، اما
این کافی نیست و باید برای هر گزاره ای که مطرح می کنید، دلیل بیاورید.
</p><p>بعضی از مسائل در کنار خود علامت کوچکی دارند. این علائم معنای خاصی دارند. منفی (-) به معنای
دستگرمی، علامت تعجب (!) به معنای سوال آموزنده و مثبت (+) به معنای سوال چالشی و بعضا
نیازمند دانش بیشتر می باشد.
</p><h2>رفع اشکال</h2><p>طبیعی است که نتوانید بعضی از مباحث را درک کنید. این مباحث به عنوان دوره های دانشگاهی
تدریس می‌شوند و برای شما به عنوان یک دانش‌آموز ممکن است سخت باشد که از روی کتاب آن‌ها
را یاد بگیرید. این مباحث معروف هستند و نوشته‌ها و فیلم‌های زیادی درون اینترنت
برای یادگیری آن‌ها وجود دارد. هم چنین می توانید سوالات خود را از دوستانتان بپرسید. انجمن
های آنلاین مکان های خوبی برای این کار هستند. برای مثال گروه شاز یک گروه آنلاین
است که می توانید در آن سوال بپرسید و هم سن و سال های خودتان به سوالاتتان پاسخ می دهند.
</p><p>تعاریف گراف بسیار زیاد هستند و ممکن است آن ها را فراموش کنید. هدف این کتاب از آموزش
گراف، به هیچ وجه حفظ تعاریف نیست. هرگاه که تعریفی را فراموش کردید، می توانید از
درس نامه یا از
این صفحه </book/appendix/3>
آن ها را مرور کنید. اگر تعریفی در کتاب هست که در این صفحه نیامده است، آن را
گزارش کنید.
</p><h2>مشارکت و گزارش مشکل</h2><p>این کتاب یک کتاب عمومی است و هر کسی می تواند آزادانه از اینترنت آن را بارگیری
کند یا آن را چاپ کند یا از مطالبش به هر طریقی با رعایت شروط مجوز (اشاره به مشارکت کنندگان
و اشتراک گزاری محصول به دست آمده با همین شرایط یعنی آزادانه برای استفاده
عموم) در آثار دیگر استفاده کند. بنابراین مشارکت در این کتاب کمک به جامعه است. از
کوچکترین مشارکت مانند گزارش یک غلط املایی تا مشارکت های بزرگ مانند نوشتن درس نامه
های ناقص همگی مفید هستند.
</p><p>منبع کتاب در
این مخزن گیت هاب <https://github.com/shaazzz/GTOI>
قرار دارد. برای گزارش مشکلات از
https://github.com/shaazzz/GTOI/issues
استفاده کنید. برای بهبود متن یا افزودن پاسخ سوالات از روال عادی مشارکت
در پروژه های گیت هاب یعنی فورک کردن مخزن و ارائه
pull request
استفاده کنید. اگر مایلید که قسمتی از درس نامه را کامل کنید، ابتدا آن را
در قسمت ایشو ها مطرح کنید که از دوباره کاری جلوگیری شود و زحمات شما
یا دیگران به هدر نرود.
</p><h2>پیشنیاز ها</h2><p>زبان برنامه نویسی سی پلاس پلاس همان طور که در بالا به آن اشاره شد و هم چنین تحلیل
پیچیدگی الگوریتم ها اگر این کتاب را برای المپیاد کامپیوتر می خوانید یا به مباحث
عملی و پیاده سازی گراف علاقه دارید. در ضمیمه بعدی
الگوریتم ها و تحلیل پیچیدگی زمانی و حافظه ای آن ها را بررسی می کنیم
و با علامت هایی همچون
$ O, \Omega, \theta $
که به وفور در کتاب استفاده می‌شوند آشنا می‌شوید. اگر با این علائم آشنا نیستید
حتما ضمیمه بعدی را بخوانید.
</p><p>اثبات ریاضی، نتیجه گیری و ابزار های نتیجه گیری مانند برهان خلف
نیز برای اثبات مسائل لازم است. دانستن استقرای ریاضی
و تسلط به آن نیز به شما در فهم بهتر و حل مسائل بیشتر کمک خواهد کرد.</p><h1>آشنایی با الگوریتم ها و پیچیدگی</h1><p>امروزه کامپیوتر ها بسیار سریع هستند، اما هیچ کامپیوتری دستورات را در لحظه اجرا نمی کند.
مقدار بسیار کوچکی از زمان طول می کشد که کامپیوتر یک دستور را اجرا کند. برای مثال کامپیوتر
های امروز در فرکانس حدود سه گیگاهرتز کار می کنند که یعنی یک زیر دستور العمل را در زمان
حدود سه دهم نانو ثانیه انجام می دهند که این یعنی هر دستور العمل در حدود چند نانو ثانیه
زمان می برد.
</p><p>با این حال کار نوشتن برنامه ای که ساعت ها، یا حتی سال ها زمان ببرد، اصلا کار سختی
نیست. حتی ممکن است خودتان به آن برخورده باشید. مثلا در پردازش فیلم یا شبیه سازی های
فیزیکی ممکن است ساعت ها کامپیوتر خود را روشن گذاشته باشید تا پاسخ را دریافت کنید.
</p><p>به همین دلیل در مسابقات برنامه نویسی محدودیت زمانی برای اجرای برنامه شما وجود دارد
و برنامه شما باید در زمانی حدود ۱ تا ۵ ثانیه
(بسته به مساله)
اجرا شود. به همین دلیل در هنگام طراحی الگوریتم ها محاسبه می کنیم که آیا راه ما
با توجه به شرایط ورودی در زمان خواسته شده اجرا می شود یا خیر و اگر اجرا می شد شروع
به پیاده سازی آن می کنیم.
</p><h2>تحلیل پیچیدگی</h2><p>سخت است که زمان اجرای یک برنامه را به طور دقیق حساب کنیم. برای مثال دستور
</p><pre dir="ltr">cpp
a[x] += a[y];</pre><p>را در نظر بگیرید. این دستور چند عمل در سی پی یو است؟ پاسخ به این سوال بسیار سخت و نیازمند
شناخت دقیق کامپایلر و سی پی یو است. حتی ممکن است پاسخ این سوال بسته به نوع سی پی یو یا
کامپایلر یا درجه بهینه سازی کامپایلر یا مکان قرار گیری این دستور در کد فرق کند. برای مثال
خواندن y از حافظه، جمع x با a و خواندن خانه به دست آمده از حافظه یا جمع
مقدار a[x] و a[y] می تواند یک یا چند دستور العمل در سی پی یو باشد.
</p><p>حتی اگر می دانستیم که برنامه ما از چند دستور العمل تشکیل شده، باز برای تخمین زمان اجرای
برنامه کافی نبود. برای مثال دستور باقیمانده و دستور شیفت بیتی هر دو یک دستور العمل
هستند اما باقیمانده بسیار بیشتر از شیفت بیتی طول می کشد.
</p><p>بنابراین از محاسبه زمان دقیق اجرای کد صرف نظر می کنیم و تنها به این اکتفا می کنیم که
دستورات سی پی یو مانند خواندن از آرایه یا جمع دو عدد، مقدار ثابتی از زمان طول می کشند.
به همین صورت، دقت اندازه گیری ما در حد یک ضریب پایین می آید. برای مثال این کد را در نظر بگیرید
</p><pre dir="ltr">cpp
for (int i = 0; i &lt; n; i++) {
  for (int j = 0; j &lt; n; j++) {
    swap(a[i],a[j]);
  }
}</pre><p>ما نمی دانیم که تابع سوپ یا عمل مقایسه یا عمل پلاس پلاس هر کدام چند واحد زمانی طول می کشند
اما می دانیم که هر کدام مقدار ثابتی از زمان طول می کشند. پس می توان گفت که زمان اجرای این کد
$ kn^2 $
است که k یک ضریب ثابت با واحد ثانیه است.
در عموم موارد مقدار k برای ما اهمیتی ندارد و از آن چشم پوشی می کنیم.
</p><h3>نماد ها</h3><p>چون می توانیم از ضریب چشم پوشی کنیم، تعریف نماد های زیر خالی از لطف نیست:
</p><ul><li><p>نماد
$ f(n) = O(g(n)) $:
این نماد به این این معنی است که ضریبی مانند k وجود دارد به طوری که
$ f(n) \le kg(n) $
به ازای تمامی n های بزرگ برقرار باشد.
این نماد به صورت اِف اِن از او یِ جیِ اِن است خوانده می شود.
</p></li><li><p>نماد
$ f(n) = \Omega (g(n)) $:
اگر و تنها اگر
$ g(n) = O(f(n)) $
بر قرار باشد برقرار است و می خوانیم
اِف اِن از اُمِگا یِ جیِ اِن است
</p></li><li><p>نماد
$ f(n) = \theta (g(n)) $:
اگر و تنها اگر
$ f(n) = O(g(n)) $ و $ f(n) = \Omega (g(n)) $
بر قرار باشد برقرار است و می خوانیم
اِف اِن از تِتا یِ جیِ اِن است
</p></li></ul><p>به این نماد ها می توانید به چشم علامت های کوچکتر مساوی، بزرگتر مساوی و مساوی نگاه کنید.
مثال های زیر می تواند به درک بهتر این علامت ها کمک کند.
</p>$$ 1000n = O(0.00001n) $$$$ 1000n = \Omega(0.00001n) $$$$ 1000n = \theta(0.00001n) $$$$ 1000n^2 = O(n^5) $$$$ 1000n^2 \ne \Omega(n^5) $$$$ n^5 = O(2^n) $$$$ 2*n^{10}+100*n^7+20*n^2 = \theta(n^{10}) $$<h2>دسته بندی پیچیدگی های مهم</h2><p>در مسائلی که ما بررسی می‌کنیم پیچیدگی هایی مرتبا تکرار می‌شوند که آن ها را در زیر
بررسی می‌کنیم.
</p><h3>پیچیدگی خطی</h3><p>به الگوریتمی که زمان اجرایش ضریبی از طول ورودی باشد، الگوریتم خطی می گوییم. اگر طول
ورودی n باشد زمان اجرای الگوریتم
.. math:: O(n)
است. در حالت عادی نمی توان الگوریتمی بهتر از الگوریتم خطی پیدا کرد زیرا خود دریافت
ورودی ضریبی از 
n
طول می‌کشد و حتی اگر زمان ورودی گرفتن را در نظر نگیریم چون در زمان ثابت می توان
روی تعداد ثابتی از متغیر ها و خانه های حافظه انجام داد پس برای این که تمام ورودی
را روی خروجی اثر دهیم باید ضریبی از طول ورودی را صرف کنیم.
</p><h3>تابع لگاریتم</h3><p>تابع لگاریتم تابعی است که در تحلیل پیچیدگی الگوریتم ها بسیار ظاهر می‌شود.
این تابع به صورت معکوس تابع توان ۲ تعریف می‌شود. یعنی:
$ 2^{lg(n)} = n $
به سادگی می توان صحت گزاره های زیر را بررسی کرد.
</p>$$ lg(a*b) = lg(a) + lg(b) $$$$ lg(a^b) = b * lg(a) $$$$ a^{\frac{lg(n)}{lg(a)}} = n $$$$ lg(n)^k = O(n) $$<h3>پیچدگی شبه خطی</h3><p>به الگوریتمی که زمان اجرایش از
$ O(n*lg(n)^k) $
باشد که k عددی ثابت است، این الگوریتم زمان اجرای شبه خطی دارد.
</p><h3>پیچیدگی چندجمله ای</h3><p>اگر زمان اجرای الگوریتم از
$ O(n^k) $
باشد و k عددی ثابت باشد می گوییم زمان اجرای الگوریتم چند جمله ای است.
</p><h3>پیچیدگی نمایی</h3><p>اگر زمان اجرای الگوریتم از
$ O(c^n) $
باشد و c عددی ثابت باشد می گوییم زمان اجرای الگوریتم نمایی است.
الگوریتم های نمایی عموما مناسب نیستند و برای
n
های بزرگ (مثلا ۱۰۰۰) می توانند به اندازه عمر کهکشان طول بشکند :))</p><h1>برگه تقلب (Cheat sheet)</h1><p>هدف این کتاب از آموزش گراف، حفظ کردن تعاریف نیست. هر وقت که تعریفی را یادتان رفت می توانید
به این صفحه مراجعه کنید  و این کار اصلا معنی تقلب ندارد (عنوان صفحه صرفا یک اصطلاح است)
</p><p>دقت کنید که این صفحه به منظور آموزش نیست و مطالب به طوری خلاصه شده اند که تنها کسی
که قبلا با آن ها آشنا بوده می تواند آن را به خاطر بیاورد. برای آموزش، از درس نامه
استفاده کنید
</p><h2>اعداد</h2><ul><li><p>عدد استقلال یا بزرگترین مجموعه مستقل (آلفا $ \alpha $ ):
بیشترین تعداد راسی از گراف که به هم هیچ یالی ندارند.
</p></li><li><p>بزرگ ترین تطابق (آلفا پریم $ \alpha^{\prime} $ ):
بیشترین تعداد یال از گراف با راس های مجزا.
</p></li><li><p>کوچک ترین پوشش راسی (بتا $ \beta $ ):
کمترین تعداد راسی از گراف که هر یالی حداقل یک سرش در این راس ها باشد.
</p></li><li><p>کوچک ترین پوشش یالی (بتا پریم $ \beta^{\prime} $ ):
کمترین تعداد یال از گراف که هر راسی سر حداقل یکی از این یال ها باشد.
</p></li><li><p>عدد رنگی (خی $ \chi $ ):
کم ترین رنگی که می توان با آن رئوس گراف را رنگ آمیزی کرد به طوری که بین
هیچ دو راس هم رنگی یال نباشد.
</p></li><li><p>عدد رنگی یالی (خی پریم $ \chi^{\prime} $ ):
کم ترین رنگی که می توان با آن یال های گراف را رنگ آمیزی کرد به طوری که
هیچ دو یال هم رنگی سر مشترک نداشته باشند.
</p></li><li><p>عدد همبندی (کاپا $ \kappa $)
حداقل تعداد رئوسی از گراف که با حذفشان گراف ناهمبند شود.
</p></li><li><p>عدد همبندی یالی (کاپا پریم $ \kappa^{\prime} $)
حداقل تعداد یال هایی از گراف که با حذفشان گراف ناهمبند شود.
</p></li><li><p>عدد خوشه ای (امگا $ \omega $ ):
بیشترین تعداد راسی از گراف که دو به دو به هم یال دارند.
</p></li><li><p>کمترین درجه (دلتای کوچک $ \delta $ ):
تعداد یال های راسی که کمترین یال را دارد.
</p></li><li><p>بیشترین درجه (دلتای بزرگ $ \Delta $ ):
تعداد یال های راسی که بیشترین یال را دارد.
</p></li></ul>
  </body>
</html>