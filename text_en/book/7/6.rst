Deriving Recurrence Relations Using Graphs and Matrices
=================================================

The problem of finding the number of walks of length :math:`k` in a graph is a problem that many counting problems can be considered a special case of. Since the computation time for this number is proportional to the logarithm of :math:`k`, it often performs faster than other algorithms. Instead of other methods, one can use matrix exponentiation of this graph.

In this section, we consider families of recurrence relations that appear in theoretical problems as well as dynamic programming. For these, we construct graphs such that the :math:`n`-th term of the desired recurrence relation is equal to the number of walks of length :math:`n` in a graph with a fixed number of vertices. Thus, an algorithm with :math:`O(lg(n))` complexity is obtained, which computes the desired recurrence sequence.

Fibonacci
----------

Consider a two-vertex graph where the two vertices are connected by an edge, and the first vertex has a loop to itself. We want to calculate the number of walks of length :math:`n` from vertex one to itself, and we call this value :math:`f_n`. We categorize based on the first edge of the walk. If the first edge of the walk is the loop, then by definition, we can continue in :math:`f_{n-1}` ways. However, if in the first step we went to the other vertex, the second edge of the walk is uniquely determined, and we are forced to return to the first vertex. Subsequently, we can continue in :math:`f_{n-2}` ways. Thus, we have:

.. math:: f_n = f_{n-1} + f_{n-2}

The number of 0-length and 1-length walks from vertex one to itself is 1, and therefore the sequence :math:`f` is the well-known Fibonacci sequence. So, if we want to calculate the :math:`n`-th Fibonacci number, we can raise the adjacency matrix of this graph to the power of :math:`n`. That is, the (1,1) entry of the matrix :math:`\begin{bmatrix}1 & 1\\1 & 0\end{bmatrix} ^ n` is the :math:`n`-th Fibonacci number.

Transformations
----------
It is not necessary to construct a graph from scratch for every recurrence relation; instead, we can find general transformations and modify the graph to encompass a specific pattern of functions. For example, the partial sum transformation is presented below.

Suppose we have a graph where the number of walks of length :math:`n` from vertex :math:`i` to :math:`j` is :math:`f_n`. We define the sequence :math:`g` as follows:

.. math:: g_0 = 0
.. math:: g_n = g_{n-1} + f_{n-1}

We want to modify the graph so that the above sequence can be computed with it. We add a new vertex, say :math:`k`, to the graph, add an edge from vertex :math:`j` to :math:`k`, and also place a loop on the new vertex. The number of walks from vertex :math:`i` to :math:`j` does not change and remains the same as before. We claim that the number of walks of length :math:`n` from :math:`i` to :math:`k` is the desired value. First, it is clear that the base case holds, and there are no 0-length walks from :math:`i` to :math:`k`. To prove the second part, we categorize based on the last edge of the walk. Either the last edge of the walk is the loop, in which case the beginning of the walk has :math:`g_{n-1}` states, or it is an edge that entered from vertex :math:`j` to :math:`k`, in which case, by assumption, the beginning of the walk can have :math:`f_{n-1}` states.