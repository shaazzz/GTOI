تطابق در گراف دوبخشی
===============================

In the previous section, we stated that the necessary and sufficient condition for having a maximum matching is the absence of an augmenting path. This condition is easily verifiable in bipartite graphs (why?).

Consequently, studying matchings in bipartite graphs (as a special case of graphs) is beneficial due to their widespread applications.

الگوریتم
----------

In this algorithm, we start with an empty matching and enlarge the matching as long as an augmenting path exists in the graph. It is easily observable that in this case, the maximality of our final matching is self-evident. To find an augmenting path, we proceed as follows:

Suppose our graph consists of two partitions with :math:`n_1` vertices and :math:`n_2` vertices. For each :math:`v = 1 ... n_1`, we search for an augmenting path in our current graph. At the :math:`i`-th step, we can claim that the matching between the :math:`i` vertices of the first partition and the remaining vertices of the second partition is maximum. Consequently, our final matching will also be maximum. Its implementation is as follows:

.. code-block:: cpp

  const int N = 2e3 + 5;
  int n1, n2, m, k, match[N];
  vector <int> adj[N];
  bool mark[N];

  bool try_kuhn(int u){
      mark[u] = true;
      for(auto v: adj[u])
          if(match[v] == -1 || (!mark[match[v]] && try_kuhn(match[v]))){
              match[v] = u;
              return true;
          }
      return false;
  }

  void read_input(){
      cin >> n1 >> n2 >> m;
      for(int i = 0; i < m; i++){
          int u, v;
          cin >> u >> v;
          adj[--u].push_back(--v);
      }
  }

  void calc(){
      memset(match, -1, sizeof match);
      for(int u = 0; u < n1; u++){
          memset(mark, false, sizeof mark);
          k += try_kuhn(u);
      }
  }

  void write_output(){
      cout << k << endl;
      for(int u = 0; u < n2; u++)
          if (match[u] != -1)
              cout << match[u] + 1 << ' ' << u + 1 << endl;
  }

  int main() {
      read_input();
      calc();
      write_output();
      return 0;
  }

In the mentioned algorithm, for each vertex in the first partition, :math:`O(m)` steps are performed, so its time complexity is :math:`O(nm)`. Of course, there is another implementation of this very algorithm whose speed is at least twice as fast as the algorithm above (why?):

.. code-block:: cpp

  const int N = 2e3 + 5;
  int n1, n2, m, k, match[N];
  vector <int> adj[N];
  bool mark[N];

  bool try_kuhn(int u){
      mark[u] = true;
      for(auto v: adj[u])
          if (match[v] == -1 || (!mark[match[v]] && try_kuhn(match[v]))) {
              match[v] = u;
              return true;
          }
      return false;
  }

  void read_input(){
      cin >> n1 >> n2 >> m;
      for(int i = 0; i < m; i++){
          int u, v;
          cin >> u >> v;
          adj[--u].push_back(--v);
      }
  }

  void calc(){
      memset(match, -1, sizeof match);
      while(true){
          bool flag = false;
          memset(mark, false, sizeof mark);
          for(int u = 0; u < n1; u++)
              if (!mark[u])
                  k += try_kuhn(u);
          if (!flag)
              break;
      }
  }

  void write_output(){
      cout << k << endl;
      for (int u = 0; u < n2; u++)
          if (match[u] != -1)
              cout << match[u] + 1 << ' ' << u + 1 << endl;
  }

  int main(){
      read_input();
      calc();
      write_output();
      return 0;
  }

قضیه هال
-------------

This theorem states another necessary and sufficient condition for the maximality of a matching in a bipartite graph, first proposed by Philip Hall and known as the Marriage Theorem. This theorem is as follows:

Let :math:`X` be a set of vertices in the first partition of a bipartite graph. The set :math:`X` admits a matching that covers all its vertices if and only if for every subset :math:`S \subseteq X`, we have :math:`|S| \leq |N(S)|`, where :math:`N(S)` is the set of neighbors of :math:`S` in the other partition.

The necessity of the above condition is trivial (otherwise, the number of adjacent vertices to a set would not be sufficient to match them). To prove sufficiency, we use proof by contradiction and assume a graph with such a property exists but does not admit a matching that covers all vertices in :math:`X`;

.. figure:: /_static/marriage_theorem.jpeg
   :width: 50%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد

Consider a maximum matching and an arbitrary unsaturated vertex :math:`u` (it must exist!). Since this vertex is not matched, we consider the matched vertex of an arbitrary neighbor of it. These two vertices, according to the problem assumption, have another adjacent vertex which is either unmatched (in which case we have an augmenting path) or matched, in which case we add its matched vertex to these two vertices. We continue this process as far as possible, and since the number of neighbors of any subset of :math:`X` is at least its own size, we eventually reach a stage where our current alternating path has an adjacent vertex that is unsaturated, in which case we have an augmenting path, which contradicts the maximality of our matching.

تطابق در گراف دوبخشی k منتظم
-----------------------------

According to Hall's theorem, it can be proven that a k-regular bipartite graph has a perfect matching. To prove this, it is sufficient to show that Hall's condition holds for it;

Consider a set of vertices :math:`S` from the first partition of the graph and name their neighbors in the second partition :math:`T`. We prove that :math:`|S| \leq |T|`. We know that the sum of degrees of vertices in :math:`S` is :math:`|S| \times k`. All these edges must connect to vertices in :math:`T`. Since each vertex in :math:`T` has a degree of at most :math:`k`, the total number of edges incident to vertices in :math:`T` is at most :math:`|T| \times k`. Therefore, the number of edges between :math:`S` and :math:`T` is :math:`|S| \times k`. Also, this number of edges must be less than or equal to the maximum possible edges :math:`|T| \times k`. So, :math:`|S| \times k \leq |T| \times k`. From this, we can conclude :math:`|T| \geq |S|`.

.. figure:: /_static/dot/K_R_Bipartite_Subgraph.svg
   :width: 30%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد

Thus, Hall's condition holds in our graph, and a perfect matching is certainly found in our graph.

تعمیم قضیه هال
--------------

We have a bipartite graph :math:`G` and want to remove some of its edges such that the degree of each vertex :math:`u` in the first partition becomes :math:`a_u`, and the degree of each vertex in the second partition is at most one. To solve this problem, we construct a graph :math:`G'` such that a matching covering all vertices of its first partition exists in :math:`G'` if and only if such a set of edges exists in graph :math:`G`;

We construct graph :math:`G'` as follows: for each vertex :math:`u` in the first partition of :math:`G`, we create a set of :math:`a_u` vertices (which are copies of vertex :math:`u`). For every edge :math:`(u, v)` in :math:`G`, we connect all vertices in the set corresponding to :math:`u` to vertex :math:`v`. The resulting graph is bipartite (why?). If Hall's condition holds in :math:`G'`, meaning it has a matching covering all vertices of its first partition, then for each matched edge between a copy of vertex :math:`u` and a vertex :math:`v` in :math:`G'`, we select the corresponding edge :math:`(u, v)` in graph :math:`G`. It is clear that in this case, we obtain our desired set of edges. If :math:`G'` does not have such a matching, similarly, it can be concluded that such a set also does not exist in graph :math:`G` (we operate in reverse).

Consider the process of checking Hall's condition in graph :math:`G'`. For every subset :math:`S` from the first partition of graph :math:`G'` and its set of neighbors :math:`T`, we check if :math:`|S| \leq |T|` holds. Now, it can be noted that for any vertex :math:`u` in :math:`G`, if some copies of :math:`u` are included in :math:`S` but not all of them, one can add all copies to set :math:`S`. In this case, :math:`T` will not change, and only :math:`S` will increase. Therefore, we only need to check subsets :math:`S` where, for each original vertex :math:`u`, either all copies of :math:`u` are included or none are.

With a little thought, we conclude that based on the above, we can find this necessary and sufficient condition on graph :math:`G`: :math:`\forall_{S} \sum\limits_{i \in S} a_i \leq |T|`

where :math:`S` is any subset of vertices from the first partition of the graph, and :math:`T` is the union of neighbors of :math:`S`.