Poset
==========

Definition
---------

A directed graph with the following property is called a Poset (Partially ordered set):

- If :math:`ab` and :math:`bc` are edges of this graph, then :math:`ac` is also an edge of this graph.

Since many mathematical concepts can be transformed into posets, studying them is beneficial.

First Problem
~~~~~~~~~~~~~~

Suppose we have a set of natural numbers, say :math:`A`, and we want to find its largest subset, say :math:`B`, such that for any two members of :math:`B`, one divides the other.

We can model this problem as a graph. For each member of :math:`A`, place a vertex in the graph. For any two vertices :math:`x,y` where :math:`x|y`, add an edge from :math:`x` to :math:`y`. Now, the problem is equivalent to finding the longest path in this graph!

Chain and Anti-chain
~~~~~~~~~~~~~~~~~~

A sequence of distinct vertices such as :math:`u_1,...,u_k` for which there is an edge from :math:`u_i` to :math:`u_j` for every :math:`i<j` is called a chain. Note that due to the poset property, it is sufficient for :math:`u_1, ... u_k` to be a path.

A subset of vertices where no two vertices are connected by an edge is called an anti-chain.

Next, we will examine partitioning a graph into chains or anti-chains (partitioning the graph's vertices is intended).

Note that these definitions are used only in posets.

Maximum Chain = Minimum Partition into Anti-chains
-------------------------------------

Let the size of the maximum chain be :math:`L`. Consider a maximum chain, say :math:`A`.

Any anti-chain can contain at most one vertex from :math:`A`. Therefore, the minimum partition into anti-chains is at least :math:`L`. Now we prove that a case of equality also exists.

To each vertex :math:`u`, we assign a number :math:`a_u` which is equal to the size of the longest chain ending at :math:`u`. Now you can see that if :math:`a_i = a_j` holds, it's impossible for an edge to exist between :math:`i,j`. For example, if there were an edge from :math:`i` to :math:`j`, then :math:`a_j \geq a_i+1`.

For each vertex :math:`u`, we call :math:`a_u` the color of vertex :math:`u`. According to the proof above, vertices with the same color form an anti-chain. Also, the number of colors is equal to :math:`L` (Why?). Thus, we were able to partition the graph into :math:`L` anti-chains.

The above theorem is known as Mirsky's Theorem and was proposed in 1971. It is interesting to note that this theorem was already known in 1940 by Gallai, Dilworth, Fulkerson, and many others, and their only reason for not publishing it was considering the theorem to be trivial!

Maximum Anti-chain = Minimum Partition into Chains
-------------------------------------

As before, one can first conclude that the minimum partition into chains is at least the size of the maximum anti-chain (because each chain can use at most one vertex from the anti-chain). Now we want to provide an argument for equality.

We discussed the problem of partitioning graph vertices into the minimum number of paths in Section 4. It was sufficient to convert the graph into a bipartite form and find a maximum matching. Now we know that in posets, every chain is equivalent to a path. Therefore, the problem of minimum partition into chains is solved by finding the minimum partition of vertices into paths.

Semi-augmenting Path
~~~~~~~~~~~~~~~~~~~~~~~~~

So now, suppose our poset is a directed graph named :math:`P`. Call its equivalent bipartite graph :math:`G`. Consider a minimum partition into paths in :math:`P`. Let the directed edges present in our paths be the set :math:`M`. We know that the edges in :math:`M` correspond to the edges of a maximum matching in :math:`G`. The necessary and sufficient condition for a matching to be maximum was the absence of an augmenting path. We examine what an equivalent of an augmenting path in our directed graph would look like. A free vertex in the first part of :math:`G` corresponds to a vertex in :math:`P` that is the end of a path. A free vertex in the second part of :math:`G` corresponds to a vertex in :math:`P` that is the start of a path.

So now, we want to understand the equivalent of an augmenting path in :math:`G` that starts in the first part and ends in the second part, within graph :math:`P`. We define a **semi-augmenting path** in :math:`P` as follows:

A sequence of vertices :math:`u_1,u_2,...,u_{2k+1}` such that :math:`u_1` is the start and :math:`u_{2k+1}` is the end of a chosen path in the minimum partition. Also, for :math:`u_{2i-1},u_{2i}` in :math:`P`, the edge :math:`u_{2i-1}u_{2i}` must exist and not be a member of :math:`M`, and for :math:`u_{2i},u_{2i+1}`, the edge :math:`u_{2i+1}u_{2i}` must be in :math:`M`! (Pay attention to the change in direction).

So now we can assume that we have partitioned the vertices of :math:`P` into the minimum number of paths such that no semi-augmenting path exists in :math:`P`.

Algorithm
~~~~~~~~~~~~~~~~~~~~~~

Our goal now is to select exactly one vertex from each chain such that the selected vertices form an anti-chain. In this case, we can achieve equality.

Consider the following algorithm:

- Consider the first vertices of the paths. If there are no edges between them, simply select them. Otherwise, there is an edge like :math:`uv` where :math:`u` and :math:`v` are both the first vertices of two paths in our partition.
- Now we must remove vertex :math:`u`. Because, given that :math:`u` has an edge to :math:`v` and :math:`v` is the first vertex of a path, by the poset property, it can be concluded that :math:`u` has an edge to all vertices of the path starting with :math:`v`. Therefore, if we select :math:`u` for the anti-chain, we cannot select any vertex from the path starting with :math:`v`. This means we cannot achieve our goal of selecting one vertex from each path. So, remove :math:`u`.

Continue this process until there are no edges between the first vertices of the paths (after removals), and we find an anti-chain of size equal to the number of paths. The only scenario that would hinder us is if a path is completely removed (in which case the anti-chain would not be of size equal to the initial number of paths).

No Path is Completely Removed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So we prove that none of the paths are completely removed during the algorithm. The idea of the proof is to assume, by contradiction, that a path is completely removed and then find a semi-augmenting path in the initial graph, which would contradict the minimality of our partition.

For any vertex :math:`a`, we call a vertex :math:`b` the father of vertex :math:`a` if :math:`a` was removed in the algorithm due to the edge :math:`ab`. That is, at some step of the algorithm, both :math:`a,b` are the first vertices of two paths, and the edge :math:`ab` is a member of :math:`P`, and according to the algorithm above, we remove vertex :math:`a`.

For any vertex :math:`a`, consider the path it belongs to, and call the vertex immediately preceding :math:`a` in that path (e.g., :math:`b`) the predecessor in path of :math:`a`. (Meaning :math:`ba` is an edge member of :math:`M`).

Note that for any vertex :math:`a`, the time of :math:`a`'s removal is after the removal time of the predecessor in path of :math:`a`'s father. This is because when :math:`a` is removed by its father, :math:`a` must be the first vertex of a path. This implies that the predecessor in path of the father (if it exists) must have been removed earlier.

Now, suppose at some stage, vertex :math:`a` is removed, where :math:`a` is the end of a path in our partition. Start from vertex :math:`a` and place a token on :math:`a`. At each step, if the token is on :math:`u`, first move the token to the father of :math:`u`. If the father of :math:`u` is the first vertex of one of the paths, then we have found our semi-augmenting path. Otherwise, move the token to the predecessor in path of the father of :math:`u`. Note two points:

- The process terminates because, as we stated, after each step, the token is placed on a vertex whose removal time in the algorithm is earlier.
- At each step, the vertex on which the token is placed has a father. This is because, in our algorithm, this vertex is removed at some point (since its removal time is earlier than :math:`a`'s, and we established that :math:`a` is removed).

Thus, we were able to find a semi-augmenting path. As we said, the resulting contradiction shows that no path is completely removed!