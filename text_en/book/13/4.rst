Applications
==============

Directed and Bipartite Graphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this section, we will see that the two concepts of bipartite and directed graphs are interconvertible, and depending on which one gives us better intuition for solving a problem, we can use one of them.

Consider the adjacency matrix of a bipartite graph and a directed graph. Both are :math:`n \times n` matrices with 0s and 1s. (The matrix is not necessarily symmetric).

Now, to convert a directed graph to a bipartite graph, it is sufficient to consider the adjacency matrix of the directed graph, which we call :math:`M`, and draw a bipartite graph whose adjacency matrix is :math:`M`. The conversion from a bipartite graph to a directed graph is similar. If we want to look at it more intuitively, each edge :math:`ab` in a directed graph is equivalent to an edge between vertex :math:`a` from the left partition and vertex :math:`b` from the right partition. That is, the left partition represents the outputs and the right partition represents the inputs.

Now consider a matching in a bipartite graph. If we convert the bipartite graph to a directed graph, what will our matching turn into?

A number of directed cycles and paths! Because in a bipartite graph, at most one incident edge is chosen for each vertex, this means that in the directed graph, each vertex has at most one incoming edge and at most one outgoing edge.

Partitioning a DAG into Paths
~~~~~~~~~~~~~~~~~~~~~~

We have a directed acyclic graph (DAG). What is the minimum :math:`x` such that this graph can be partitioned into :math:`x` directed paths?

Note that if the number of edges in these optimal paths is :math:`y`, then :math:`x+y=n`. So, to minimize :math:`x`, it is sufficient to maximize :math:`y`. Convert the directed graph to a bipartite graph. Now, :math:`y` is equal to the maximum matching of this bipartite graph. (Why?)

Partitioning a Directed Graph into Cycles
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose in a directed graph we want to find a method to partition this graph into cycles.

First, convert the graph into bipartite form. We said that a matching means a partition into cycles and paths. You can easily conclude that a perfect matching gives us a partition into cycles. So, it is sufficient to find a perfect matching in the bipartite graph.

2k-Regular Graphs and Partitioning into Cycles
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This time, our topic is an undirected graph. Similar to the problem above, imagine we have an **undirected** graph like :math:`G` and we know it is :math:`2k`-regular. We want to **prove** that there is a method to partition this graph into cycles.

The first idea is that for each edge :math:`ab` in :math:`G`, we put two edges :math:`ab, ba` in a directed graph. Then, similar to the problem above, first convert the directed graph into bipartite form and then try to find a perfect matching.

The problem that arises with this approach is that this partition might create cycles of length 2 (which are just single edges), which is not desirable for us.

To avoid this problem, consider an Eulerian tour of the graph and orient each edge in the direction that the Eulerian tour traverses it. (If the graph has multiple connected components, we do this for each component).
The resulting graph is now a directed graph where the in-degree and out-degree of each vertex are equal to :math:`k`. Now, if we convert this graph into bipartite form, each vertex will have degree :math:`k`.

According to a theorem we proved earlier, a :math:`k`-regular bipartite graph has a perfect matching, so there is also a method to partition this directed graph into cycles.

Tournament Degree Sequence and Matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose a sequence :math:`d_1,d_2,...d_n` is given, and we know that :math:`\sum\limits_{i=1}^{n} d_i = {n \choose 2}`. We want to check if a tournament exists where the out-degree of each vertex :math:`u` is equal to :math:`d_u`?

Construct a bipartite graph. The right partition has :math:`n` vertices, and the left partition has :math:`{n \choose 2}` vertices, each representing an edge from the tournament. Connect the vertex representing edge :math:`ab` to vertex :math:`a` and vertex :math:`b` from the right partition. Now, select a subset of edges such that the degree of each vertex in the left partition is 1, and the degree of vertex :math:`u` from the right partition is :math:`d_u`. (Similar to the matching we discussed in Hall's generalization section).

Intuitively, each vertex in the left partition, like the one representing :math:`ab`, must choose one of the two vertices :math:`a` or :math:`b`. If it chooses :math:`a`, it means the edge between vertices :math:`a,b` in the tournament is directed from :math:`a` to :math:`b`, and vice versa. Also, the out-degree of vertex :math:`u` in the tournament is supposed to be :math:`d_u`, so each vertex :math:`u` from the right partition must have been chosen by exactly :math:`d_u` vertices from the left partition!

So, according to what we discussed in Hall's generalization section, the necessary and sufficient condition for the existence of such a tournament is that for any subset :math:`S` of vertices in the left partition, if the union of its neighbors in the right partition is :math:`P`, then:
:math:`|S| \leq \sum\limits_{u \in P} d_u`
Since we can increase the left side to :math:`{|P| \choose 2}` without changing the right side of the inequality (why?), we can also write the condition as:

:math:`\forall_{P \subseteq \{1,2,...,n\}} {|P| \choose 2} \leq \sum\limits_{u \in P} d_u`

Now, since only the number of elements in the set matters on the left side of the inequality, not the set itself, it is sufficient to check the condition for the smallest :math:`d_u`s. In other words, assuming :math:`d_1 \leq d_2 \leq ... d_n`, the following condition is necessary and sufficient:

:math:`\forall_{1 \leq k \leq n} {k \choose 2} \leq \sum\limits_{i=1}^{k} d_i`

Fixed Vertices in Bipartite Matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have a bipartite graph. For a matching :math:`M`, any vertex :math:`u` that is incident to one of the edges of :math:`M` is said to be *present* in :math:`M`. Now, for all vertices :math:`u`, you must state whether there exists a maximum matching where :math:`u` is **not present**?

First, consider an arbitrary maximum matching, say :math:`M`. Now, for all vertices not present in :math:`M`, we know the answer. And we want to find the answer for each vertex present in :math:`M`, say :math:`u`. Suppose there exists a maximum matching :math:`M^{\prime}` such that :math:`u` is not present in it. Now, suppose the symmetric difference of :math:`M` and :math:`M^{\prime}` is :math:`H`. In this case, :math:`H` must consist of a number of even cycles and paths, and :math:`u` must be the endpoint of one of these even paths (why?)!

So we conclude that for any vertex :math:`u` that is part of matching :math:`M`, we can find a matching where :math:`u` is not present if and only if there exists an alternating path from a free vertex (a vertex not in matching :math:`M`) to :math:`u`. Note that since this augmented path is not an augmenting path, both ends of the path are in the same partition of our bipartite graph.

Up to this point, we haven't used the bipartiteness of the graph (all stated propositions hold for any graph). But now, to find a maximum matching and the vertices that start an alternating path, we must use the bipartiteness of the graph.

First, find the maximum matching :math:`M` using the algorithm presented in Section 12.2.

Now, suppose the two partitions of the graph are :math:`X` and :math:`Y`, and we want to solve the problem for partition :math:`X`. We orient the edges of the graph such that edges belonging to :math:`M` are directed from :math:`Y` to :math:`X`, and edges not belonging to :math:`M` are directed from :math:`X` to :math:`Y`. You can see that any alternating path starting from a vertex in :math:`X` is actually equivalent to a path in our directed graph that must start from one of the free vertices in :math:`X`.

So, it is sufficient to orient the graph as described and then run a DFS algorithm from each free vertex in :math:`X` and check which vertices are reached. Finally, all vertices in :math:`X` that we could reach are part of an alternating path. As we said, this means that for each of those vertices, there exists a maximum matching in which that vertex is not present.

Similarly, we can solve the problem for partition :math:`Y`.

Finding a Minimum Vertex Cover in a Bipartite Graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Section 12.3, we understood that in a bipartite graph, the size of a minimum vertex cover is equal to the size of a maximum matching. In this section, we learn how to find a minimum vertex cover given a maximum matching.

First, consider the edges of a maximum matching and call it :math:`M`. Since for each edge of the matching, one of its two endpoints must be included in the vertex cover, exactly one of its two endpoints is included in the minimum vertex cover (why?). So, for each edge in :math:`M`, we just need to decide whether to put the vertex from the first partition of the graph into the vertex cover or the vertex from the second partition.

Name the two partitions of the graph :math:`X` and :math:`Y`. Let :math:`MX` be the set of edges from :math:`M` for which we choose the vertex from partition :math:`X`, and let :math:`MY` be the set of edges from :math:`M` for which we choose the vertex from partition :math:`Y`. Now we want to determine :math:`MX, MY`.

Similar to the previous section, we orient the edges of the bipartite graph such that edges belonging to :math:`M` are directed from partition :math:`Y` to :math:`X`, and edges not belonging to :math:`M` are directed from :math:`X` to :math:`Y`. Now, perform a DFS from all vertices in partition :math:`X` that are not present in the matching. Let :math:`A` be all vertices we visit, and :math:`B` be the rest. It is clear that there are no edges between :math:`X \cap A` and :math:`Y \cap B` (otherwise, set :math:`A` would change). Thus, all vertices in :math:`Y \cap A` and :math:`X \cap B` can be chosen for the vertex cover. Since none of these two sets contain free vertices (because :math:`M` is maximum, so there are no augmenting paths), we can conclude that our statement is equivalent to setting all edges visited in the DFS as :math:`MY` and the rest as :math:`MX`. That is, :math:`MX = M - MY`.

.. figure:: /_static/min_cover_finding.jpg
   :width: 50%
   :align: center
   :alt: If the user's internet is bad, this will show