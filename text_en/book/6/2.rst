Dijkstra
============
Problem Statement
-----------------

Given a weighted directed graph
:math:`G`,
where all edge weights in :math:`G` are non-negative.

We want to find the length of the shortest path from a source vertex :math:`sc` to all other vertices. The length of a path is defined as the sum of its edge weights.

Dijkstra's Algorithm
-------------------

We define an array named :math:`dis`. During the execution of the algorithm, :math:`dis_u` represents the shortest path to vertex :math:`u` such that the previous vertex on the path has definitely been selected (selection will be explained later). Initially, all entries in the :math:`dis` array are equal to
:math:`\infty`.
We know initially that
:math:`dis_{sc} = 0`.
Now, we select :math:`sc` and update the :math:`dis` values of its neighboring vertices.
   
Now, in each step of the algorithm, from the vertices we have not yet selected, we choose the vertex with the minimum :math:`dis` value and call it :math:`v`.

Now we will prove that the length of the shortest path from :math:`sc` to :math:`v` is indeed the current value of :math:`dis_v`. To do this, we use proof by contradiction and assume a shorter path exists (a path of length :math:`P`). Let :math:`last` be the last selected vertex on this path (it must exist since :math:`sc` is selected). We name the next vertex after
:math:`last`
as :math:`u` (this next vertex also exists because the last vertex on the path was not selected).

According to our contradictory assumption, the path length to :math:`v` was less than :math:`dis_v`, and since edges are non-negative, the path length to :math:`u` is also less than :math:`dis_v`. Since the vertex preceding :math:`u` in the path was a selected vertex, and the final distance of selected vertices is their :math:`dis` value, then :math:`dis_u` must have been updated to the shortest path length to :math:`u` when :math:`last` was selected. And since
:math:`dis_u < P` and :math:`P < dis_v`,
it follows that
:math:`dis_u < dis_v`,
which contradicts :math:`dis_v` being the minimum among the current values. Therefore, our assumption by contradiction is false, and the claim is proven.

Now that it is proven that :math:`dis_v` is exactly the length of the shortest path to :math:`v`, we select it. Then, for all its neighbors, such as :math:`adj`, where an edge from :math:`v` to :math:`adj` has weight :math:`w`,
:math:`dis_{adj} = min(dis_{adj}, dis_v + w)`
is performed. We continue this process until all vertices have been selected.

Complexity Analysis
------------
There are two general ways to implement this algorithm.

First approach with :math:`\mathcal{O}(n^2)` complexity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In each step, we iterate over all unselected vertices to find the minimum. In each step of the process, we perform
:math:`\mathcal{O}(n)`
operations. Since the algorithm has :math:`n` steps, the complexity of our program becomes
:math:`\mathcal{O}(n^2)`.


Second approach with :math:`\mathcal{O}(n + m \log n)` complexity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In each step, instead of iterating over all vertices, we use data structures that can find the minimum faster, such as :math:`set` and :math:`priority-queue` in :math:`C++` (assume we use :math:`set` here).

In each step, the minimum :math:`dis` value can be found in
:math:`\mathcal{O}(1)`
time. Each time we change an entry in :math:`dis`, we must update its value in the :math:`set`, which takes
:math:`\mathcal{O}(\log n)`
time.

Since in each step, the :math:`dis` values of neighbors of the selected vertex might change, we update :math:`dis` values for a total number equal to the sum of the degrees of all vertices. We know that the sum of degrees is of order
:math:`\mathcal{O}(m)`.
Therefore, in total,
:math:`\mathcal{O}(m \log n)`
time is spent on updates. Thus, the program's complexity becomes :math:`\mathcal{O}(n + m \log n)`.