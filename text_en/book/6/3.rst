فلوید وارشال
============
صورت مسئله
-----------

یک گراف جهت دار وزن دار 
:math:`G`
داریم. وزن یال های :math:`G` میتواند منفی نیز باشد. میدانیم گراف :math:`G` دور با مجموع وزن منفی ندارد. 

در این سوال به ازای هر جفت راس مانند :math:`(u, v)` طول کوتاه ترین مسیر از :math:`u` به :math:`v` را میخواهیم. طول یک مسیر برابر حمع وزن یال های آن است.

الگوریتم فلوید وارشال
-----------------------

برای حل این مسئله ابتدا یک :math:`dp` با ابعاد
:math:`|V(G)|.|V(G)|.|V(G)|`
تعریف میکنیم که 
:math:`dp_{k, i, j}`
برابر طول کوتاه ترین گشتی از راس :math:`i` به راس :math:`j` است که راس های وسطی آن (راس های مسیر به جز خود :math:`i` و :math:`j`) از بین مجموعه رئوس
:math:`\lbrace 1, 2, \dots, k \rbrace`
است.

حال میدانیم طول کوتاه ترین گشت بین 2 راس در گراف :math:`G` برابر طول کوتاه ترین مسیر نیز میباشد چون اگر کوتاه ترین گشت دارای 2 راس تکراری باشد یک دور داریم که طول آن مثبت است (طبق فرض سوال نمیتواند طول دور منفی باشد.) پس میتوان ان را حذف کرد و به یک گشت با طول کمتر رسید که تناقض است.

حال برای پایه های این دپپی میدانیم که :math:`dp_{0, i, i} = 0` و به ازای هر جفت از رئوس مانند 
:math:`(u, v)`
دیپی :math:`dp_{0, u, v}` را برابر کوتاه ترین یال از :math:`u` به :math:`v` این دو راس میزاریم. ( اگر یالی از :math:`u` به :math:`v` نبود
:math:`dp_{0, u, sc} = \infty`
است).


حال برای بدست اوردن :math:`dp_{k, i, j}` دو حالت را در نظر میگیریم یا راس :math:`k` در مسیر بهینه وجود ندارد که جواب در این حالت
:math:`dp_{k - 1, i, j}`
است. 

اگر راس :math:`k` در مسیر باشد انگاه مسیر بهینه برابر
:math:`dp_{k - 1, i, k} + dp_{k - 1, k, j}`
است چون که ابتدا از راس :math:`i` باید به راس :math:`k` برسیم و سپس از راس :math:`k` به راس :math:`j` برویم و در بین این دو مسیر حتما شماره رئوس از :math:`k` کمتر است.

برای بدست آوردن طول کوتاه ترین مسیر از راس :math:`u` به راس :math:`v` داشتن مقدار :math:`dp_{n, u, v}` کافی است. 

تحلیل اردر
-----------

برای اپدیت کردن هر خانه دیپی 
:math:`\mathcal{O}(1)`
عملیات انجام داده ایم. میدانیم که دیپی دارای
:math:`\mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right)`
است. پس در کل 
:math:`\mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right)`
عملیات انجام داده ایم. اردر حافظه استفاده شده نیز همان
:math:`\mathcal{O}\left(\left|V\left(G\right)\right|^{3}\right)`
است.


بهینه سازی اردر حافظه
------------------------

برای بهینه سازی مقدار حافظه مصرفی، میتوان بعد اول را حذف کرد. در نتیجه اردر حافظه مصرفی برابر 
:math:`\mathcal{O}\left(\left|V\left(G\right)\right|^{2}\right)`
میشود.

منظوز این است که یک 
:math:`for`
از 1 تا 
:math:`\left|V\left(G\right)\right|`
بزنیم و متغیر آن را :math:`k` بنامیم. سپس در هر مرحله
ازای هر خانه :math:`dp` آن را اپدیت کنیم. منظور از اپدیت کردن این است که مثل حالت عادی روی اینکه راس :math:`k` جزو راس های میانی مسیر هست یا نه حالت بندی کنیم.

حال برای اثبات درست بودن میگوییم که بعد هر مرحله حلقه اول تمامی مقادیر درست هستند. اگر ابتدا میگوییم که خانه های دیپی که یکی از بُعد های آن ها برابر
:math:`k`
است هیچ گاه تغییری نمی کنند. حال برای آپدیت کردن بقیه خانه های دیپی از مقادیر خانه هایی استفاده میکنیم که حتما یک بُعد از انها :math:`k` است. 

پس با استقرا میتوان ثابت کرد که بعد مرحله  :math:`k` م 
:math:`dp_{i, j} = dp^{\prime}_{k, i, j}`
است که 
:math:`dp^{\prime}`
همان دیپی بدون بهینه سازی است. پس بعد مرحله :math:`n`م به مقادیر مطلوب خواهیم رسید.

پس با استقرا میتوان ثابت کرد که بعد مرحله  :math:`k` م :math:`dp_{i, j} = dp^{\prime}_{k, i, j}`
است که 
:math:`dp^{\prime}`
همان دیپی بدون بهینه سازی است. پس بعد مرحله  :math:`n`  م به مقادیر مطلوب خواهیم رسید.

دور منفی
----------

ممکن است برایتان سوال شود اگر تضمین نشود که گراف دور منفی دارد یا نه چگونه بفهمیم دور منفی داریم یا نه ؟ برای این هدف ابتدا 
:math:`dp_{i, i} = 0`
قرار میدهیم. حال اگر در حین اجرای الگوریتم یکی از خانه های 
:math:`dp_{i, i} < 0`
شد انگاه میدانیم یک گشت با طول منفی از :math:`i` به :math:`i` وجود دارد که میدانیم در هر گشت بسته با طول منفی دوری به طول منفی وجود دارد. 

اگر دور منفی وجود داشت حتما برای راسی مانند :math:`u` در دور منفی حتما
:math:`dp_{u, u} < 0`
میشد. چون دور منفی ما طبق تعریف :math:`dp` ما مشکلی ندارد و در 
:math:`dp_{u, u}`
تاثیر دارد و انرا منفی میکند.

طبق دو تا استدلال بالا وجود داشتن دور منفی با داشتن 
:math:`dp_{i, i} < 0` 
معادل است. پس کافی است فقط بررسی کنیم در طول فرایند :math:`dp_{i, i}` منفی نشود.
