Segment Tree
============
Segment Tree is undoubtedly one of the most widely used data structures in competitive programming.
Its binary tree type is a `Full Binary Tree <https://gtoi.shaazzz.ir/book/8/1.html#full-binary-tree>`_.

Using this data structure, one can find the sum of a range in an array, or the maximum or minimum value in an array.

Structure
----------
Each node in this tree represents a range of the array in question.
The children of each node (if they exist, there are naturally two) divide their parent's range in half. In other words, if a node's range is :math:`[Begin, End)`, its two children's ranges are :math:`[Begin, Middle)` and :math:`[Middle, End)` respectively.
Leaf nodes (nodes without children) contain a single element from the array.

To better understand the relationship between nodes and ranges, refer to the figure below.

.. figure:: /_static/SegmentTree.png
   :width: 75%
   :align: center
   :alt: Segment Tree

In each of these nodes, specific information about the corresponding range in the array is available, which can vary depending on our use of this data structure.
For example, if we are looking for the sum of a range in an array, each node stores the sum of its corresponding range.

For a clearer understanding of this part, refer to the figure below showing how each node stores a value.

.. figure:: /_static/construction.png
   :width: 85%
   :align: center
   :alt: Segment Tree

The height of this tree is :math:`lg n` and the maximum number of nodes it uses is :math:`2n`. Therefore, you can store this data structure with :math:`2n` memory. It is worth noting that some people consider :math:`4n` memory, which is due to the implementation type where two children without any specific characteristics are placed for each leaf node (single-element nodes), causing the memory to double.

For numbering the nodes, the root can be assigned the number one, and the left and right children of each node can be assigned :math:`2k` and :math:`2k + 1` respectively.

Algorithm
---------
The execution method of this algorithm is almost identical for all types of problems solvable with this data structure. We will explain the algorithm using one of its famous queries.

Initially, we are given an array, and at each step, we are asked either to change the value of an array element or to report the sum of a range.

Build
~~~~~
To solve, we first build the Segment Tree from the array. For this, we first construct the main structure of the Segment Tree, then set the value of each node to the sum of its children's values, and set the value of leaf nodes (single-element nodes) to the value of the corresponding element.

.. code-block:: cpp

    void build(int u = 1, int ul = 0, int ur = n){
        if(ur - ul < 2){
            seg[u] = a[ul];
            return;
        }
        int mid = (ul + ur) / 2;
        build(u * 2, ul, mid);
        build(u * 2 + 1, mid, ur);
        seg[u] = seg[u * 2] + seg[u * 2 + 1];
    }

Updating a single element
~~~~~~~~~~~~~~~~~~~~~~~~~

We change the value of all nodes whose range includes this element. Note that the number of such ranges is at most equal to the height of the tree, because each level of the tree partitions the array. Therefore, at most one node's value needs to change at each level, making the order of this operation :math:`O(lg n)`.

.. code-block:: cpp

    void update(int i, int x, int u = 1, int ul = 0, int ur = n){
        seg[u] += x - a[i];
        if(ur - ul < 2){
            a[i] = x;
            return;
        }
        int mid = (ul + ur)/2;
        if(i < mid)
            update(i, x, u * 2, ul, mid);
        else
            update(i, x, u * 2 + 1, mid, ur);
    }

Querying the sum of a range
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We use a recursive approach, and at each step, we find the sum of the requested range, assuming we are at node `u`.
There are three cases for the relationship between the requested range and node `u`'s range. The first case is when these two ranges are equal, in which case the answer is the value of node `u`. The second case is when the requested range is completely within the range of one of node `u`'s children, in which case we find the answer in the child whose range contains the requested range.
The last case is when part of the requested range is within the left child's range and the rest is within the right child's range. For this, we recursively find the value of the part of the requested range that is in `u`'s left child's range, then the value of the part that is in `u`'s right child's range, and then sum these two results.
To find the sum of the requested range, it is sufficient to start from node one using this method.

For better understanding, assume :math:`F(u,ul,ur,l,r)` is the recursive function above that, given the current node `u`, its range, and the requested range, returns the answer (assuming the requested range is within node `u`'s range), and :math:`sum[u]` refers to the value stored in node `u`. The summary of the three cases above is as follows:

.. math:: Middle = (ul + ur) / 2
.. math:: (ul = l, ur = r) => F(u,ul,ur,l,r) = sum[u]
.. math:: (r < Middle) => F(u,ul,ur,l,r) = F(2*u,ul,Middle,l,r)
.. math:: (l > Middle) => F(u,ul,ur,l,r) = F(2*u+1,Middle,ur,l,r)
.. math:: (l < Middle, Middle < r) => F(u,ul,ur,l,r) = F(2*u,ul,Middle,l,Middle) + F(2*u+1,Middle,ur,Middle,r)

The order of this operation is :math:`O(lg n)` because at most 4 nodes are used in the recursive function at each level. For proof, it is sufficient to note that only the rightmost and leftmost nodes of a level can call their children, meaning a maximum of 4 nodes are called at each level.

.. code-block:: cpp

    int sum(int l, int r, int u = 1, int ul = 0, int ur = n){
        if(x >= ur || ul >= y)return 0;
        if(x <= ul && ur <= y)return seg[u];
        int mid = (ul + ur) / 2;
        return sum(l, r, u * 2, ul, mid) + sum(l, r, u * 2 + 1, mid, ur);
    }

Lazy propagation
------------------------------------
Suppose that in the first operation, instead of changing a single value, changing a range is required. For example, we are asked to add two units to the range from :math:`L` to :math:`R`. If we want to change all elements in this range, it would be difficult and increase the number of operations. Now, using the lazy propagation technique, we can reduce the number of operations. This is done by considering another value for each node, which is, for instance, stored in a `Lazy` array. We divide the given range for modification into smaller ranges (on the tree), similar to how we handled the requested range in the second operation, and update the `Lazy` array value for all these nodes (nodes on which the range has been divided). And whenever we are at a node in this algorithm, we add its `Lazy` value to the node's own value, propagate its `Lazy` value to its children's `Lazy` values, and then reset its own `Lazy` value to zero.

.. code-block:: cpp

    void upd(int u, int ul, int ur, int x){
        lazy[u] += x;
        seg[u] += (ur - ul) * x;
    }
    void shift(int u, int ul, int ur){
        int mid = (ul + ur) / 2;
        upd(u * 2, ul, mid, lazy[u]);
        upd(u * 2 + 1, mid, ur, lazy[u]);
        lazy[u] = 0;
    }
    void increase(int l, int r, int x, int u = 1, int ul = 0, int ur = n){
        if(l >= ur || ul >= r)return;
        if(l <= ul && ur <= r){
            upd(u, ul, ur, x);
            return;
        }
        shift(u, ul, ur);
        int mid = (ul + ur) / 2;
        increase(l, r, x, u * 2, ul, mid);
        increase(l, r, x, u * 2 + 1, mid, ur);
        seg[u] = seg[u * 2] + seg[u * 2 + 1];
    }
    int sum(int l, int r, int u = 1, int ul = 0, int ur = n){
        if(l >= ur || ul >= r)return 0;
        if(l <= ul && ur <= r)return seg[u];
        shift(u, ul, ur);
        int mid = (ul + ur) / 2;
        return sum(l, r, u * 2, ul, mid) + sum(l, r, u * 2 + 1, mid, ur);
    }