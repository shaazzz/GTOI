Minimum Spanning Tree
=====================

Problem Description
-------------------
Suppose we are given a weighted graph and asked to find a spanning subgraph that is a tree and whose total edge weight is minimal.
In this case, we are looking for its Minimum Spanning Tree.

We introduce the following four algorithms to solve this problem.

Algorithms
----------

Kruskal
~~~~~~~

We sort the graph's edges by their weights in ascending order. We add the graph's vertices to the final MST without any edges initially (imagine we are building the MST step-by-step, and at the beginning, this MST has no edges, and we are about to add them).
The algorithm starts with the first sorted edge and, in each step, adds the selected edge to the MST if it does not form a cycle with previously selected edges.
To determine if the selected edge forms a cycle, we can use DSU (Disjoint Set Union).
The correctness of this algorithm is proven by contradiction. Assume the MST found by the algorithm is G, and the true MST is H. Consider the lightest edge that is used in H but not in G. In Kruskal's algorithm, we must have skipped this edge because it formed a cycle (with edges already chosen in G). Therefore, H must contain a cycle, which contradicts the assumption that H is an MST.
The time complexity of this algorithm is :math:`O(m \log n + n)`.

Prim
~~~~

In general, Prim's algorithm maintains a set of vertices, to which a new vertex is added with an edge in each step, until the set of vertices becomes identical to the set of all vertices in the original graph.
To become more familiar with this algorithm, pay close attention to its steps.

- Create a set that represents the vertices included in the MST at each step of this algorithm.
- Initialize a 'minimum distance' value for all graph vertices, setting all of them to infinity (a very large number), and for an arbitrary starting vertex (our first vertex in this algorithm), set its value to zero.
- Until our set becomes identical to the set of all graph vertices, perform these three actions: First, select a vertex `u` that is not in our set and has the minimum distance value. Add `u` to our set, and then update the distance values of all neighbors of `u`. Specifically, if vertex `w` is connected to vertex `u` by an edge `z`, and `Dis[u] + z` is less than `Dis[w]`, then update `Dis[w]` to `Dis[u] + z`.

.. math:: Dis [u] + z < Dis [w] => Dis [w] = Dis [u] + z

The final explanation of Prim's algorithm's idea is that in each step, we choose the edge with the minimum weight between the set of vertices we have already selected and the set of other vertices in the graph.
The algorithm's proof is as follows: in each step, we select an edge between our current set of vertices and the set of other vertices. If this edge is not selected, the MST will not be connected, which is a contradiction. If two edges are selected, the MST will contain a cycle, again leading to a contradiction. Therefore, exactly one edge must be selected, and for the MST to have the minimum total weight, the lightest edge must be chosen, which is precisely what we do.
The time complexity of this algorithm is :math:`O(m \log n + n)`.