Tree Hash
============

In this section, we examine checking the equality of two trees. Suppose we are given two trees :math:`T_1` and :math:`T_2`, and we want to present a linear algorithm to check whether :math:`T_1` and :math:`T_2` are equal. Equality here means that if we disregard the node numbering, the two trees can be drawn such that their shapes are identical.

Reduction to Rooted Tree Equality
---------------------------------

Suppose we know that node :math:`u_1` of tree :math:`T_1` is to be equal to node :math:`u_2` of tree :math:`T_2`. Then we can check the equality of two rooted trees, which seems simpler than the current problem.

So now, if we can solve the problem of equality of two :math:`n`-node rooted trees in :math:`O(f(n))`, we have a solution that solves the current problem in :math:`O(n \times f(n))`. It is enough to consider :math:`u_1` as a fixed node and iterate over all possibilities for :math:`u_2`.

The key idea here is to choose :math:`u_1, u_2` with a special property such that the number of nodes in the tree with this property is small. For example, if we consider :math:`u_1` to be a leaf, then :math:`u_2` must also be a leaf. So, instead of iterating over :math:`n` possibilities for :math:`u_2`, it is sufficient to iterate over the number of leaves in :math:`T_2`.

In previous sections, we learned that every tree has at most 2 centroids. Consequently, if we consider the desired property to be 'being a centroid', it is enough to consider :math:`u_1` as one of the centroids of tree :math:`T_1` and iterate over all centroids of tree :math:`T_2` for :math:`u_2` (which are at most 2). Thus, we were able to solve the problem in :math:`O(f(n))`.

Solving Rooted Tree Equality
------------------------------------

Suppose :math:`r_1` is the root of tree :math:`T_1` and :math:`r_2` is the root of tree :math:`T_2`, and now we want to check the equality of these two trees. Initially, if the number of children of :math:`r_1` and :math:`r_2` are not equal, then the two trees are clearly unequal. If the number of children is equal, we need to figure out which child of :math:`r_1` corresponds to which child of :math:`r_2`. If we figure this out, we can solve the problem recursively by checking the equality of the subtree of each child of :math:`r_1` with the subtree of its corresponding node in tree :math:`T_2`.

In other words, we need to permute the children sequences of :math:`r_1` and :math:`r_2` in some way, and then for each :math:`i`, check the equality of the subtrees of the :math:`i`-th children of :math:`r_1` and :math:`r_2`.

Now we use the idea of ordering the children of each node based on a specific property. In this case, we no longer need to check all permutations of the children of :math:`r_1` and :math:`r_2`; it is sufficient to check only the current ordering.

We assign a sequence of parentheses to each rooted tree :math:`T` with root :math:`r`. This is done by first recursively computing the subtrees corresponding to the children of :math:`r`, then sorting the children of :math:`r` based on the lexicographical order of their strings. **This is the fixed order we wanted to assign to the children of each node.** Finally, the parenthesization sequence of :math:`T` is given by :math:`S = (S_1S_2...S_k)`, where :math:`S_i` are the parenthesization sequences corresponding to the subtree of the :math:`i`-th child of :math:`r`.

You can verify that two rooted trees are equal if and only if their assigned parenthesization sequences are equal.

.. figure:: /_static/dot/Hash_Tree.svg
   :width: 30%
   :align: center
   :alt: If the user's internet is trash, this appears

Calculating Rooted Tree Hash
-----------------------------

Since working with a string (concatenating two strings or checking string equality) requires :math:`O(n)` operations, it leads us to think about assigning a number to each node instead of a string, where each number represents a string!

So, we use the logic above and obtain the number corresponding to each node as follows. First, we obtain the numbers of the children, then sort them, and assuming they are :math:`H_1,...,H_k`, our number will be :math:`H = (1 + \sum H_i \times P^i) \pmod M`, where :math:`M` and :math:`P` are two random prime numbers. This technique is called hashing. Since :math:`M` and :math:`P` are random numbers, we can assume that the resulting numbers are random, and the probability of assigning the same numbers to two different trees will be very small. (For more certainty, this can be done with more :math:`M` and :math:`P` values to further reduce the chance of failure).

The implementation of the algorithm we described is as follows:

.. code-block:: cpp

  const int maxn = 1e5 + 10, P = 101, M = 1e9 + 9;
  
  vector <int> v[maxn];
  
  int calc(int u, int par = -1){
      vector<int> vec;
      for(int y : v[u]){
  	      if(y != par)
  	      vec.push_back(calc(y, u));
      }
      sort(vec.begin(), vec.end());
      int H = 0;
      for(int x : vec)
	    H = (1ll * H * P + x) % M;
      H = (1 + H) % M;
      return H;
  }
  
  int main(){
      int n;
      cin >> n;
      for(int i = 0; i < n - 1; i++){
	  int a, b;
	  cin >> a >> b;
	  v[a].push_back(b);
	  v[b].push_back(a);
      }
      cout << calc(1) << "\n"; // hash of rooted tree from node 1
      return 0;
  }
