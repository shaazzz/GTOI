Games and Directed Graphs
=======================

Introduction
---------------------------
In this section, we will examine the relationship between games and directed graphs.

Let's start with a simple example:

Ali and Matin are playing a game. There is a bag containing 10 pebbles in front of them. In each turn, the player whose turn it is removes 1 or 2 pebbles from the bag. The loser of the game is the one who faces an empty bag and cannot remove any pebbles.

Suppose Matin starts the game. If both players play optimally, who will win the game?

Analyzing an Example
---------------------------
In this section, we will explain the example presented in the introduction.
 
We construct an 11-node graph, with node numbers ranging from 0 to 10. We draw a directed edge from node
:math:`i`
to node
:math:`j`
if it's possible to reach :math:`j` from :math:`i` by removing 1 or 2 pebbles.

Next to each node, we write a letter
:math:`L(Lose)`
or 
:math:`W(Win)`
(or nothing, which means the status of this node is not yet determined).

Suppose we have written the letter
:math:`L`
next to node
:math:`i`.
This means that if the initial bag from which two players are playing has
:math:`i`
pebbles, and both players play optimally, the first player will lose that game.

Conversely, suppose we have written the letter
:math:`W`
next to node
:math:`i`.
This means that if the initial bag from which two players are playing has
:math:`i`
pebbles, and both players play optimally, the first player will win that game.

Now, at the beginning of the game, which node can be assigned
:math:`L`
or 
:math:`W`
?!

With a little thought, we realize it's node 0. This means that if the initial bag contains 0 pebbles, according to the game rules, the first player loses, because they cannot remove any pebbles.

So, we assign :math:`L` to node 0.

Now, which is the next node whose status is determined?

Consider node 1. If the bag only has 1 pebble, the first player can only remove one pebble. Now, if we pay attention, we see that the bag remaining after the first player's move contains 0 pebbles, whose status we previously determined.

We previously said that the status of node 0 is 
:math:`L`.
So, the status of node 1 becomes
:math:`W`.
Because if you notice, when the first player removed a pebble, the positions of the first and second players in the game swapped (because the turn changed). Therefore, node 0 represents the loss for the second player (Ali).



**Conclusion**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We determine the status of the nodes, i.e.,
:math:`L`
or 
:math:`W`,
in increasing order of node numbers.

To do this, if among the nodes to which
:math:`v`
has a directed edge, there exists a node
:math:`u`
whose status is
:math:`L`,
then the status of node 
:math:`v`
becomes
:math:`W`.
And if all nodes to which
:math:`v`
has an edge have a status of
:math:`W`,
then the status of node
:math:`v`
becomes
:math:`L`.

Using this method, we can determine the status of all nodes. Now, it's enough to look at the initial state of the game and see if it's
:math:`L`
or
:math:`W`.
If it's
:math:`L`,
it means the first player loses the game. And if the status is
:math:`W`,
it means the first player wins. With this, we can figure out whether Ali or Matin wins the game we described above!

Game of Moving a Piece on a Graph
---------------------------
Our game is as follows: we have a graph, and initially, a piece is on a starting node. Players move in turns, and each player moves the piece to an adjacent node in their turn. The player who cannot make a move loses the game.

Generalization
~~~~~~~~~~~~~~~~

If you pay attention to the nature of most games, you will see such a graph within them! In fact, the essence of combinatorial games is that two or more players make changes to shared resources (shared resources can be a chessboard on which we move pieces, or a bag from which we take pebbles).

Now, suppose we create a node for each state of the shared resources and whose turn it is, and draw a directed edge from node :math:`A` to :math:`B` if and only if the person whose turn it is in state :math:`A` can move to :math:`B` in their turn. Now we have a graph! We have been able to define our game on a graph. 

So, we intuitively accept that most games can be converted into a game of moving a piece on a graph (as described above). For example, consider the game of chess. Each state of this game is a chessboard with a different arrangement of pieces.

Solving the Game on a Graph
~~~~~~~~~~~~~~~~~~~~~

If we can solve the game of moving a piece on a graph, we have taken a big step in understanding how to solve most games. To solve this game, we proceed as follows. We assign each node a label of Win (W), Lose (L), or Draw (D). Pay attention to the following three points.

- A node with no outgoing edges is definitely L.
- A node with an L-neighbor is definitely W.
- If a player has a non-losing strategy, it's impossible for them to move the piece to a node labeled W (because in that case, their opponent can win).

So, we implement this algorithm on our graph. As long as there is a node like :math:`u` with no outgoing edges, we label it :math:`L`. Then, we label all nodes like :math:`v` that have an edge to :math:`u` as W. After that, we remove all labeled nodes from the graph. Why? Because we are sure that if a player wants to move the piece to :math:`v`, they must first reach a node labeled W, and no player wants to move the piece to W-nodes. 

Eventually, a time comes when every remaining node in the graph has at least one outgoing edge. If we start from any of these remaining nodes, the game will never end, and both players can continue the game indefinitely! Thus, we have been able to partition the nodes into three categories, and for each category, we know what the outcome of the game will be (Win, Lose, or Draw) if we start from a node within it. So, we have algorithmically solved the game of moving a piece on a graph.


Some Useful Conclusions
~~~~~~~~~~~~~~~~~~~~~~~~~~

If a node has an edge to itself, then this node will certainly not be L. Because according to the algorithm, we only label a node L if it has no outgoing edges. More precisely, the player whose piece is currently on this node can easily 'steal' the opponent's strategy. That is, if they realize the other player can win, they can simply use the self-loop edge, and this move is as if they have swapped their turn with the next player's, after which they can use the other player's strategy. Examples of 'stealing strategy' are provided in the problems section.

The algorithm we discussed can be examined in another way for acyclic graphs. This is due to the characteristic of DAGs, namely having a topological order. We arrange the nodes of the graph in topological order. Now we start from the end and remove the nodes one by one. If the node we remove has an edge to an L-node that is further along (i.e., comes later in the topological order), we label it W; otherwise, we label it L. Ultimately, all nodes will be assigned either win or lose, because such games are always finite.

Final Word
------------

It seems that converting games into graphs is an effective way to solve them, but in reality, it's not always the case. 

Because in practice, many games, after being converted into graphs, will have an enormous (or even infinite) number of nodes, and since solving games requires memory and execution time proportional to the number of nodes and edges, solving many games this way is not feasible. (Can you estimate how many distinct nodes the game of chess would have after being converted into a graph?!).

On the other hand, in many games, converting to a graph can provide better intuition for problem-solving, or our graph will be very specific. So, the conclusion is that converting to a graph is a relatively powerful tool for solving and gaining intuition about games, but it will not always meet our needs.