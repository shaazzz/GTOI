Cycle Detection in Directed Graphs
==========================================================
Introduction
------------------------------------------------
In previous sections, it was sometimes necessary to determine whether a directed graph has a cycle or not! For example, to provide a topological ordering of a graph, we must first ensure that the graph is acyclic. This is because a graph with a cycle has no topological ordering!

Here, we will describe two algorithms that can detect whether a graph is cyclic. Furthermore, in the first algorithm, we will output a cycle found in the graph!

Cycle Detection Algorithm using DFS
------------------------------------------------
**Description:** This algorithm is similar to the algorithm in section 3.3, with the difference that here we will have two types of markings for each vertex. The graph is traversed using
:math:`DFS`,
and each vertex is marked as "visited" when we enter it, and as "exited" when we leave it. Now, if during traversal we reach a vertex that we have visited but not yet exited, we conclude that the graph has a cycle; otherwise, the graph is acyclic.

**Correctness Proof:** When we are traversing the graph, if we are at a vertex :math:`v` and reach a vertex :math:`u` that we have visited but not yet exited (vertices in a 'gray' path), this means there is a directed edge from :math:`v` to :math:`u` (a 'red' edge) and :math:`u` has a directed path to :math:`v`, which implies the graph has a cycle. Furthermore, if the graph has a cycle, this algorithm will certainly find it. Otherwise, assume :math:`G` is a graph with at least one cycle, and the algorithm failed to find it. If :math:`v` is the first vertex entered from a cycle :math:`C`, and :math:`e` is an edge from :math:`u` to :math:`v` that is part of cycle :math:`C`, then during the traversal, before exiting :math:`v`, we will reach :math:`u` (because these two vertices are in a cycle and there must be a path from :math:`v` to :math:`u`). Then, using edge :math:`e`, we reach :math:`v` again, which means we have found a cycle. Therefore, from the contradiction, it follows that the algorithm finds a cycle in any graph that has one.

.. figure:: /_static/dot/Cycle_DFS.svg
   :width: 50%
   :align: center
   :alt: DFS cycle detection illustration

Algorithm Complexity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The algorithm uses DFS once, resulting in a complexity of
:math:`O(m+n)`,
where :math:`n` is the number of vertices and :math:`m` is the number of edges.

Algorithm Implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Note that in the implementation below, if a cycle is present, the found cycle is output; otherwise, the topological order of the vertices is output.

.. code-block:: cpp

	const int MX = 5e5 + 200;

	int n, m;
	vector<int> gr[MX], topo, cycle;
	bool st[MX], ed[MX];

	bool dfs(int v){
	    st[v] = 1;
	    for(int u: gr[v]){
			if(st[u] && !ed[u]){
				cycle.push_back(u);
				cycle.push_back(v);
				return 0;
			}
			if(!st[u] && !dfs(u)){
				if(cycle[0] != cycle[cycle.size() - 1])
					cycle.push_back(v);
				return 0;
			}
	    }
	    ed[v] = 1;
	    topo.push_back(v);
	    return 1;
	}

	int main(){
	    cin >> n >> m;
	    for(int i = 0; i < m; i++){
			int v, u;
			cin >> v >> u;
			gr[v].push_back(u);
	    }
	    bool check = 1;
	    for(int i = 0; i < n; i++){
			if(!st[i] && !dfs(i)){
				check = 0;
				break;
			}
	    }
	    if(check){
			cout << "no cycle \ntopo order: ";
			for(int v: topo)
				cout << v << ' ';
	    }
	    else{
			cout << "cycle: ";
			for(int i = cycle.size() - 2; i >= 0; i--)
				cout << cycle[i] << ' ';
	    }
	    return 0;
	} 

Kahn's Algorithm
------------------------------------------------
**Description:** Another method to determine if a graph has a cycle is Kahn's algorithm. This algorithm operates based on induction. This method is very similar to Theorem 3.3.2!

The algorithm starts with an empty set of vertices, which we call :math:`zero`. This set contains vertices whose in-degree is 0 in the current graph.

Initially, we add all vertices with an in-degree of 0 to :math:`zero`.

In each step, we remove the vertices in :math:`zero` along with their outgoing edges from the graph. Consequently, some new vertices might have their in-degree become 0 and be added to :math:`zero`. We continue this process until either the number of vertices in the graph becomes 0 or the set :math:`zero` becomes empty.

If at any point the size of the set :math:`zero` is 0, and the current graph still contains some vertices, then the graph definitely has a cycle. If this does not happen and all vertices are removed from the graph, then the graph is acyclic.

.. figure:: /_static/dot/Cycle_Kahn.svg
   :width: 80%
   :align: left
   :alt: Kahn's algorithm cycle detection illustration

For a better understanding, see the adjacent figure. In this figure, the blue cycle never enters the :math:`zero` set, and therefore the graph is detected as cyclic!

**Correctness Proof:** To prove the algorithm, we consider two cases for the graph. First, assume graph :math:`G` has a cycle; then we claim the algorithm correctly detects its presence.

If :math:`G` has a cycle, then if we call this cycle :math:`C`, none of the vertices in :math:`C` will ever be added to :math:`zero` (why?). Thus, we reach a point where the graph still contains some vertices, but :math:`zero` is empty! So the algorithm detects the cycle.

Now, if the graph does not have a cycle, we prove by induction on the number of vertices that all vertices will be removed!

Firstly, if a graph has no cycle, then according to Theorem 3.1.3, there are vertices in graph :math:`G` whose in-degree is 0. These vertices are then added to the :math:`zero` set and subsequently removed from the graph along with their outgoing edges. Thus, the number of vertices decreases. On the other hand, the inductive hypothesis holds, and the current graph has no cycle. Therefore, by induction, all vertices are removed from the graph, and the algorithm correctly detects the absence of a cycle.

Algorithm Complexity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To analyze the algorithm's complexity, we need to examine how much we traverse vertices and edges. We traverse edges when a vertex is in the
:math:`zero`
set; then we traverse its outgoing edges. On the other hand, each vertex is added to
:math:`zero`
only once and then removed from the graph. Thus, we traverse each edge once.

Similarly, we traverse vertices when a vertex is placed in the
:math:`zero`
set. And likewise, each vertex is added to this set only once and then removed from the graph.

Therefore, the complexity of the above algorithm is
:math:`O(n + m)`,
which is similar to the previous algorithm!

Algorithm Implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: cpp

	const int maxn = 5e5 + 5;

	int n, m; // number of vertices and edges
	int in_edge[maxn]; // in_edge[v] is the in-degree of vertex v!

	vector <int> g[maxn]; // adjacency list
	vector <int> zero; // vertices that have in-degree 0 and should be removed!

	bool has_cycle(){
	      for(int i = 0; i < n; i++){
		    if(in_edge[i] == 0){
			  zero.push_back(i); 
		    }	   
	      }
	      for(int i = 0; i < n; i++) {
		    if(zero.size() == 0){
			  return true;
		    }
		    int v = zero[zero.size() - 1]; // last element from zero_set
		    zero.pop_back();
		    for(int u : g[v]){
			  in_edge[u]--;
			  if(in_edge[u] == 0){
				zero.push_back(u);
			  }
		    }
	      }
	      return false;
	}


	int main(){
	      cin >> n >> m;
	      for(int i = 0; i < m; i++){
		    int u, v;
		    cin >> u >> v; // u, v are 0-based
		    g[u].push_back(v);
		    in_edge[v]++; // edge (u, v) is in the graph. So in-degree of v increases by one!
	      }
	      if(has_cycle())
		    cout << "graph has at least one cycle!" << endl;	    
		  else 
		    cout << "graph is acyclic!" << endl;
	      return 0;
	}
