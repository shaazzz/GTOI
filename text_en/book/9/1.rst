تعریف np و np کامل
=====================

You may have heard that a certain problem is NP, and thus cannot be solved. But what does that really mean? And why can't it be solved? In this chapter, we will examine these issues.

The purpose of this chapter is to finalize the status of graph problems for which we have not provided an algorithm. This chapter justifies our failure to provide a practical algorithm for these problems.

This topic is one of the topics in theoretical computer science. Although reading this chapter will not directly help your success in Computer Olympiad exams, reading it is recommended for the following reasons:

- This topic is one of the most interesting topics in theoretical computer science, and you, as someone interested in the Computer Olympiad, will definitely enjoy it.
- Reading this topic helps you avoid common misconceptions among students about NP problems.
- Reading this topic helps you more easily identify NP problems and avoid attempting to solve them in exams.

مسائل تصمیم
--------------
Decision problems are problems whose answer is only a single bit. That is, their answer is either yes or no. For example, the problem "factorize a number" is not a decision problem, but "is a number prime or not?" is a decision problem.

Generally, for problems, there is a corresponding decision problem that can be used to solve the original problem. For example, the decision problem "is the smallest prime factor of this number greater than k or not?" can solve the factorization problem with the help of a binary search. In general, the decision problem "is the k-th bit of the output 1?" can solve the original problem.

In this section, we are dealing with decision problems, but the results can be widely used in other problems as well.

کلاس P
---------
Problems in class P are a category of decision problems for which an algorithm exists that can determine the result in :math:`O(|s|^k)`. Here, :math:`s` is the input string, :math:`|s|` is the length of the input string, and :math:`k` is a constant independent of the input. In other words, problems that can be solved in polynomial time with respect to the input length are in this class. Note that input length is not always the parameter by which we analyze algorithm complexity. For example, the decision problem of factoring a number, i.e., "does number :math:`n` have a prime factor smaller than :math:`k`?", has an algorithm with time complexity :math:`O(\sqrt{n})` or :math:`n^{\frac{1}{2}}`. However, this problem is not in class P because the input length is :math:`O(\lg(n))`, meaning our algorithm was not polynomial with respect to the input length.

کلاس NP
---------
These problems are a category of problems that do not necessarily have a polynomial-time solution, but they do have a polynomial-time verifier.

تایید کننده
~~~~~~~~~~~~~
A verifier for a problem is itself a decision problem that takes the input of the main problem along with an auxiliary string (which is called a certificate or proof) and determines whether this certificate is a correct answer for the problem or not. If an auxiliary string exists that the verifier accepts, then the answer to the main problem was affirmative. If the answer to the main problem is negative, no string exists that the verifier would accept.

More precisely, if we denote the main problem by :math:`X` where :math:`X(s)` is either accepted or rejected, we call a problem like :math:`C(s,t)` a verifier for problem :math:`X` if and only if the following two conditions hold:

- If :math:`X(s) = 0`, then for every possible string :math:`t`, :math:`C(s,t) = 0`.
- If :math:`X(s) = 1`, then at least one string :math:`t` exists such that :math:`C(s,t) = 1`.

تعریف
~~~~~~~
Now we return to the definition of class NP. A problem is a member of this class if and only if it has a verifier that reaches a result in polynomial time, and also, if the answer to the main problem is affirmative, there exists an auxiliary string whose length is polynomial with respect to the input, and the verifier accepts it.

مثال
~~~~~~~
A wide range of problems falls into this class. For example, consider the problem of whether a graph has a Hamiltonian cycle. A verifier can take a permutation of vertices as input and check if each member of this permutation has an edge to its next member. If the answer to the main problem is negative, no such permutation exists. If it's affirmative, a permutation exists whose length is less than the original graph, and the verifier can perform this check in linear time. Thus, the Hamiltonian cycle problem is a problem in class NP.

The corresponding decision problem for number factorization is also an NP problem. A verifier can take a number smaller than :math:`k` as input and determine whether the main input is divisible by this number. This determination can be done in polynomial time using division (with the help of the algorithm we learned in elementary school), and the length of the proof (the number smaller than :math:`k`) is less than the input length. Therefore, this problem is also in class NP.

کاهیدن چند جمله ای
---------------------
We define problem A to be polynomially reducible to problem B if and only if problem A can be solved in polynomial time with the help of an algorithm and an oracle machine for problem B. Reduction is important because if A is reducible to B, and B can be solved in polynomial time, then A can also be solved in polynomial time.

مسائل NP سخت و NP کامل
-------------------------
We call a problem NP-hard if and only if every problem in class NP can be polynomially reduced to it. If an NP-hard problem is itself in class NP, it is called NP-complete.
It might seem strange that all problems, which have immense breadth and diversity, can be reduced to a single problem, but later in this chapter, you will become familiar with many NP-hard and NP-complete problems.

P=NP
--------
This problem is the biggest open problem in all of computer science. This problem asks whether all problems in class NP can be solved in polynomial time or not. This problem is equivalent to whether one of the NP-hard problems can be solved in polynomial time.

An affirmative answer to this problem would break all encryption algorithms and has the potential to collapse the economy. On the other hand, it would compute computational problems that currently take billions of years in a short time. It could find the key to curing cancer and so on.

A negative answer to this problem, although it has no practical application and the general belief is that the answer is negative, would be a tremendous advancement in theoretical computer science. A prize of one million dollars has been set for proving this problem.