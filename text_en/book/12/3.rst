Minimum Cut and Maximum Flow
==========================

In this section, we examine an important problem in the field of algorithms that can be used to solve many other problems (including the matching problem).

In this problem, we have a water network with several points connected by directed pipes (edges). Each pipe has a capacity, which means the maximum amount of water flow that can pass through it. Two specific points in this network are important to us: the source and the sink. The goal is to measure the maximum amount of water flow that can be transferred from the source to the sink.

Equivalence with Minimum Cut
---------------------
Consider the same graph as in the problem above. We want to remove a set of edges such that there is no directed path from the source vertex to the sink vertex. The goal is to minimize the sum of capacities of the removed edges. This problem is called the minimum cut problem. We will prove that in any graph, the maximum flow is equal to the minimum cut.

Proof
~~~~~~~
First, it is clear that the size of any cut is greater than or equal to the size of any flow. This is because removing an edge reduces the flow by at most its capacity, and as long as there is flow, we have not yet reached a cut. To prove that maximum flow is equal to minimum cut, we consider a maximum flow and construct a cut of the same size.

Consider a maximum flow. An augmenting path is a path such that if we use an edge in its forward direction along the path, its full capacity should not have been used; and if we use it in the reverse direction, there must have been some flow through it. For example, the path below is an augmenting path:

.. figure:: /_static/flow_path.png
   :width: 50%
   :align: center
   :alt: If the user's internet is bad, this appears

In a maximum flow, there is no augmenting path from the source to the sink. Because if there were, we could increase the flow by increasing the flow through edges in the forward direction (blue edges) by one unit and decreasing the flow through other edges by one unit. This would increase the total flow by one unit.

Now, to find a cut of size equal to the maximum flow = f, consider the set of vertices that are reachable from the source vertex via an augmenting path. According to the above, the sink vertex is not in this set. The incoming flow to this set is 0 because if there were an edge from outside this set that had flow passing through it and entering this set, then the vertex outside this set (the source of that edge) must also be in this set, as there would be an augmenting path to it. The sum of incoming and outgoing flow for any set is equal to the sum of incoming and outgoing flow for each vertex in that set. And the sum of incoming and outgoing flow for each vertex is exactly 0, except for the source and sink vertices. The source vertex has f units of outgoing flow. So, the sum of incoming and outgoing flow for the set we considered is exactly f. Since the incoming flow to this set is 0, its outgoing flow is therefore f. Consider the outgoing edges from this set; all their capacities are fully utilized (otherwise, an augmenting path to the vertices outside this set would exist). The sum of their capacities is exactly f. Cut these edges, and there is no longer a path from the source to outside this set, and consequently, to the sink. Thus, we have found a cut of size f, which is the size of the maximum flow. Therefore, maximum flow is equal to minimum cut.

Ford-Fulkerson Algorithm for Maximum Flow
----------------------------------------
We try to find an augmenting path from the source to the sink and use it to add one unit to the flow. We continue this process until no more augmenting paths exist. The resulting flow will have a cut of its size. Since we know that all cuts are greater than or equal to all flows, the flow we found is definitely the maximum flow.

The following code snippet is an implementation of this algorithm. For simplicity, instead of separately checking for paths in the forward and reverse directions, for each edge, we add a reverse edge with weight 0. Whenever flow passes through an edge, we decrease its capacity and add to the capacity of its reverse (dual) edge.

.. code-block:: cpp

  int cnt, head[M], pre[M], cap[M], to[M], from[M];
  int n,m;
  
  void add(int u, int v, int w){
      // adding the main edge
      from[cnt] = u;
      to[cnt] = v;
      pre[cnt] = head[u];
      cap[cnt] = w;
      head[u] = cnt++;
      // adding the dual edge
      from[cnt] = v;
      to[cnt] = u;
      pre[cnt] = head[v];
      cap[cnt] = 0;
      head[v] = cnt++;
  }
  
  int tnod = 0;
  bitset <M> mark;
  
  // we try to find an augmenting path
  int dfs(int u, int mn){
      mark[u] = 1;
      if(u == tnod)return mn;
      // edges of vertex u are stored in a linked list.
      for (int i = head[u]; i != -1; i = pre[i]){
          // if the target edge has no capacity, we ignore it
          if (cap[i] == 0 || mark[to[i]]) continue;
          // we try to find a flow to the sink
          int s = dfs(to[i], min(mn,cap[i]));
          // if s is not 0, there exists an augmenting path where
          // the least capacity edge has s units of capacity
          if (s){
              // decrease capacity of edge by s units
              cap[i] -= s;
              // add s units to the capacity of the dual edge
              cap[i^1] += s;
              // declare that an s-unit path has been found
              return s;
          }
      }
      // no path found 
      return 0;
  }
  
  int maxflow(){
      int flow = 0;
      while(1){
          mark &= 0;
          int s = dfs(0, inf);
          // if no path was found, flow = maxflow
          if (!s) return flow;
          flow += s;
      }
  }

In this algorithm, we have used the DFS algorithm to find an augmenting path. This algorithm adds at least one unit to the existing flow at each step, and since DFS has linear time complexity, this algorithm has a time complexity of :math:`O(ef)`, where e is the number of edges and f is the maximum flow value. If we used the BFS algorithm instead of DFS, a bound of :math:`O(ve^2)` has also been proven, which we will not delve into its proof.

Finding Vertex and Edge Connectivity
------------------------------------
Using the maximum flow algorithm, vertex and edge connectivity can be found in polynomial time.

To find the edge connectivity, for each edge, we add two directed edges with weight 1 in opposite directions between the two vertices. Then, we find the maximum flow between every pair of vertices, which is also equal to the minimum cut. Given that the minimum cut does not cut both directions of an edge, the minimum cut of this graph is equal to that of the undirected graph. And every cut disconnects two vertices, so it is greater than the edge connectivity of the graph. Since the minimum number of edges required to disconnect a graph separates two vertices, the minimum of these cuts is the edge connectivity of the graph. The time complexity of this algorithm is :math:`O(v^3e)` because the answer is less than the number of vertices.

To find the vertex connectivity of a graph, we construct a new graph where each vertex in the original graph is represented by two vertices: an 'in' vertex and an 'out' vertex. For each edge in the original graph, we add two edges: from the corresponding 'in' vertex to the corresponding 'out' vertex. For each original vertex, we also add an edge from its 'in' vertex to its 'out' vertex. Edges corresponding to the original graph's edges have infinite capacity, and edges within each split vertex (from 'in' to 'out') have capacity 1. To determine how many vertices need to be removed to disconnect two given vertices, we can find the minimum cut between the corresponding 'out' vertex of the source and 'in' vertex of the sink in this new graph. We calculate this value for every pair of vertices, and the vertex connectivity is obtained. The time complexity of this algorithm is :math:`O(v^3e)` because the answer is less than the number of vertices.