DFS
=========

The DFS algorithm is one of the graph traversal methods and one of the simplest and most fundamental graph algorithms. Despite its simplicity, this algorithm has interesting features and, contrary to popular belief, has numerous applications in solving both theoretical and practical problems!

First Problem
-------------

Imagine you are stuck in a maze, which can be represented as a graph. That is, each vertex of the graph represents a room, and each edge represents a corridor between two rooms. Your memory is strong enough that if you enter a room you've visited before, you can recognize it as a repeated room. When you are in a room, you can only see the adjacent corridors. You also have a string with you; one end is tied to your starting room, and the other end is in your hands. A treasure is located in one of the graph's vertices. Your goal is to find the treasure. How do you do it?

Finding the treasure is as simple as executing the following algorithm. Perform the algorithm below until you reach the treasure:

- If all adjacent rooms have been visited, go back to the room from which you first entered the current room. (Simply follow the string in your hand).
- Otherwise, go to one of the adjacent rooms that has not been visited.

Why does this algorithm solve our problem? The key point is that when we enter a room for the first time, we make every effort to find a path to the treasure from that room. Consequently, when all adjacent rooms have been visited and we follow the string back, we can conclude that no path to the treasure exists from that room. Therefore, we should never enter this room again. (And this logic of not re-entering a visited room stems from this very principle).

The problem can also be viewed from a different perspective. For any edge :math:`uv`, if we visit one of :math:`u,v`, we will definitely visit the other as well. (Because we only finish with a vertex when all its neighbors have been visited). Consequently, if we visit one vertex in a connected component, we will visit all other vertices in that component.

Connected Components
------------------

Given a graph :math:`G` as input, you need to find the number of its connected components.

What we examine in this section is a general overview of the DFS algorithm. Assume a `mark` array indicates which vertices have been visited, and initially, all its entries are `false`. Now, our algorithm will be as follows:

.. code-block:: cpp

  void dfs(int u){
     mark[u] = true;
     for(int y : g[u])
	      if(mark[y] == false)
             dfs(y);
  }

Use the intuition gained from solving the problem above. When `dfs(u)` is called, the algorithm recursively attempts to visit all vertices reachable from :math:`u`. Then, `dfs(u)` finishes, and we return to a vertex named :math:`par` from which we first reached :math:`u`.

Consequently, it can be seen that after executing this function, all vertices belonging to the connected component of the starting vertex will be visited. So, to solve the problem, it is sufficient to select a vertex, say :math:`y`, whose `mark` value is `false` at each step. Then, execute `dfs(y)` and increment the solution count.

DFS Tree
-----------------

Beyond merely traversing our graph, the DFS algorithm performs this traversal in a specific way! Now, let's become familiar with some interesting features of this traversal.

Assume the graph edges are initially blue. Now, whenever the program is at vertex :math:`v` and traverses edge :math:`uv` to reach a new vertex :math:`u`, color the edge :math:`uv` red.

Initially, note that the red edges form a tree! This is because each time an edge is colored red, one of its endpoints is connected to a vertex we haven't visited before. Thus, it's as if we are adding leaves to this tree one by one! This tree, obtained from the DFS algorithm, is called the DFS tree. An interesting feature of DFS is that when the execution of `dfs(u)` begins, vertex :math:`u` is just a leaf in the red tree, and by the time `dfs(u)` finishes, the subtree rooted at :math:`u` has been fully constructed.

So, you can see that after running the DFS algorithm on a connected graph, we will obtain a spanning tree of this graph. Root this spanning tree at the starting vertex.

Now, pay attention to an interesting property that arises regarding the blue edges.

We call an edge :math:`uv` a back edge if one of :math:`u,v` is an ancestor of the other. Otherwise, we call this edge a cross edge. (Note: while sometimes `tree edges` are considered a separate category, and the remaining edges are called `back edges`, in this context (undirected graphs), all non-tree edges are `back edges`. Therefore, we effectively classify edges into two categories: `tree edges` and `back edges`, implying no `cross edges`.)

We claim that for any DFS tree, all edges of the graph are back edges!

.. figure:: /_static/dot/Back_Edge.svg
   :width: 50%
   :align: center
   :alt: If the user's internet is trash, this will show up

To prove that all edges are back edges after a DFS traversal, consider an arbitrary edge :math:`uv`. Without loss of generality, assume that in the algorithm, we first entered vertex :math:`u`. In this case, at the start of `dfs(u)`, vertex :math:`v` has not yet been visited. Furthermore, by the time `dfs(u)` finishes, vertex :math:`v` must have been visited (because it is adjacent to vertex :math:`u`). Therefore, if you consider the DFS tree, vertex :math:`v` must be within the subtree of :math:`u`! Consequently, :math:`u` is an ancestor of :math:`v`, so edge :math:`uv` will be a back edge.

In the future, we will make extensive use of this theorem: that after running DFS, all edges are back edges!

Maximal Path and DFS
-------------------------

In Chapter 1, we became familiar with proofs that were carried out using maximal paths. Here, we learn that instead of using maximal paths, we can use the leaves of a DFS tree (which provides much stronger intuition)!

After performing DFS on the graph, let :math:`back_u` denote the number of back edges for which :math:`u` is the lower vertex (i.e., the descendant endpoint). Note that, according to our definition, the edges of the DFS tree itself are also considered back edges. Furthermore, we denote the height of vertex :math:`u` in the tree as :math:`h_u`.

The following two theorems are easily derived from the specific structure of the tree (the second theorem holds assuming the graph is simple).

- :math:`\sum back_u = m`
- :math:`\forall_u back_u \leq h_u`

Path of length :math:`\delta`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We prove that a simple graph has a path of length at least :math:`\delta`. It suffices to prove that the height of the DFS tree is at least :math:`\delta`. Consider an arbitrary leaf, say :math:`u`. It is clear that :math:`back_u \geq \delta`, which implies :math:`h_u \geq \delta`, easily yielding our claim!

Path of length :math:`\frac m n`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We prove that a simple graph has a path of length at least :math:`\frac m n`. Similar to the above, we prove that the height of the DFS tree is at least :math:`\frac m n`. For the proof, we use contradiction. Assume that the height of every vertex is less than :math:`\frac m n`. We have:

:math:`m = \sum back_u \leq \sum h_u < n \times \frac m n = m \Rightarrow m < m`

which gives us a contradiction. Therefore, there exists a vertex with height at least :math:`\frac m n`, which proves our assertion.

Leaves and Height, Independent Set and Longest Path!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Assume that after applying the DFS algorithm, the height of the tree becomes :math:`H` (in fact, :math:`H` is the maximum value among all :math:`h_u`). Also, let :math:`S` be the number of leaves.

Here, we prove that :math:`H \times S \geq n-1`.

For each leaf of the tree, traverse the path from this vertex to the root, and place a stone on every vertex along this path except the root. In this case, for each leaf like :math:`u`, :math:`h_u` stones are added to the total count. On the other hand, we placed at least one stone on every vertex except the root, so the total number of stones is at least :math:`n-1`. Thus, we can write:

:math:`n-1 \leq \sum h_u \leq H \times S`

which proves our assertion. However, so far, we haven't used a specific property derived from the DFS tree! The interesting point is that the leaves of a DFS tree form an independent set. (Because an edge between two leaves would create a cross edge).

Consequently, if the size of the maximum independent set is :math:`S^{\prime}`, then :math:`S \leq S^{\prime}` holds.

Similarly, if the length of the longest path in this graph is :math:`H^{\prime}`, then :math:`H \leq H^{\prime}` holds.

So now we have arrived at the interesting inequality: :math:`n-1 \leq H \times S \leq H^{\prime} \times S^{\prime}`!

The interesting point is that both problems of finding a maximum independent set and the longest path in a graph are NP-hard! But with the method we presented, we can provide either an independent set of size at least :math:`\sqrt{n-1}` or a path of length at least :math:`\sqrt{n-1}`!

Non-cut Vertex
~~~~~~~~~~~~~~~~

We prove that every graph with :math:`n > 1` has at least two non-cut vertices.

It suffices to perform DFS on the graph. Then, each of the leaves of the DFS tree will be a non-cut vertex (furthermore, if we remove these two vertices together, the graph does not become disconnected). This is because the edges of the DFS tree keep the rest of the graph connected (and removing a leaf from a tree does not break its connectivity). Also, every tree with :math:`n>1` has at least two leaves, which proves our assertion. Of course, in this problem, there was no need to use a DFS tree specifically; any arbitrary spanning tree would have solved the problem for us.

Tree Traversal
--------------------

One of the special cases of graph traversal is tree traversal. In this section, we see that tree traversal can be performed more simply with the DFS algorithm. For example, we no longer need a `mark` array. This is because the only neighbor of a vertex that has been previously visited is its parent.

Additionally, other information about the tree can be gathered concurrently with the DFS execution. For example, in the code below, after executing DFS on the tree, the number of vertices in each vertex's subtree is stored in the `sz` array, and the height of each vertex is stored in the `h` array.

Note that we assumed the tree vertex indices start from 1, and there is no vertex with index 0.

.. code-block:: cpp
  
  const int maxn = 1e5 + 10;

  vector <int> g[maxn];
  int sz[maxn], h[maxn];

  void dfs(int u, int par = 0){
     h[u] = h[par] + 1;
     sz[u] = 1;
     for(int y : g[u]){
	 if(y != par){
             dfs(y, u);
             sz[u] += sz[y];
         }
     }
  }