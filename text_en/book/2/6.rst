الگوریتم پیدا کردن قطر درخت
===========================

یکی دیگر از مسائلی که در حالت کلی گراف np است اما در درخت ها به سادگی حل می شود مسئله پیدا کردن بلندترین مسیر است! از آنجایی که در درخت ها مسیر بین هر دو راس یکتا است می توان نتیجه گرفت قطر درخت همان بلندترین مسیر درخت می باشد. در این بخش روش های پیدا کردن قطر درخت را با پیچیدگی زمانی :math:`O(n)` بررسی می کنیم.

استفاده از dp
-------------------

درخت را از راس 1 ریشه دار کنید. با استفاده از برنامه نویسی پویا دو متغیر زیر را به ازای هر راس :math:`u` به دست می آوریم.

- مقدار :math:`dp_u` برابر است با بیشترین فاصله راس :math:`u` با یک راس درون زیردرخت خود :math:`u`. 
- مقدار :math:`ans_u` برابر است با اندازه قطر در زیردرخت :math:`u`.

واضح است که جواب مسئله برابر است با :math:`ans_1`. حالا تنها مسئله باقی مانده این است که چگونه این دو متغیر را به دست آوریم.

برای به دست آوردن :math:`dp_u` کافی است توجه کنید که در اولین حرکت از :math:`u` به یکی از بچه هایش می رویم. پس باید به بچه ای برویم که مقدار :math:`dp` آن بیشینه است. 

برای به دست آوردن :math:`ans_u` حالت بندی کنید که راس :math:`u` درون قطر باشد یا نباشد.

- اگر راس :math:`u` درون قطر نباشد مقدار :math:`ans_u` برابر با بیشینه :math:`ans` بچه های :math:`u` خواهد بود زیرا که قطر کاملا درون یکی از بچه ها خواهد بود.
- در غیر اینصورت اگر راس :math:`u` انتهای قطر باشد جواب برابر با :math:`dp_u` خواهد بود.
- در غیر اینصورت راس :math:`u` باید وسط یک مسیر باشد. حالت بندی کنید که دو سر آن به کدام یکی از بچه ها برود. اگر به بچه :math:`a, b` برود جواب برابر با :math:`2 + dp_a + dp_b` خواهد بود. پس کافیست :math:`a, b` را دو بچه ای انتخاب کنیم که مقدار :math:`dp` آن ها بیشینه است.

در کد زیر در :math:`mx1, mx2` به ترتیب راس های با بیشترین :math:`dp` را نگه داری می کنیم.

.. code-block:: cpp
    
    const int maxn = 1e5 + 10;

    vector<int> g[maxn];
    int dp[maxn], ans[maxn];

    void dfs(int u, int par = 0){
        int mx1 = -1, mx2 = -1;
        for(int y : g[u]){
            if(y != par){
                dfs(y, u);
                dp[u] = max(dp[u], 1 + dp[y]);
                ans[u] = max(ans[u], ans[y]);
                if(mx1 == -1 || dp[mx1] < dp[y]){
                    mx2 = mx1;
                    mx1 = y;
                }
                else if(mx2 == -1 || dp[mx2] < dp[y])
                    mx2 = y;            
            }
        }
        ans[u] = max(ans[u], dp[u]);
        if(mx1 != -1 && mx2 != -1){
        ans[u] = max(ans[u], 2 + dp[mx1] + dp[mx2]);
    }


پس توانستیم الگوریتمی ارائه دهیم که با پیچیدگی زمانی :math:`O(n)` قطر درخت را پیدا می کند.

dfs up/down
-----------------------

گاهی هدف ما به دست آوردن یک متغیر مثل :math:`dp` به ازای هر راس درخت است اما حساب کردن مقدار :math:`dp_u` نیاز به داشتن مقدار :math:`dp` تمام مجاور های راس :math:`u` (و نه فقط بچه های :math:`u`) دارد.

ساده ترین مثال برای معرفی این تکنیک مسئله پیدا کردن بیشترین فاصله از هر راس است. فرض کنید می خواهیم به ازای هر راس :math:`u` خروج از مرکز این راس را داشته باشیم. جواب راس :math:`u` را :math:`ans_u` بگیرید. برای به دست آوردن جواب یک راس می توان به راحتی درخت را از این ارتفاع آویزان کرد و در :math:`O(n)` ارتفاع درخت را حساب کرد. اما آیا می توان مسئله را به ازای تمام راس با هم در :math:`O(n)` حل کرد؟

اولین مشکل ما این است که چون حساب کردن جواب یک راس به داشتن جواب مجاور هایش نیاز دارد نمی دانیم که محاسبه را از کجا شروع کنیم!

درخت را از یک راس دلخواه ریشه دار کنید. شکاندن مسئله به دو بخش می تواند مفید باشد. فرض کنید :math:`dpDown_u` برابر است با بیشترین فاصله از راس :math:`u` به راسی درون زیردرخت راس :math:`u`. همچنین :math:`dpUp_u` برابر است با بیشترین فاصله از راس :math:`u` به راسی خارج از زیردرخت راس :math:`u` (یعنی در اولین گام باید به پدر :math:`u` برویم). واضح است که جواب راس :math:`u` برابر با بیشینه دو عدد :math:`dpDown_u` و :math:`dpUp_u` است.

همانطور که در قسمت بالا بررسی کردیم :math:`dpDown_u` را می توان از روی :math:`dpDown` بچه های راس :math:`u` حساب کرد.

برای حساب کردن :math:`dpUp_u` توجه کنید که بعد از اینکه از :math:`u` به پدر :math:`u` رفتیم می توانیم دو راه در پیش بگیریم.

- می توانیم باز هم به بالا برویم. در اینصورت جواب برابر با :math:`1 + dpUp_{par}` است(فرض کنید :math:`par` پدر راس :math:`u` است).
- می توانیم به پایین برویم یعنی به یکی از برادر های :math:`u` مثل :math:`w` بریم. سپس باید پایین برویم. در اینصورت جواب برابر با :math:`2 + dpDown_w` می باشد.

نکته کلیدی این است که نیاز نیست هر بار تمام برادر های :math:`u` را بررسی کنیم که راس با :math:`dpDown` بیشینه (همان :math:`w` را پیدا کنیم). کافی است به ازای :math:`par` تنها یک بار دو بچه ای که :math:`dpDown` آن ها بیشینه است را به دست بیاوریم. همواره راس :math:`w` یکی از دو بچه :math:`par` است که :math:`dpDown` آنها بیشینه است. (چرا؟)


پس فهمیدیم که به چه صورت باید متغیر ها را به دست بیاوریم. اما همچنان یک مشکل حل نشده باقی مانده است. به چه ترتیبی باید به دست آوردن مقادیر را انجام دهیم. برای به دست آوردن :math:`dpDown` نیاز داریم که مقادیر بچه ها و برای به دست آوردن :math:`dpUp` نیاز داریم که مقادیر پدر را داشته باشیم. پس از کدام یک باید شروع کنیم؟

جواب ساده و هوشمندانه است. می توانیم طی دومرحله مقادیر را به دست بیاوریم. یک بار :math:`dpDown` ها را با استفاده از dfsDown و سپس :math:`dpUp` ها را با استفاده از dfsUp به دست بیاوریم! نکته اینجاست که در dfsDown ابتدا مقدار بچه ها به دست می آیند سپس مقدار راس فعلی. اما در dfsUp ابتدا مقدار پدر به دست می آید سپس مقدار بچه ها از روی پدر به دست می آیند!

توجه کنید که در تابع dfsUp وقتی روی یک راس هستیم فرض کرده ایم که :math:`dpUp` آن راس به دست آمده است و سپس :math:`dpUp` بچه های آن را به دست می آوریم.

.. code-block:: cpp
  
  const int maxn = 1e5 + 10;

  vector<int> g[maxn];
  int dpUp[maxn], dpDown[maxn];

  void dfsDown(int u, int par = 0){ // aval bayad in taabe ra ejra konim
      for(int y : g[u]){
          if(y != par){
              dfsDown(y, u);
              dpDown[u] = max(dpDown[u], dpDown[y] + 1);
          }
      }
  }
  void dfsUp(int u, int par = 0){
     int mx1 = -1, mx2 = -1;
     for(int y : g[u]){
	 if(y != par){
             if(mx1 == -1 || dpDown[mx1] < dpDown[y]){
                  mx2 = mx1;
                  mx1 = y;
             }
             else if(mx2 == -1 || dpDown[mx2] < dpDown[y]){
                  mx2 = y;
             }            
         }
     }
     for(int y : g[u]){
	 if(y != par){
              if(y == mx1){
                  dpUp[y] = dpUp[u] + 1;
                  if(mx2 != -1)
                      dpUp[u] = max(dpUp[u], doDown[mx2] + 2);
              }
              else{
                  dpUp[y] = max(dpUp[u]+1, doDown[mx1] + 2);
              }
              dfsUp(y, u);
         }
     }
  }


یک الگوریتم ساده تر
---------------------------
قطر درخت یک خاصیتی دارد که به ما کمک می کند تا آن را ساده تر پیدا کنیم. آن
خاصیت این است: دور ترین راس نسبت به هر راس، سر یکی از قطر های درخت است.

برای اثبات، درخت را از این راس ریشه دار کنید. یکی از قطر های درخت را در
نظر بگیرید. این قطر که یک مسیر هم هست، دقیقا یک راس دارد که نزدیک ترین راس
به ریشه است. (پایین ترین جد مشترک سر و ته مسیر) اگر دور ترین راس مورد نظر
ما درون زیردرخت این راس باشد، یکی از شاخه ها را حذف می کنیم و شاخه مربوط به
این راس را اضافه می کنیم و طول مسیر کوچک تر نمی شود پس هم چنان قطر می ماند. حالت
دیگر ممکن نیست چون در این صورت از راس دورتر نسبت به جد مشترک شروع کرده و به این
راس می رویم و قطر بزرگ تری پیدا می شود که تناقض است. پس این راس سر یکی از قطر
های درخت است.

از این خاصیت می توان استفاده کرد و قطر درخت را پیدا کرد. تابعی می نویسیم که
یک راس ورودی بگیرد و به کمک الگوریتم دی اف اس یکی از دور ترین رئوس نسبت به این
راس را برگرداند. این تابع را از یک راس دلخواه اجرا می کنیم و نتیجه را
:math:`u`
می نامیم. یکبار هم این تابع را از
:math:`u`
اجرا می کنیم و نتیجه را
:math:`v`
می نامیم. چون از قضیه بالا می دانستیم که راس
:math:`u`
سر یکی از قطر های درخت است، پس مسیر
:math:`uv`
یکی از قطر های درخت است.

Algorithm for Finding the Diameter of a Tree
============================================

Another problem that is NP-hard for general graphs but easily solvable for trees is finding the longest path! Since in trees, the path between any two vertices is unique, it can be concluded that the diameter of a tree is its longest path. In this section, we examine methods for finding the diameter of a tree with a time complexity of :math:`O(n)`.

Using DP
-------------------

Root the tree at vertex 1. Using dynamic programming, we obtain the following two variables for each vertex :math:`u`.

- The value :math:`dp_u` is the maximum distance from vertex :math:`u` to a vertex within its own subtree rooted at :math:`u`.
- The value :math:`ans_u` is the diameter of the subtree rooted at :math:`u`.

It is clear that the answer to the problem is :math:`ans_1`. Now the only remaining question is how to obtain these two variables.

To obtain :math:`dp_u`, it's sufficient to note that the first move from :math:`u` is to one of its children. So, we should go to the child whose :math:`dp` value is maximal.

To obtain :math:`ans_u`, consider two cases: whether vertex :math:`u` is part of the diameter or not.

- If vertex :math:`u` is not part of the diameter, then :math:`ans_u` will be the maximum of the :math:`ans` values of :math:`u`'s children, because the diameter will be entirely contained within one of the children.
- Otherwise, if vertex :math:`u` is an endpoint of the diameter, the answer will be :math:`dp_u`.
- Otherwise, vertex :math:`u` must be an intermediate vertex on a path. Consider which two children its two ends extend to. If it extends to children :math:`a` and :math:`b`, the answer will be :math:`2 + dp_a + dp_b`. So, it's sufficient to choose :math:`a` and :math:`b` as the two children whose :math:`dp` values are maximal.

In the following code, :math:`mx1` and :math:`mx2` store the vertices with the first and second largest :math:`dp` values, respectively.

.. code-block:: cpp
    
    const int maxn = 1e5 + 10;

    vector<int> g[maxn];
    int dp[maxn], ans[maxn];

    void dfs(int u, int par = 0){
        int mx1 = -1, mx2 = -1;
        for(int y : g[u]){
            if(y != par){
                dfs(y, u);
                dp[u] = max(dp[u], 1 + dp[y]);
                ans[u] = max(ans[u], ans[y]);
                if(mx1 == -1 || dp[mx1] < dp[y]){
                    mx2 = mx1;
                    mx1 = y;
                }
                else if(mx2 == -1 || dp[mx2] < dp[y])
                    mx2 = y;            
            }
        }
        ans[u] = max(ans[u], dp[u]);
        if(mx1 != -1 && mx2 != -1){
        ans[u] = max(ans[u], 2 + dp[mx1] + dp[mx2]);
    }


Thus, we have presented an algorithm that finds the diameter of a tree with a time complexity of :math:`O(n)`.

dfs up/down
-----------------------

Sometimes our goal is to compute a variable like :math:`dp` for each vertex in a tree, but calculating :math:`dp_u` requires knowing the :math:`dp` values of all neighbors of vertex :math:`u` (not just its children).

The simplest example to introduce this technique is finding the maximum distance from each vertex. Suppose we want to find the eccentricity of each vertex :math:`u`. Let the answer for vertex :math:`u` be :math:`ans_u`. To find the answer for a single vertex, one can simply root the tree at this vertex and compute the tree's height in :math:`O(n)`. But can we solve the problem for all vertices simultaneously in :math:`O(n)`?

Our first problem is that since calculating the answer for a vertex requires knowing the answers for its neighbors, we don't know where to start the computation!

Root the tree at an arbitrary vertex. Breaking the problem into two parts can be helpful. Let :math:`dpDown_u` be the maximum distance from vertex :math:`u` to a vertex within :math:`u`'s subtree. Also, let :math:`dpUp_u` be the maximum distance from vertex :math:`u` to a vertex outside :math:`u`'s subtree (meaning the first step must be towards :math:`u`'s parent). It is clear that the answer for vertex :math:`u` is the maximum of :math:`dpDown_u` and :math:`dpUp_u`.

As we discussed in the section above, :math:`dpDown_u` can be computed from the :math:`dpDown` values of :math:`u`'s children.

To compute :math:`dpUp_u`, note that after moving from :math:`u` to its parent :math:`par`, we can take two paths.

- We can continue going up. In this case, the answer is :math:`1 + dpUp_{par}` (assuming :math:`par` is the parent of :math:`u`).
- We can go down, i.e., to one of :math:`u`'s siblings, say :math:`w`. Then we must go further down. In this case, the answer is :math:`2 + dpDown_w`.

The key point is that we don't need to check all of :math:`u`'s siblings every time to find the vertex :math:`w` with the maximal :math:`dpDown` value. It is sufficient to find, for each :math:`par`, only once, the two children whose :math:`dpDown` values are maximal. Vertex :math:`w` will always be one of the two children of :math:`par` with maximal :math:`dpDown` values. (Why?)


So, we understand how to compute these variables. However, one unsolved problem remains. In what order should we compute the values? To compute :math:`dpDown`, we need the values of the children, and to compute :math:`dpUp`, we need the values of the parent. So, which one should we start with?

The answer is simple and clever. We can compute the values in two phases. First, we compute :math:`dpDown` values using `dfsDown`, and then :math:`dpUp` values using `dfsUp`! The point is that in `dfsDown`, the children's values are computed first, then the current vertex's value. But in `dfsUp`, the parent's value is computed first, then the children's values are derived from the parent's.

Note that in the `dfsUp` function, when we are at a vertex, we assume its :math:`dpUp` value has already been computed, and then we compute the :math:`dpUp` values of its children.

.. code-block:: cpp
  
  const int maxn = 1e5 + 10;

  vector<int> g[maxn];
  int dpUp[maxn], dpDown[maxn];

  void dfsDown(int u, int par = 0){ // aval bayad in taabe ra ejra konim
      for(int y : g[u]){
          if(y != par){
              dfsDown(y, u);
              dpDown[u] = max(dpDown[u], dpDown[y] + 1);
          }
      }
  }
  void dfsUp(int u, int par = 0){
     int mx1 = -1, mx2 = -1;
     for(int y : g[u]){
	 if(y != par){
             if(mx1 == -1 || dpDown[mx1] < dpDown[y]){
                  mx2 = mx1;
                  mx1 = y;
             }
             else if(mx2 == -1 || dpDown[mx2] < dpDown[y]){
                  mx2 = y;
             }            
         }
     }
     for(int y : g[u]){
	 if(y != par){
              if(y == mx1){
                  dpUp[y] = dpUp[u] + 1;
                  if(mx2 != -1)
                      dpUp[u] = max(dpUp[u], doDown[mx2] + 2);
              }
              else{
                  dpUp[y] = max(dpUp[u]+1, doDown[mx1] + 2);
              }
              dfsUp(y, u);
         }
     }
  }


A Simpler Algorithm
---------------------------
The diameter of a tree has a property that helps us find it more simply. That
property is: the farthest vertex from any given vertex is an endpoint of one of the tree's diameters.

To prove this, root the tree at this vertex. Consider one of the tree's diameters.
This diameter, which is also a path, has exactly one vertex that is closest
to the root. (The lowest common ancestor of the path's endpoints) If our farthest
vertex is within the subtree of this common ancestor, we remove one branch and
add the branch corresponding to this vertex, and the path length does not decrease,
so it remains a diameter. The other case is not possible, because in that scenario,
we would start from a vertex farther from the common ancestor and reach this
vertex, finding a larger diameter, which is a contradiction. Therefore, this
vertex is an endpoint of one of the tree's diameters.

This property can be used to find the diameter of a tree. We write a function that
takes a vertex as input and, using a DFS algorithm, returns one of the farthest
vertices from this input vertex. We execute this function starting from an
arbitrary vertex and call the result :math:`u`. We then execute this function
once more, starting from :math:`u`, and call the result :math:`v`. Since we know
from the above theorem that vertex :math:`u` is an endpoint of one of the tree's
diameters, the path :math:`uv` is one of the tree's diameters.