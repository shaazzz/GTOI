Relationship between LCA and RMQ
==================

Next, we will examine another problem that, at first glance, seems unrelated to the topic at hand, but has a close connection to the LCA problem. We will then present a solution of order :math:`O(n*lg(n)+q)` by solving this problem, which performs better than the previous approach if the number of queries is large relative to the number of tree vertices.

In this problem, you are initially given an array of n elements, and then q queries are performed. In each query, you are given the two endpoints of a range, and you are asked for the minimum element within this range. Using the segment tree you previously studied, you can solve this problem in :math:`O(n+q*lg(n))`. If, instead of the minimum element, the sum of elements were requested, you could easily solve the problem in :math:`O(n+q)`. This problem is called RMQ, which stands for Range Minimum Query.

Converting RMQ to LCA
---------------------
Here, we construct a Cartesian tree from the input array. A Cartesian tree is a binary tree where each array element corresponds to a node in the tree. The node corresponding to the minimum element of the array is at the root. The left child's subtree is equivalent to the Cartesian tree of the range from the beginning up to the minimum element, and the right child's subtree is equivalent to the Cartesian tree of the range from the minimum element to the end. You can see an example of a Cartesian tree in the figure below.

.. figure:: /_static/dot/Cartesian_Tree.svg
   :width: 40%
   :align: center
   :alt: An example image of a Cartesian tree

Using the fact that the Lowest Common Ancestor (LCA) lies within the range between these two nodes, prove that to find the minimum in a range, one can find the Lowest Common Ancestor in the Cartesian tree. We will then show, by presenting an :math:`O(n)` method for constructing a Cartesian tree, that if a solution for RMQ exists, a solution with the same complexity will exist for LCA.

Linear-Time Cartesian Tree Construction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A Cartesian tree can be constructed using a stack. Inside the stack, we maintain nodes whose parents are not yet confirmed, in sorted order (both by value and by position). We start with an empty stack and begin traversing the array. For each element we encounter, we pop elements from the top of the stack as long as they are smaller than the current element. The parents of all popped elements are now determined, as no element encountered later in the array can be their parent. The parent of each popped node is the previous node in the stack, and the parent of the last popped node is the current input node. We then push the current node onto the stack and move to the next node. At the end, we obtain a forest whose roots are in the stack. These nodes in the stack are also in order such that each is the parent of the previous node (since there are no new nodes to process), and the root of the entire tree is the last element in the stack, which is also the minimum element of the array.

Converting LCA to RMQ
---------------------
We perform a DFS traversal on the tree. Upon entering each node, we add it to an array and set its value to its depth. Upon exiting each node, we similarly add its parent to the array. Each node will have a number of corresponding entries in the array equal to its number of children plus one. To find the Lowest Common Ancestor (LCA), it is sufficient to calculate the minimum value among the elements corresponding to the two nodes whose LCA we want to find, and then see which node it corresponds to. The proof of this statement is left to the reader. Therefore, if a solution exists for one of the LCA or RMQ problems, a solution with the same complexity exists for the other.

Solving RMQ with Sparse Table
--------------------------------
A Sparse Table is a special type of dynamic programming where the second dimension has a logarithmic size relative to the first dimension. This table is used in various problems, and here we will use it to solve this problem. Let :math:`dp_{i,j}` be the minimum element in the range :math:`[i,i+2^j)`. If we have this dp table, we can answer queries in :math:`O(1)`. This is done by finding `j` such that the length of the desired range is between :math:`2^j` and :math:`2^{j+1}`. Then the answer to the problem is:

.. math:: min(dp_{l,j},dp_{r-2^j,j})

Calculating this table is also possible in :math:`O(n*lg(n))`. We just need to start from `j=0` and go up to the logarithm of the array length. Each `j` is computed from the previous `j` as follows:

.. math:: dp_{i,j}=min(dp_{i,j-1},dp_{i+2^{j-1},j-1})

Thus, for RMQ and LCA, we have an algorithm with a time complexity of :math:`O(n*lg(n)+q)`, which performs better than the previous algorithm of :math:`O(n+q*lg(n))` when `n` is smaller than `q`.
