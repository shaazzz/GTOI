
Virtual Tree
============

Consider a tree, say :math:`T`. An arbitrary subset of vertices of :math:`T`, let's call it :math:`A`, is called a virtual tree if it is closed with respect to :math:`lca`. That is, the :math:`lca` of any two arbitrary vertices from :math:`A` must also be within :math:`A`.

.. figure:: /_static/virt_tree_intro.png
   :width: 80%
   :align: center
   :alt: A placeholder image for when the internet connection is poor

Why is a Virtual Tree important for us?
---------------------------------------

First Problem
~~~~~~~~~~~~~~

Suppose we have colored a subset of vertices of a tree, say :math:`B`, black. Now we want to color some uncolored vertices black such that all black vertices become connected. We also want to minimize the final number of black vertices. Find this minimum number.

It is clear that to solve this problem, we must color all vertices on the path between at least two black vertices. However, the important question is how to find the number of these vertices such that our time complexity is related to :math:`|B|` and completely independent of :math:`n`. (i.e., if the given set is small, we should respond quickly, and vice versa).

Assume the answer is :math:`ans`. Note that :math:`ans` itself might be very large and not of the order of :math:`|B|`. For example, if our tree is a path and :math:`B` is the set of the two end vertices of this path, then :math:`ans=n`. So we cannot work with a time complexity of :math:`ans`.

Now pay attention to this interesting point. Consider the final state of the tree (where black vertices are connected) and suppose we define the "black degree" of each vertex :math:`u` as the number of adjacent black vertices to the black vertex :math:`u`. As you probably gathered from the path example, many of the vertices we are forced to color black might have a black degree of 2!

We perform an equivalent transformation on the problem to make our work easier. Hang the tree from one of the vertices in :math:`B`. Now, for every vertex :math:`u` in :math:`B`, all vertices from :math:`u` to the root must be colored black, and this black coloring is also sufficient (i.e., the resulting structure satisfies the connectivity condition).

This is where our problem becomes somewhat similar to the virtual tree problem. Suppose we added enough vertices to set :math:`B` such that it became closed with respect to :math:`lca`. That is, as long as there were two vertices :math:`u, v` within :math:`B` such that :math:`lca(u, v)` was not within :math:`B`, we had to color :math:`lca(u, v)` black and add it to :math:`B`.

Now, for every non-root vertex :math:`u`, call its lowest black ancestor its "virtual parent," denoted by :math:`p_u`. Note that the vertices between :math:`u` and :math:`p_u` were the ones we said would have a black degree of 2, and there might be many of them. Now, if we count these vertices for all :math:`u, p_u` pairs (whose number is :math:`h_u - h_{p_u} - 1`) and add this value to the current number of black vertices, we will get the answer to the problem.

In this section, we did not mention several key points. Including:

- How can we find the vertices that, if added to set :math:`B`, form a virtual tree?
- Why is the maximum number of vertices in a virtual tree related only to :math:`B` and not to :math:`n`?

We will answer these questions later. It is also worth noting that the problem we posed in this section can be solved just as easily without changing the root. The root change we performed was merely to simplify the explanations!

Diameter of a Subset
~~~~~~~~~~~~~~~~~~~~

Suppose you are given a tree :math:`T` and a set :math:`B`. Now you need to name two vertices within :math:`B` whose distance from each other is maximal.

We discussed the algorithm for finding the diameter of a tree using DFS in Chapter 2. Here, if the vertices of :math:`B` are connected, we can use the same DFS algorithm. What if they are not connected? Our current concern is similar to the previous problem. That is, for any two vertices :math:`u,v` from :math:`B`, we want to add all vertices present on the path :math:`uv` to :math:`B` and then run the DFS algorithm on the resulting graph.

However, this is not a good method because, as stated in the previous problem, the number of vertices we need to add to :math:`B` might be very large.

Here, just like the previous problem, we use a virtual tree. That is, we expand the set :math:`B` until it becomes a virtual tree. Now, in a new graph, we draw an edge between each vertex and its virtual parent with a weight of :math:`h_u - h_{p_u}`. The new tree we have is our virtual tree! By finding the diameter in this tree, we find the maximum distance between the vertices of the original :math:`B`.

Algorithm
---------------

Introduction
~~~~~~~~~~~

As you probably intuited from the previous problems, a virtual tree can represent a small subtree of our tree. The interesting point is that this subtree is not necessarily connected, but if we construct a new tree where everyone is connected to their virtual parent, we get a new tree. Then, we can consider only this new tree from now on and perform our computations on it.

.. figure:: /_static/transform_to_virt_tree.png
   :width: 80%
   :align: center
   :alt: A placeholder image for when the internet connection is poor

In this section, we assume that the set of vertices :math:`B` is given to us, and we want to add some vertices to it to make :math:`B` a virtual tree. We call this process "expansion" here.

First Attempt
~~~~~~~~~~~~

In the first step, for every two vertices in set :math:`B`, say :math:`a, b`, we can compute :math:`lca(a, b)` and call it set :math:`C`.

Now we claim that :math:`D = B \cup C` is a virtual tree. To prove this, note that every vertex in :math:`D` has a member of :math:`B` within its subtree. (Why?) Now, suppose there are two vertices :math:`a, b \in D` such that their :math:`lca` is not within :math:`D`. Let the vertices in :math:`B` within the subtrees of :math:`a, b` be denoted by :math:`a\prime, b\prime` respectively. If :math:`lca(a, b)` has not been added to :math:`D`, then :math:`lca(a\prime, b\prime)` will be the same as :math:`lca(a, b)`, which is in :math:`C`, contradicting our initial statement.

So, it is only necessary to perform these calculations for every two vertices within :math:`B` (and there is no need to check the :math:`lca` of newly added vertices with the others).

A Better Algorithm
~~~~~~~~~~~~~~~~~~

The method we discussed before had high time complexity. If we consider :math:`lca` calculations to be :math:`O(\log n)`, then the above method would be :math:`O(|B|^2)`.

Now we try to find a better method. Consider a vertex named :math:`u` that is not in :math:`B` but must be in the virtual tree. This means :math:`u` has two children :math:`a, b` such that within the subtree of each of :math:`a, b`, there exists one or more vertices from :math:`B` (whose :math:`lca` will be :math:`u`).

Now, note that taking the :math:`lca` of any vertex within the subtree of :math:`a` with any vertex within the subtree of :math:`b` will yield vertex :math:`u`. The problem with the previous algorithm was that in this situation, it computed :math:`u` many times, which was unnecessary. That is, for every ordered pair of vertices from the subtrees of :math:`a` and :math:`b`, it calculated vertex :math:`u` once, and this is precisely what increased the time complexity of the previous method.

The interesting point is that if we can assign an initial order to the vertices of tree :math:`T` such that **the subtree of each vertex becomes an interval** in this order, then we can use the following method and claim it works correctly:

- Sort the vertices in :math:`B` according to this specified order.
- Now, for every two consecutive vertices in the sorted list we obtained, add their :math:`lca` to set :math:`C`.
- The union of the two sets :math:`B` and :math:`C` forms our virtual tree.

Why does this algorithm work correctly? We said vertex :math:`u` has two children, and within the subtree of each, there exists a vertex from :math:`B`. In the sorted list on which we ran the algorithm, there exists **an interval** corresponding to the subtree of :math:`u`. Among the vertices within this interval, there are definitely two vertices belonging to subtrees of different children of :math:`u` (Why?). Therefore, when we compute :math:`lca`, vertex :math:`u` is added to set :math:`C`! Just as we wanted.

Optimal Order?
~~~~~~~~~~~~~~~~~

In the above algorithm, we magically used an order that had an interesting property. However, we did not provide such an order.

You can construct such an order yourself. All methods for constructing such an order are rooted in the DFS algorithm. Why? Because when we want to calculate this order for the subtree of a vertex like :math:`u`, we must first recursively find such an order for the subtrees of all children of :math:`u` and then add vertex :math:`u` somewhere between the intervals of two of its children (or before and after all).

This is exactly what we call `starting-time` or `finishing-time` in DFS, and we discussed it in Chapter 2.

Implementation
~~~~~~~~~~~~~~~~

.. code-block:: cpp
  
  const int maxn = 1e5 + 10, max_log = 20;

  int start_time[maxn], sparse_table[maxn][max_log], h[maxn];
  vector<int> g[maxn];
  int Counter = 0;

  void dfs(int v, int par = 0){
    h[v] = h[par] + 1;
    sparse_table[v][0] = par;
    for(int i = 1; i < max_log; i++){
        sparse_table[v][i] = sparse_table[sparse_table[v][i-1]][i-1];
    }
    start_time[v] = Counter;
    Counter = Counter + 1;
    for(int u : g[v]){
        if(par != u){
            dfs(u, v);
        }
    }
  }

  int lca(int a, int b){
    if(h[a] < h[b])
        swap(a, b);
    for(int i = max_log-1; i >= 0; i--){
        if(h[sparse_table[a][i]] >= h[b])
            a = sparse_table[a][i];
    }
    if(a == b)
        return a;
    for(int i = max_log-1; i >= 0; i--){
        if(sparse_table[a][i] != sparse_table[b][i])
            a = sparse_table[a][i], b = sparse_table[b][i];
    }
    return sparse_table[a][0];
  }
  
  vector<int> build_virtual_tree(vector<int> vec){
    sort(vec.begin(), vec.end(), [](int a, int b){ return start_time[a] < start_time[b]; }); // sort on starting time
    for(int i = vec.size()-1; i > 0; i--){
        vec.push_back(lca(vec[i], vec[i-1]));
    }
    sort(vec.begin(), vec.end(), [](int a, int b){ return start_time[a] < start_time[b]; });
    vec.resize(unique(vec.begin(), vec.end())-vec.begin());
    return vec;
  }

Also, note that if vertex :math:`u` is in the virtual tree and the vertex before it in the `starting-time` order is vertex :math:`v`, then the virtual parent of :math:`u` is :math:`lca(u, v)`. (Why?)

For calculating :math:`lca` in the code above, a method with :math:`O(\log n)` time complexity was used, and finally, finding the expansion of the virtual tree for set :math:`B` was done in :math:`O(|B| \times \log n)` time.