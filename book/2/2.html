

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>فاصله در درخت و گراف &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="درخت ها" href="index.html" />
        <link rel="next" title="شمردن تعداد درخت ها" href="3.html" />
        <link rel="prev" title="خاصیت های مقدماتی" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">انواع گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیرگراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">درخت ها</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف‌جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس و عملیات های روی آن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">دترمینان ماتریس ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">ماتریس وقوع</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">درخت دودویی (Binary Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">درخت جست و جوی دودویی (BST یا Binary Search Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">مسائل np و np کامل</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">تعریف np و np کامل</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">اثبات np کامل بودن مساله sat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">مسائل np کامل گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">درخت مجازی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">درخت پوشای کمینه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">تجزیه سبک سنگین(HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">تطابق</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">چند ماتریس خاص</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">برگه تقلب (Cheat sheet)</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; فاصله در درخت و گراف</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/en/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (English)</a>
        <script>document.getElementById('lang-link').href=`/en${window.location.pathname}`;</script>
        
            <a href="../../_sources/book/2/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="id1">
<h1>فاصله در درخت و گراف<a class="headerlink" href="#id1" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>در این بخش با معرفی فاصله در گراف به بررسی تعریف های مرتبط با فاصله چه در حالت کلی و چه در حالت خاص آن(یعنی در درخت) میپردازیم. در درخت ها صحبت در مورد فاصله به مراتب راحت تر از گراف در حالت کلی است چرا که همانطور که در بخش قبل بررسی کردیم در درخت مسیر بین هر دو راس یکتا است.</p>
<section id="id2">
<h2>فاصله چیست؟<a class="headerlink" href="#id2" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>دو راس <span class="math notranslate nohighlight">\(u,v\)</span> در گراف را در نظر بگیرید. فاصله این دو راس طول (تعداد یال ها) کوتاه ترین مسیر بین این دو راس تعریف می شود.</p>
<p>نکته : اگر دو راس در دو مولفه همبندی جدا باشند فاصله آن ها بینهایت است.</p>
<p>فاصله دو راس <span class="math notranslate nohighlight">\(u,v\)</span> را به صورت <span class="math notranslate nohighlight">\(d(u,v)\)</span> نشان میدهند.</p>
</section>
<section id="id3">
<h2>قطر<a class="headerlink" href="#id3" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>تعریف : قطر گراف برابر است با
<span class="math notranslate nohighlight">\(Max_{u,v} d(u,v)\)</span>
یا به عبارتی ماکسیمم فاصله دو به دو راس ها در گراف.</p>
<p>توجه کنید که قطر بلندترین مسیر نیست و در واقع بلند ترین <strong>فاصله</strong> است ولی در درخت بلندترین مسیر و قطر یکی است زیرا اگر دو سر بلندترین مسیر را بگیرید
چون بین آن دو دقیقا یک مسیر وجود دارد و بلندترین مسیر , آن مسیر است در واقع طول بلندترین مسیر برابر فاصله آن دو راس است پس قطر برابر بلندترین مسیر است.
تفاوت بلند ترین مسیر و قطر جایی به چشم می اید که در حالت کلی  پیدا کردن قطر یک گراف از اوردر چند جمله ای حل میشود ولی پیدا کردن بلند ترین مسیر یک مسئله NP است.</p>
</section>
<section id="id4">
<h2>خروج از مرکز<a class="headerlink" href="#id4" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>اگر نام راس را <span class="math notranslate nohighlight">\(u\)</span> در نظر بگیریم خروج از مرکز <span class="math notranslate nohighlight">\(u\)</span> برابر ماکسیمم <span class="math notranslate nohighlight">\(d(u,v)\)</span> به ازای همه <span class="math notranslate nohighlight">\(v\)</span> هاست.</p>
<p>گراف اگر درخت باشد و درخت را از <span class="math notranslate nohighlight">\(u\)</span> اویزان کنیم خروج از مرکز <span class="math notranslate nohighlight">\(u\)</span> میشود ارتفاع راسی که بیشترین ارتفاع را در درخت دارد.</p>
<p>خروج از مرکز راس <span class="math notranslate nohighlight">\(u\)</span> را با  <span class="math notranslate nohighlight">\(\varepsilon{(u)}\)</span>  نشان میدهند.</p>
</section>
<section id="id5">
<h2>قضیه 2.2.1<a class="headerlink" href="#id5" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>صورت قضیه : در درخت خروج از مرکز یک راس برابر ماکسیمم فاصله آن از دو سر قطر است.</p>
<p>اثبات : برهان خلف میزنیم. فرض کنید راس ما <span class="math notranslate nohighlight">\(a\)</span>  است و دو سر قطر هم راس های <span class="math notranslate nohighlight">\(u , v\)</span> هستند . و راسی که فاصله اش با <span class="math notranslate nohighlight">\(a\)</span> برابر <span class="math notranslate nohighlight">\(\varepsilon(a)\)</span> است <span class="math notranslate nohighlight">\(b\)</span> نام دارد . واضح هم است <span class="math notranslate nohighlight">\(a\)</span> اگر یکی از دو سر قطر بود حکم درست است پس فرض میکنیم هیج یک از دو سر قطر نیست.</p>
<p>درخت را از <span class="math notranslate nohighlight">\(a\)</span> آویزان میکنیم. فرض کنید راس <span class="math notranslate nohighlight">\(mh\)</span> راسی با بیشترین ارتفاع باشد که سه راس <span class="math notranslate nohighlight">\(b,u,v\)</span> داخل زیر درخت آن هستند.
چون <span class="math notranslate nohighlight">\(mh\)</span> بیشترین ارتفاع از پدر های مشترک این سه راس دارد یعنی یا <span class="math notranslate nohighlight">\(mh = b\)</span> است یا بچه ای از <span class="math notranslate nohighlight">\(mh\)</span> که جد <span class="math notranslate nohighlight">\(b\)</span> است در زیر درختش حداقل یکی از دو راس
<span class="math notranslate nohighlight">\(u , v\)</span> را ندارد.که یعنی <span class="math notranslate nohighlight">\(mh = lca(u,b)\)</span>  or <span class="math notranslate nohighlight">\(lca(v,b)\)</span> .بدون از دست دادن کلیت مسئله فرض کنید <span class="math notranslate nohighlight">\(mh = lca(u,b)\)</span>. حال ثابت میکنیم <span class="math notranslate nohighlight">\(d(b,u)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span>
با اثبات این بخش با تناقض بدست امده در طول قطر قضیه اثبات میشود.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(d(b,u)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(mh = lca(b,u)\)</span> <span class="math notranslate nohighlight">\(\longrightarrow\)</span>  <span class="math notranslate nohighlight">\(h(b)+h(u)-2×h(Mh)\)</span> &gt; <span class="math notranslate nohighlight">\(d(u,v)\)</span></p></li>
<li><p>اگر <span class="math notranslate nohighlight">\(mh \neq lca(u,v)\)</span> هم باشد باز جد مشترکشان است پس <span class="math notranslate nohighlight">\(d(u,v)\)</span> <span class="math notranslate nohighlight">\(\leqslant\)</span> <span class="math notranslate nohighlight">\(h(u)+h(v)-2×h(mh)\)</span></p></li>
<li><p>در نتیجه
<span class="math notranslate nohighlight">\(h(B) + h(u) - 2×h(mh) &gt; h(u) + h(v) - 2×h(mh) \longrightarrow h(B) &gt; h(u)\)</span>
که فرض سوال است پس عبارت درست است. با تناقض بدست امده قضیه اثبات شد.</p></li>
</ul>
</section>
<section id="id6">
<h2>شعاع و مرکز<a class="headerlink" href="#id6" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>به راسی که مینیمم خروج از مرکز را را در بین راس های گراف دارد مرکز گراف گوییم و به خروج از مرکز آن شعاع گراف.</p>
</section>
<section id="id7">
<h2>قضیه 2.2.2<a class="headerlink" href="#id7" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li><p>الف) در درخت اگر قطر برابر <span class="math notranslate nohighlight">\(Q\)</span> باشد شعاع برابر <span class="math notranslate nohighlight">\(\lceil{Q/2}\rceil\)</span> است.</p></li>
<li><p>ب) در درخت اگر <span class="math notranslate nohighlight">\(Q\)</span> فرد باشد دو راس وسط مسیر دو سر قطر مرکز هستند و اگر زوج باشد راس وسط قطر.</p></li>
</ul>
<p>اثبات : در ابتدا ثابت میکنیم راسی که در مسیر دو سر قطر نیست نمیتواند مرکز باشد. راسی مانند <span class="math notranslate nohighlight">\(u\)</span> را در نظر بگیرید که در مسیر دو سر قطر نیست و راس <span class="math notranslate nohighlight">\(v\)</span> را راسی از مسیر دو سر قطر در نظر بگیرید که فاصله اش با
<span class="math notranslate nohighlight">\(u\)</span> مینیمم است با توجه به قضیه 2.2.1 میتوان فهمید <span class="math notranslate nohighlight">\(\varepsilon{(u)} = \varepsilon{(v)} + d(u,v)\)</span> پس <span class="math notranslate nohighlight">\(u\)</span> قطعا مرکز نیست.
حال بیایبد راس های درون مسیر دو سر قطر را از یک سر قطر به ترتیب شماره گزاری کنید(یعنی از 0 تا <span class="math notranslate nohighlight">\(Q\)</span>. طبق  قضیه 2.2.1 میدانیم راس خروج از مرکز راس <span class="math notranslate nohighlight">\(i\)</span> ام در مسیر دو سر قطر برابر <span class="math notranslate nohighlight">\(max(i,Q-i)\)</span>
است.میدانیم مینیمم عبارت بالا زمانی است که <span class="math notranslate nohighlight">\(i , Q-i\)</span> کمترین اختلاف را با هم داشته باشند پس</p>
<ul class="simple">
<li><p>اگر <span class="math notranslate nohighlight">\(Q\)</span> زوج باشد جواب میشود  <span class="math notranslate nohighlight">\(max(Q - Q/2 , Q/2)\)</span> = <span class="math notranslate nohighlight">\(Q/2\)</span>  پس شعاع برابر <span class="math notranslate nohighlight">\(Q/2\)</span> است و تنها مرکز هم راس وسط قطر است (راس <span class="math notranslate nohighlight">\(Q/2\)</span> مسیر دو سر قطر.</p></li>
<li><p>اگر <span class="math notranslate nohighlight">\(Q\)</span> فرد باشد شعاع میشود  <span class="math notranslate nohighlight">\(max((Q-1)/2 , (Q+1)/2)\)</span> = <span class="math notranslate nohighlight">\((Q+1)/2\)</span>  و تنها راس هایی در مسیر در سر قطر که چنین ویژگی دارد راس های <span class="math notranslate nohighlight">\((Q-1)/2,(Q+1)/2\)</span>  مسیر دو سر قطر هستند.</p></li>
</ul>
</section>
<section id="id8">
<h2>سنتروید<a class="headerlink" href="#id8" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>به راسی در گراف که مجموع فاصله هایش از دیگر راس ها مینیمم است سنتروید گراف میگویند . به مانند تعاریف بالا سنتروید در درخت نیز دارای ویژگی جالبی است که در قضیه زیر آمده.</p>
</section>
<section id="id9">
<h2>قضیه 2.2.3<a class="headerlink" href="#id9" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li><p>الف) در درخت یک راس سنتروید است اگر و تنها اگر وقتی او را از درخت حذف کنیم سایز هر مولفه کمتر مساوی <span class="math notranslate nohighlight">\(n/2\)</span> باشد.</p></li>
<li><p>ب) در درخت حداکثر دو سنتروید داریم و اگر دو تا باشند گراف زوج راسی است و ان دو به هم یال دارند .</p></li>
</ul>
<p>اثبات : راس ها را شماره گزاری میکنیم و <span class="math notranslate nohighlight">\(a_i\)</span> برابر مجموع فاصله های راس <span class="math notranslate nohighlight">\(i\)</span> از دیگر راس های خواهد بود.حال ابتدا بخش اگر الف را اثبات میکنیم. فرض کنید سنتروید راس <span class="math notranslate nohighlight">\(u\)</span> باشد و وقتی ان را حذف کنیم
مولفه همبندی با سایز بیشتر از
<span class="math notranslate nohighlight">\(n/2\)</span>
بوجود بیاید حال میگویم راسی که از ان مولفه با
<span class="math notranslate nohighlight">\(u\)</span>
همسایه است را در نظر بگیرید و نام آن را
<span class="math notranslate nohighlight">\(v\)</span>
بگزارید . فاصله
<span class="math notranslate nohighlight">\(v\)</span>
از راس های داخل این مولفه همبندی
یکی کمتر از فاصله
<span class="math notranslate nohighlight">\(u\)</span>
از ان ها است و برای دیگر راس ها هم فاصله آن یکی بیشتر از فاصله
<span class="math notranslate nohighlight">\(u\)</span>
است پس
<span class="math notranslate nohighlight">\(a_v = a_u - sz + (n-sz)\)</span>
که <span class="math notranslate nohighlight">\(sz\)</span> برابر سایز آن مولفه همبندی است.
و چون
<span class="math notranslate nohighlight">\(sz &gt; n/2 \longrightarrow n - 2 \times sz &lt; 0 \longrightarrow a_v &gt; a_u\)</span>
با تناقض بدست امده اگر الف اثبات شد.</p>
<p>حال ثابت میکنم هر دو راسی مانند
<span class="math notranslate nohighlight">\(i , j\)</span>
که ویژگی اگر بخش الف را دارند در ان ها
<span class="math notranslate nohighlight">\(a_i = a_j\)</span>
و چون میدانیم سنتروید ما ویژگی اگر الف را دارد پس همه راس ها با ویژگی اگر الف سنتروید هستند.
درخت را از راس
<span class="math notranslate nohighlight">\(i\)</span>
اویزان میکنیم.حال یک متغیر به نام
<span class="math notranslate nohighlight">\(A\)</span>
داریم که وقتی روی راس
<span class="math notranslate nohighlight">\(z\)</span>
هستیم
<span class="math notranslate nohighlight">\(A = a_z\)</span>
و اول کار <span class="math notranslate nohighlight">\(A = a_i\)</span> حال از راس ریشه یعنی <span class="math notranslate nohighlight">\(i\)</span> به سمت راس <span class="math notranslate nohighlight">\(j\)</span> حرکت میکنیم
(یعنی در واقع مسیر بین این دو راس را با شروع از
<span class="math notranslate nohighlight">\(i\)</span>
طی میکنیم) حال زمانی که از یک راس به بچه اش میرویم
<span class="math notranslate nohighlight">\(A\)</span>
به اندازه سایز زیر درخت بچه اش کم میشود
و به اندازه تعداد راس های منهای سایز زیر درخت بچه اش به
<span class="math notranslate nohighlight">\(A\)</span>
اضافه میشود.
ما میدانیم سایز زیر درخت
<span class="math notranslate nohighlight">\(j\)</span>
بیشترمساوی از
<span class="math notranslate nohighlight">\(n/2\)</span>
است زیرا وقتی
<span class="math notranslate nohighlight">\(j\)</span>
را از درخت حذف کنیم سایز مولفه همبندی که پدرش در آن قرار دارد طبق فرض کمتر مساوی
<span class="math notranslate nohighlight">\(n/2\)</span>
است پس تعداد راس های که در این مولفه نیستند(با احتساب <span class="math notranslate nohighlight">\(j\)</span>)
بیشتر مساوی
<span class="math notranslate nohighlight">\(n/2\)</span>
است. پس سایز زیر درخت تمام جد های
<span class="math notranslate nohighlight">\(j\)</span>
که ما طی کردیم هم این بیشتر مساوی بیشتر مساوی
<span class="math notranslate nohighlight">\(n/2\)</span>
است پس میتوان نتیجه گرفت مقدار
<span class="math notranslate nohighlight">\(A\)</span>
همیشه یا کمتر میشود یا تغییر نمیکند.
پس
<span class="math notranslate nohighlight">\(a_i \geq a_j\)</span>
. اگر ما درخت را از
<span class="math notranslate nohighlight">\(j\)</span>
هم اویزان کنیم و مسیر بین ان دو را طی کنیم به نتیجه
<span class="math notranslate nohighlight">\(a_j \geq a_i\)</span>
میرسیم که در نتیجه
<span class="math notranslate nohighlight">\(a_i = a_j\)</span>
است.</p>
<p>حال به اثبات بخش ب میرویم فرض کنید دو راس <span class="math notranslate nohighlight">\(i,j\)</span> سنتروید هستند و درخت را از  <span class="math notranslate nohighlight">\(i\)</span> اویزان کردیم و داریم الگوریتم بالا را طی میکنیم حال میگوییم وقتی از یک راس به بچه اش میرویم <span class="math notranslate nohighlight">\(A\)</span> در صورتی تغییر نمیکند
که سایز زیر درخت بچه دقیقا برابر <span class="math notranslate nohighlight">\(n/2\)</span> باشد و چون سایز زیر درخت <span class="math notranslate nohighlight">\(j\)</span> بیشتر مساوی از <span class="math notranslate nohighlight">\(\lceil{n/2}\rceil\)</span> است پس باید برای آن که <span class="math notranslate nohighlight">\(A\)</span> در کل مسیر تغییر نکند <span class="math notranslate nohighlight">\(j\)</span> بچه
<span class="math notranslate nohighlight">\(i\)</span> باشد و سایز زیر درختش  دقیقا <span class="math notranslate nohighlight">\(n/2\)</span> باشد . پس درخت زوج راسی است زیرا سایز زیر درخت <span class="math notranslate nohighlight">\(j\)</span> بیشتر مساوی <span class="math notranslate nohighlight">\(\lceil{n/2}\rceil\)</span> است و سایز زیر درخت بچه های
<span class="math notranslate nohighlight">\(i\)</span> باید کمتر مساوی <span class="math notranslate nohighlight">\(\lfloor{n/2}\rfloor\)</span> باشد پس باید <span class="math notranslate nohighlight">\(\lfloor{n/2}\rfloor = \lceil{n/2}\rceil \)</span> زوج است.
همچنین فهمیدیم در بالا هر دو سنتروید با هم همسایه اند پس واضح است که حداکثر میتوانیم دو سمنترید داشته باشیم و اگر نه دور داریم.</p>
</section>
<section id="id10">
<h2>مجموع فاصله ها<a class="headerlink" href="#id10" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید در مسئله ای هدف مینیمم یا ماکسیمم کردن مجموع فاصله بین هر دو راس است فرض کنید به این مجموع چگالی گراف بگوییم. به صورت شهودی هر چه چگالی گراف کمتر باشد گراف جمع و جور تر و هر چه چگالی گراف بیشتر باشد گراف پهن و پخش تر است.</p>
<p>در ضمن برای اینکه فاصله تعریف شده باشد فرض کنید موضوع بحث ما گراف های همبند می باشد.</p>
<section id="id11">
<h3>کمینه کردن چگالی گراف<a class="headerlink" href="#id11" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>فاصله بین دو راس حداقل 1 است. و در گراف <span class="math notranslate nohighlight">\(K_n\)</span> فاصله بین هر دو راس دقیقا 1 است. پس کمترین چگالی ممکن در گراف <span class="math notranslate nohighlight">\(K_n\)</span> به دست می آید که برابر با <span class="math notranslate nohighlight">\(n \choose 2\)</span> می باشد.</p>
<p>حالا اگر دامنه بحث را به درخت ها محدود کنیم مسئله کمی سخت تر می شود. اما همچنان می توان اینگونه استنتاج کرد.</p>
<ul class="simple">
<li><p>دقیقا <span class="math notranslate nohighlight">\(n-1\)</span> جفت از راس ها هستند که فاصله اشان دقیقا 1 است. زیرا درخت <span class="math notranslate nohighlight">\(n-1\)</span> یال دارد.</p></li>
<li><p>هر جفتی از راس ها که به همدیگر یال ندارند دارای فاصله حداقل 2 هستند.</p></li>
</ul>
<p>در نتیجه کمترین چگالی ممکن حداقل <span class="math notranslate nohighlight">\(2 \times {n \choose 2} - (n-1)\)</span> می باشد و تنها مثالی که در حالت این کران صدق می کند حالتی است که فاصله بین هر دو راس <strong>حداکثر</strong> برابر با 2 است. تنها درختی که این ویژگی را دارد ستاره می باشد (همانطور که در عکس می بینید). زیرا که اگر در این گراف دو برگ باشند که پدر مشترک نداشته باشند در اینصورت فاصله آنها حداقل 3 خواهد بود.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/S_7.svg"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/S_7.svg" width="50%" /></a>
</figure>
</section>
<section id="id12">
<h3>بیشینه کردن چگالی گراف<a class="headerlink" href="#id12" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>در این حالت توجه کنید که اگر یالی را حذف کنیم و حذف این یال گراف را ناهمبند نکند باید اینکار را بکنیم. زیرا که حذف یال باعث بیشتر شدن چگالی می شود (چرا؟). پس گرافی که چگالی آن بیشینه است را باید در میان درخت ها جست و جو کرد (زیرا همانطور که گفتیم همه یال های آن باید برشی باشد).</p>
<p>حالا یک راس خاص مثل <span class="math notranslate nohighlight">\(u\)</span> را در نظر بگیرید. ادعا می کنیم جمع فواصل همه راس ها از <span class="math notranslate nohighlight">\(u\)</span> حداکثر برابر با <span class="math notranslate nohighlight">\(n \choose 2\)</span> است.</p>
<p>برای اثبات فرض کنید درخت را از <span class="math notranslate nohighlight">\(u\)</span> آویزان کرده ایم و به ازای هر ارتفاع می دانیم که چند راس در این ارتفاع قرار دارند و بیشترین ارتفاع <span class="math notranslate nohighlight">\(H\)</span> باشد. در اینصورت به ازای هر ارتفاعی از 0 تا <span class="math notranslate nohighlight">\(H\)</span> حداقل یک راس از این ارتفاع باید داشته باشیم. حالا اگر حداقل دو راس در یک ارتفاع داشتیم می توان یکی از آن ها را به ارتفاع بالاتر برد و در اینصورت جمع ارتفاع ها بیشتر خواهد شد. با تکرار این فرایند به حالتی می رسیم که در هر ارتفاع 0 تا <span class="math notranslate nohighlight">\(n-1\)</span> دقیقا یک راس باشد (یعنی درخت یک مسیر شده) که در این حالت جمع فاصله ها از <span class="math notranslate nohighlight">\(u\)</span> برابر با <span class="math notranslate nohighlight">\(1 + 2 + ... + (n-1) = {n \choose 2}\)</span> خواهد بود. پس ثابت کردیم که جمع فاصله ها از هر راس <span class="math notranslate nohighlight">\(u\)</span> حداکثر <span class="math notranslate nohighlight">\(n \choose 2\)</span> است.</p>
<p>پس حالا برای اینکه به یک کران برسیم در هر مرحله یک <strong>برگ</strong> را از درخت حذف کنید و جمع فاصله ها از این برگ را محاسبه کنید. جمع تمام مقادیر برابر با چگالی گراف خواهد بود که طبق آنچه گفتیم حداکثر <span class="math notranslate nohighlight">\(\sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3}\)</span> خواهد بود (طبق اتحاد چوشی چی).</p>
<p>می توان نتیجه گرفت تنها گرافی که در حالت تساوی این کران صدق می کند گراف مسیر است.</p>
</section>
</section>
<section id="id13">
<h2>درخت پشتیبانی<a class="headerlink" href="#id13" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید یک شبکه ارتباطی داریم که <span class="math notranslate nohighlight">\(n\)</span> شهر را به هم وصل می کنند. برای اطمینان یک شبکه ارتباطی پشتیبانی هم آماده کرده ایم که در صورت ایجاد اختلال در شبکه اصلی از شبکه پشتیبانی استفاده کنیم تا ارتباط قطع نشود.</p>
<p>به زبان گراف دو درخت <span class="math notranslate nohighlight">\(n\)</span> راسی <span class="math notranslate nohighlight">\(T\)</span> و <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span> داریم. می خواهیم ثابت کنیم در صورتیکه یکی از یال های <span class="math notranslate nohighlight">\(T\)</span> مثل <span class="math notranslate nohighlight">\(uv\)</span> قطع شوند می توان یکی از یال های <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span> مثل <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span> را به درخت <span class="math notranslate nohighlight">\(T\)</span> اضافه کرد که ساختار همچنان همبند باقی بماند.</p>
<p>پس فرض کنید <span class="math notranslate nohighlight">\(uv\)</span> را از <span class="math notranslate nohighlight">\(T\)</span> حذف کردیم در اینصورت درخت ما دارای دو مولفه همبندی خواهد شد یکی از مولفه ها را آبی و دیگری را قرمز در نظر بگیرید. حالا می توان در درخت <span class="math notranslate nohighlight">\(T^{\prime}\)</span> مسیری بین <span class="math notranslate nohighlight">\(u,v\)</span> یافت.
در این مسیر یالی وجود خواهد داشت که یک سر آن آبی و یک سر آن قرمز باشد (چرا؟). حالا اگر این یال <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span> باشد می توانیم این یال را به <span class="math notranslate nohighlight">\(T\)</span> اضافه کنیم و دوباره آن را همبند کنیم!</p>
</section>
<section id="id14">
<h2>افراز درخت به مسیر ها<a class="headerlink" href="#id14" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>درخت <span class="math notranslate nohighlight">\(T\)</span> را در نظر بگیرید. در این قسمت هدف ما این است که یال های این درخت را به کمترین تعداد تعدادی مسیر افراز کنیم. برای شهود بهتر فرض کنید یال های مسیر ها را یکی یکی از درخت حدف می کنیم تا به گرافی بدون یال برسیم.</p>
<p>اول از همه توجه کنید که بعد از حذف هر مسیر تنها زوجیت درجه دو سر مسیر تغییر می کند همچنین در انتها درجه تمام راس ها زوج (صفر) خواهد بود. پس یک راس درجه فرد باید فرد بار و یک راس درجه زوج باید زوج بار به عنوان یک سر مسیر انتخاب شود. پس اگر تعداد راس های درجه فرد درخت <span class="math notranslate nohighlight">\(X\)</span> باشد آنگاه حداقل <span class="math notranslate nohighlight">\(\frac X 2\)</span> مسیر نیاز داریم. (می دانیم که تعداد راس های درجه فرد هر گرافی زوج است پس <span class="math notranslate nohighlight">\(X\)</span> زوج است).</p>
<p>حالا اگر در هر مرحله مسیر بین دو راس درجه فرد را حذف کنیم می توانیم به حالت بهینه برسیم! فقط باید توجه داشته باشیم که دو راس درجه فرد ما مربوط به یک مولفه همبندی باشد.</p>
<p>حالا سوالی که پیش می آید این است که درخت بودن طی این فرایند به ما چه کمکی کرد؟</p>
<p>در نهایت ما از این موضوع استفاده کردیم که اگر درختی راس درجه فرد نداشته باشد یالی ندارد (اما این قضیه در گراف به صورت کلی برقرار نیست). چرا که اگر تعداد راس های گراف حداقل دو باشد در اینصورت برگی خواهد داشت که درجه آن 1 (و فرد) است.</p>
</section>
<section id="id15">
<h2>پوشاندن یال های درخت با مسیر ها<a class="headerlink" href="#id15" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>در ابن قسمت می خواهیم کمترین تعداد مسیر را پیدا کنیم که اجتماع آن ها کل یال های <span class="math notranslate nohighlight">\(T\)</span> را شامل شود. این مسئله مشابه حالت قبل است با این تفاوت که در حالت قبل یال ها را به مسیر ها افراز می کردیم یعنی هر یال متعلق به یک مسیر بود. در اینجا این آزادی را داریم که یک مسیر چند بار یالی را بپوشاند. می توان نتیجه گرفت که جواب این مسئله کمتر از مسئله قبل است.</p>
<p>در نگاه اول متوجه می شوید که چون طولانی کردن مسیر ها ضرری با ما نمی زند پس حالت بهینه ای وجود دارد که دو سر هر مسیر برگ باشد!</p>
<p>از طرف دیگر به ازای هر برگ یالی که از این برگ به راس مجاورش می رود را در نظر بگیرید. هر مسیر حداکثر 2 تا از این یال ها را می پوشاند. پس اگر <span class="math notranslate nohighlight">\(X\)</span> تا برگ داشته باشیم حداقل <span class="math notranslate nohighlight">\(\frac X 2\)</span> تا مسیر نیاز داریم حالا تلاش می کنیم تا این کران را بر آورده کنیم. یعنی اگر <span class="math notranslate nohighlight">\(X\)</span> زوج باشد با <span class="math notranslate nohighlight">\(\frac X 2\)</span> مسیر و اگر <span class="math notranslate nohighlight">\(X\)</span> فرد بود با <span class="math notranslate nohighlight">\(\frac {X+1} 2\)</span> مسیر یال های درخت را بپوشانیم.</p>
<p>پس سعی می کنیم در هر مرحله پس از انتخاب مسیر درختمان را به درختی تبدیل کنیم که تعداد برگ هایش دو تا کمتر است(البته در حالتی که <span class="math notranslate nohighlight">\(X\)</span> فرد باشد مرحله آخر نمی توانیم اینکار را بکنیم). اگر بتوانیم این کار را بکنیم تعداد مسیر هایی که انتخاب کردیم نصف تعداد برگ ها خواهد بود همانطور که می خواستیم.</p>
<p>دو برگ دلخواه مثل <span class="math notranslate nohighlight">\(u,v\)</span> را در نظر بگیرید و درخت را از این مسیر آویزان کنید. ابتدا این مسیر را انتخاب کنید (که یال های بین <span class="math notranslate nohighlight">\(u,v\)</span> را بپوشاند). فرض کنید راس های مسیر ما <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> باشد حالا درختی می سازیم که به جای <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> یک راس دارد! بین این راس و یک راس مثل <span class="math notranslate nohighlight">\(w\)</span> یال است اگر و تنها اگر بین <span class="math notranslate nohighlight">\(w\)</span> و یکی از <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> یال باشد.‌ (به صورت شهودی مثل این است که کل راس های مسیر را فشرده کردیم و به یک راس تبدیل کردیم). حالا هر مسیر در گراف جدیدمان معادل با یک مسیر در گراف اولیه است و الان تنها کافیست کل یال ها در درخت جدید را با مسیر ها بپوشانیم!</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_1.svg"><img alt="درخت اولیه" src="../../_images/Tree_to_Path_1.svg" width="50%" /></a>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_2.svg"><img alt="درخت پس از فشرده کردن یک یال" src="../../_images/Tree_to_Path_2.svg" width="50%" /></a>
</figure>
<p>پس در هر مرحله یک مسیر که دو سر آن برگ است را فشرده می کنیم و به صورت یک راس در می آوریم. در هر مرحله تعداد برگ های گراف جدیدمان دو تا کم می شود مگر اینکه راسی که جدید اضافه کردیم (راس فشرده) برگ باشد. در صورتی این اتفاق می افتد که راس های مسیر بین <span class="math notranslate nohighlight">\(u,v\)</span> همه درجه 2 باشند به جز یکی از آنها که باید درجه 3 باشد. به <span class="math notranslate nohighlight">\(u,v\)</span> که مسیر بین آن چنین خاصیتی داشته باشد یک زوج ناسازگار می گوییم.</p>
<p>پس اگر بتوانیم در هر مرحله دو برگ <span class="math notranslate nohighlight">\(u,v\)</span> را طوری انتخاب کنیم که زوج ناسازگار نباشند این کار را می کنیم (‌که پس از فشرده سازی از تعداد برگ ها 2 تا کم می کند). اگر نتوانستیم اینکار را بکنیم چه؟ در اینصورت ادعا می کنیم تنها یک راس درجه 3 داریم و باقی راس ها دارای درجه 1 یا 2 هستند (چرا؟). در اینصورت همانطور که در شکل می بینید درخت ما دقیقا 3 برگ خواهد داشت و می توانیم آن را با 2 مسیر بپوشانیم.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Tree_to_Path_3.svg"><img alt="درخت نهایی" src="../../_images/Tree_to_Path_3.svg" width="50%" /></a>
</figure>
</section>
<section id="id16">
<h2>درخت چپانی<a class="headerlink" href="#id16" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید درختی <span class="math notranslate nohighlight">\(n\)</span> راسی به نام <span class="math notranslate nohighlight">\(T\)</span> داریم. همچنین گرافی مثل <span class="math notranslate nohighlight">\(G\)</span> داریم که <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span>. می خواهیم ثابت کنیم زیرمجموعه ای از یال های <span class="math notranslate nohighlight">\(G\)</span> وجود دارد که <span class="math notranslate nohighlight">\(T\)</span> را بسازد. (به صورت شهودی یک درخت <span class="math notranslate nohighlight">\(T\)</span> در گراف <span class="math notranslate nohighlight">\(G\)</span> بتوان پیدا کرد).</p>
<p>یک برگ دلخواه مثل <span class="math notranslate nohighlight">\(u\)</span> که تنها مجاور آن <span class="math notranslate nohighlight">\(v\)</span> است را در نظر بگیرید و <span class="math notranslate nohighlight">\(u\)</span> را از درخت حذف کنید! سپس به صورت استقرایی درخت <span class="math notranslate nohighlight">\(T-u\)</span> را در <span class="math notranslate nohighlight">\(G\)</span> پیدا کنید. حالا می خواهیم یال <span class="math notranslate nohighlight">\(uv\)</span> را به درختمان اضافه کنیم. فرض کنید راس <span class="math notranslate nohighlight">\(v\)</span> در گراف <span class="math notranslate nohighlight">\(G\)</span> متناظر با <span class="math notranslate nohighlight">\(v^{\prime}\)</span> شده باشد. حالا کافیست از بین مجاور های <span class="math notranslate nohighlight">\(v^{\prime}\)</span> راسی را انتخاب کنید که قبلا با هیچ راس درخت متناظر نشده است. سپس می توان این راس را متناظر با <span class="math notranslate nohighlight">\(u\)</span> قرار داد که فرض استقرای ما را ثابت می کند.</p>
<p>برای یافتن چنین راسی کافیست از فرض <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span> استفاده کنیم. پس <span class="math notranslate nohighlight">\(v^{\prime}\)</span> حداقل <span class="math notranslate nohighlight">\(n-1\)</span> مجاور دارد و حداکثر <span class="math notranslate nohighlight">\(n-2\)</span> تا از آن ها قبلا به راس های درخت متناظر شده اند. پس یکی از مجاور های <span class="math notranslate nohighlight">\(v\)</span> تا حالا به راس های درخت متناظر نشده که حالا می توانیم همانطور که گفتیم <span class="math notranslate nohighlight">\(u\)</span> را به آن متناظر کنیم.</p>
<p>این مسئله به منظور آشنایی شما با ساختار استقرا پذیر درخت مطرح شد. دیدید که چطور می توان یک برگ از درخت را حذف کرد و فرض استقرا را برای درخت باقی مانده به کار برد.</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:right;" title="خاصیت های مقدماتی" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="3.html" style="float:left;" title="شمردن تعداد درخت ها" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        پروانه cc-by-sa
                    </a>
                    در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>