

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>DFS &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="درخت ها" href="index.html" />
        <link rel="next" title="BFS" href="5.html" />
        <link rel="prev" title="شمردن تعداد درخت ها" href="3.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">انواع گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیرگراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">درخت ها</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف‌جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس و عملیات های روی آن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">دترمینان ماتریس ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">ماتریس وقوع</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">درخت دودویی (Binary Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">درخت جست و جوی دودویی (BST یا Binary Search Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">مسائل np و np کامل</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">تعریف np و np کامل</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">اثبات np کامل بودن مساله sat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">مسائل np کامل گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">درخت مجازی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">درخت پوشای کمینه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">تجزیه سبک سنگین(HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">تطابق</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">چند ماتریس خاص</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">برگه تقلب (Cheat sheet)</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; DFS</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/en/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (English)</a>
        <script>document.getElementById('lang-link').href=`/en${window.location.pathname}`;</script>
        
            <a href="../../_sources/book/2/4.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="dfs">
<h1>DFS<a class="headerlink" href="#dfs" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>الگوریتم dfs یکی از روش های پیمایش گراف است و یکی از ساده ترین و پایه ای ترین الگوریتم های گراف می باشد. این الگوریتم در عین سادگی ویژگی های جالبی دارد و برخلاف تصور در حل مسائل تئوری و عملی کاربرد فراوان دارد!</p>
<section id="id1">
<h2>اولین مسئله<a class="headerlink" href="#id1" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید در یک هزارتو گیر کرده اید که به صورت یک گراف است. یعنی در هر راس گراف یک اتاق قرار دارد و هر یال نشان دهنده یک راهرو بین دو اتاق است. همچنین حافظه شما به قدری قوی است که می توانید اگر به یک اتاق تکراری رفتید تشخیص بدهید که این اتاق تکراری است و هنگامی که در یک اتاق هستید تنها می توانید راهرو های مجاور آن را ببینید. همچنین یک نخ به همراه دارید که یک سر آن به اتاقی که اول کار در آن قرار دارید بسته شده است و سر دیگر در دستان شماست. در یکی از راس های گراف گنجی قرار دارد. هدف شما این است که گنج را بیابید. چگونه این کار را انجام می دهید؟</p>
<p>پیدا کردن گنج به سادگی انجام الگوریتم زیر است. تا زمانی که به گنج نرسیدیم الگوریتم زیر را انجام دهید :</p>
<ul class="simple">
<li><p>اگر همه اتاق های مجاور تکراری بودند به اتاقی برو که برای اولین بار از آن به اتاق فعلی آمده ای. (کافی است نخی که دستمان است را دنبال کنیم).</p></li>
<li><p>در غیراینصورت به یکی از اتاق های مجاور که تکراری نیست برو.</p></li>
</ul>
<p>چرا این الگوریتم مسئله ما را حل می کند؟ نکته اینجاست که زمانی که ما برای اولین بار در یک اتاق قرار می گیریم تمام تلاشمان را می کنیم که از آن اتاق مسیری به گنج پیدا کنیم. در نتیجه وقتی که همه اتاق های مجاور تکراری می شوند و ما نخ را دنبال کرده و بر می گردیم می توان نتیجه گرفت که هیچ مسیری از آن اتاق به گنج وجود ندارد. در نتیجه هیچ گاه دیگر نباید وارد این اتاق شویم. (و این منطق که نباید وارد اتاق تکراری شویم نیز از همینجا ناشی می شود).</p>
<p>می توان با یک دید متفاوت تر هم به مسئله نگاه کرد. به ازای هر یال <span class="math notranslate nohighlight">\(uv\)</span> اگر یکی از <span class="math notranslate nohighlight">\(u,v\)</span> را ببینیم قطعا دیگری را نیز خواهیم دید. (زیرا زمانی کارمان با یک راس تمام می شود که تمام مجاور های آن تکراری باشند). در نتیجه اگر یک راس از مولفه همبندی را ببینیم تمام راس های دیگر آن را نیز خواهیم دید.</p>
</section>
<section id="id2">
<h2>مولفه های همبندی<a class="headerlink" href="#id2" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>گراف <span class="math notranslate nohighlight">\(G\)</span> به شما ورودی داده شده است. شما باید تعداد مولفه های همبندی این گراف را بیابید.</p>
<p>آنچه در این قسمت بررسی می کنیم تصویری کلی از الگوریتم dfs است. فرض کنید آرایه mark نشان می دهد که چه راس هایی قبلا دیده شده اند و در ابتدای کار تمام خانه های آن false است. حالا الگوریتم ما به اینصورت خواهد بود :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">){</span><span class="w"></span>
<span class="w">   </span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">mark</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>از شهودی که با حل مسئله بالا به دست آوردیم استفاده کنید. وقتی dfs(u) صدا زده می شود الگوریتم تلاش می کند که به صورت بازگشتی تمام راس هایی که با <span class="math notranslate nohighlight">\(u\)</span> می توان به آن رسید را ببیند سپس dfs(u) به اتمام می رسد و به راسی به نام <span class="math notranslate nohighlight">\(par\)</span> بر می گردیم که از آن برای اولین بار به <span class="math notranslate nohighlight">\(u\)</span> رسیده بودیم.</p>
<p>در نتیجه می توان دید که پس از اجرای این تابع تمام راس هایی که در مولفه همبندی راس شروع قرار دارند دیده می شوند. پس برای حل مسئله کافیست در هر مرحله راسی مثل <span class="math notranslate nohighlight">\(y\)</span> را انتخاب کنیم که mark آن false باشد. سپس dfs(y) را اجرا کرده و به جواب مسئله یکی اضافه کنیم.</p>
</section>
<section id="id3">
<h2>درخت dfs<a class="headerlink" href="#id3" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>الگوریتم dfs علاوه بر اینکه گراف ما را پیمایش می کند این پیمایش را به صورت خاصی انجام می دهد! حالا با برخی از ویژگی های جالب این پیمایش آشنا می شویم.</p>
<p>فرض کنید یال های گراف در ابتدا آبی هستند. حالا هر گاه که برنامه در راس <span class="math notranslate nohighlight">\(v\)</span> بود و با طی کردن یال <span class="math notranslate nohighlight">\(uv\)</span> به راس جدید <span class="math notranslate nohighlight">\(u\)</span> می رسید یال <span class="math notranslate nohighlight">\(uv\)</span> را قرمز کنید.</p>
<p>در ابتدا توجه کنید که یال های قرمز تشکیل یک درخت می دهند! زیرا هر بار که یک یال قرمز می شود یک سر آن متصل یه راسی است که قبلا ندیده بودیم. پس مثل این است که یکی یکی به این درخت برگ اضافه می کنیم! به این درخت به دست آمده از الگوریتم
dfs،
درخت dfs می گوییم. ویژگی جالب dfs این است که وقتی اجرای
dfs(u)
شروع می شود راس
<span class="math notranslate nohighlight">\(u\)</span>
در درخت قرمز ها تنها یک برگ است و زمانی که اجرای dfs(u) به پایان می رسد زیردرخت
<span class="math notranslate nohighlight">\(u\)</span>
به طور کامل ساخته شده است.
پس می بینید که پس از اجرای الگوریتم dfs روی یک گراف همبند، یک درخت فراگیر از این گراف را به دست خواهیم آورد. این درخت فراگیر را از راس شروع ریشه دار کنید.</p>
<p>حالا به ویژگی جالبی که روی یال های آبی به دست می آید توجه کنید.</p>
<p>به یال <span class="math notranslate nohighlight">\(uv\)</span> بک اج (back edge) می گوییم اگر یکی از <span class="math notranslate nohighlight">\(u,v\)</span> جد دیگری باشد. در غیراینصورت به این یال کراس اج (cross edge) می گوییم. البته
ممکن است بعضا یک دسته تری ادج (tree edge) در نظر بگیرند و یال های خود درخت را تری ادج و یال های دیگر را بک ادج در نظر بگیرند اما ما در اینجا
همه را بک ادج در نظر می گیریم و به این دو دسته اکتفا می کنیم.</p>
<p>ادعا می کنیم برای هر درخت dfs تمام یال های گراف بک اج هستند!</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/Back_Edge.svg"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/Back_Edge.svg" width="50%" /></a>
</figure>
<p>برای اثبات اینکه تمام یال ها بعد از پیمایش
dfs
بک اج هستند یک یال
<span class="math notranslate nohighlight">\(uv\)</span>
دلخواه را در نظر بگیرید. بدون کم شدن از کلیت مسئله فرض کنید در الگوریتم ابتدا به راس
<span class="math notranslate nohighlight">\(u\)</span> وارد شده ایم. در اینصورت موقع شروع dfs(u) راس <span class="math notranslate nohighlight">\(v\)</span> هنوز دیده نشده است. همچنین زمانی که dfs(u) به پایان می رسد راس <span class="math notranslate nohighlight">\(v\)</span> باید دیده شده باشد (زیرا مجاور راس <span class="math notranslate nohighlight">\(u\)</span> است). بنابراین اگر درخت dfs را در نظر بگیرید راس <span class="math notranslate nohighlight">\(v\)</span> باید درون زیردرخت <span class="math notranslate nohighlight">\(u\)</span> باشد! در نتیجه <span class="math notranslate nohighlight">\(u\)</span> جد <span class="math notranslate nohighlight">\(v\)</span> است پس یال <span class="math notranslate nohighlight">\(uv\)</span> بک اج خواهد بود.</p>
<p>در آینده از این قضیه که بعد از اجرای dfs تمام یال ها بک اج هستند استفاده های بسیاری خواهیم کرد!</p>
</section>
<section id="id4">
<h2>مسیر ماکسیمال و dfs<a class="headerlink" href="#id4" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>در فصل 1 با اثبات هایی که توسط مسیر ماکسیمال انجام می شد آشنا شدیم. در اینجا یاد می گیریم که می توان به جای استفاده از مسیر ماکسیمال از برگ های درخت dfs استفاده کرد(که شهود بسیار قوی تری ایجاد می کند)!</p>
<p>بعد از dfs زدن روی درخت، تعداد بک اج هایی که
<span class="math notranslate nohighlight">\(u\)</span>
راس پایین آن است را
<span class="math notranslate nohighlight">\(back_u\)</span>
می نامیم. توجه کنید که یال های درخت dfs هم طبق تعریف ما بک اج محسوب می شوند. همچنین ارتفاع راس <span class="math notranslate nohighlight">\(u\)</span> در درخت را <span class="math notranslate nohighlight">\(h_u\)</span> می نامیم.</p>
<p>دو قضیه زیر به راحتی از ساختار خاص درخت نتیجه می شوند (قضیه دوم با فرض ساده بودن گراف برقرار است).</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sum back_u = m\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall_u back_u \leq h_u\)</span></p></li>
</ul>
<section id="delta">
<h3>مسیر به طول <span class="math notranslate nohighlight">\(\delta\)</span><a class="headerlink" href="#delta" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>ثابت می کنیم که یک گراف ساده مسیری به طول حداقل <span class="math notranslate nohighlight">\(\delta\)</span> دارد. کافیست ثابت کنیم ارتفاع درخت dfs حداقل <span class="math notranslate nohighlight">\(\delta\)</span> است. یک برگ دلخواه مثل <span class="math notranslate nohighlight">\(u\)</span> را در نظر بگیرید. واضح است که <span class="math notranslate nohighlight">\(back_u \geq \delta\)</span> در نتیجه <span class="math notranslate nohighlight">\(h_u \geq \delta\)</span> که حکم ما را به سادگی نتیجه می دهد!</p>
</section>
<section id="frac-m-n">
<h3>مسیر به طول <span class="math notranslate nohighlight">\(\frac m n\)</span><a class="headerlink" href="#frac-m-n" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>ثابت می کنیم که یک گراف ساده مسیری به طول حداقل <span class="math notranslate nohighlight">\(\frac m n\)</span> دارد. مثل بالا ثابت می کنیم ارتفاع درخت dfs حداقل <span class="math notranslate nohighlight">\(\frac m n\)</span> است. برای اثبات از برهان خلف استفاده می کنیم. فرض کنید ارتفاع هر راس کمتر از <span class="math notranslate nohighlight">\(\frac m n\)</span> باشد. داریم :
<span class="math notranslate nohighlight">\(m = \sum back_u \leq \sum h_u &lt; n \times \frac m n = m \Rightarrow m &lt; m\)</span></p>
<p>که به ما تناقض می دهد. در نتیجه راسی با ارتفاع حداقل <span class="math notranslate nohighlight">\(\frac m n\)</span> وجود دارد که حکم مسئله ما را ثابت می کند.</p>
</section>
<section id="id5">
<h3>برگ ها و ارتفاع، مجموعه مستقل و طولانی ترین مسیر!<a class="headerlink" href="#id5" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>فرض کنید بعد از اعمال الگوریتم dfs ارتفاع درخت برابر با <span class="math notranslate nohighlight">\(H\)</span> شود(در واقع <span class="math notranslate nohighlight">\(H\)</span> بیشینه مقدار بین <span class="math notranslate nohighlight">\(h_u\)</span> ها است). همچنین فرض کنید تعداد برگ ها <span class="math notranslate nohighlight">\(S\)</span> باشد.</p>
<p>در اینجا ثابت می کنیم که <span class="math notranslate nohighlight">\(H \times S \geq n-1\)</span>.</p>
<p>به ازای هر برگ درخت مسیر این راس تا ریشه را طی کنید و روی هر راس این مسیر به جز ریشه یک سنگ قرار دهید. در اینصورت به ازای هر برگ مثل <span class="math notranslate nohighlight">\(u\)</span> به تعداد کل سنگ ها <span class="math notranslate nohighlight">\(h_u\)</span> تا اضافه می شود. از طرفی روی هر راس به جز ریشه حداقل یک سنگ قرار دادیم در نتیجه تعداد کل سنگ ها حداقل <span class="math notranslate nohighlight">\(n-1\)</span> می باشد. پس می توان نوشت :</p>
<p><span class="math notranslate nohighlight">\(n-1 \leq \sum h_u \leq H \times S\)</span></p>
<p>که حکم ما را ثابت می کند. اما تا الان از ویژگی خاصی که توسط درخت dfs به دست بیاید استفاده نکردیم! نکته جالب این است که برگ های درخت dfs تشکیل یک مجموعه مستقل می دهند. (زیرا وجود یال بین دو برگ موجب ایجاد کراس اج می شود).</p>
<p>در نتیجه اگر اندازه مجموعه مستقل بیشینه <span class="math notranslate nohighlight">\(S^{\prime}\)</span> باشد در اینصورت <span class="math notranslate nohighlight">\(S \leq S^{\prime}\)</span> برقرار است.</p>
<p>همینطور اگر اندازه طولانی ترین مسیر این گراف <span class="math notranslate nohighlight">\(H^{\prime}\)</span> باشد در اینصورت <span class="math notranslate nohighlight">\(H \leq H^{\prime}\)</span> برقرار است.</p>
<p>پس حالا توانستیم به نامساوی جالب <span class="math notranslate nohighlight">\(n-1 \leq H \times S \leq H^{\prime} \times S^{\prime}\)</span> برسیم!</p>
<p>نکته جالب این است که هر دو مسئله پیدا کردن مچموعه مستقل با بیشترین بیشینه و طولانی ترین مسیر در گراف np هستند! اما با روشی که ارائه دادیم می توانیم یا یک مجموعه مستقل به اندازه حداقل <span class="math notranslate nohighlight">\(\sqrt{n-1}\)</span> یا یک مسیر به اندازه حداقل <span class="math notranslate nohighlight">\(\sqrt{n-1}\)</span> ارائه دهیم!</p>
</section>
<section id="id6">
<h3>راس نابرشی<a class="headerlink" href="#id6" title="پیوند ثابت به این سر مقاله">¶</a></h3>
<p>ثابت می کنیم هر گراف با <span class="math notranslate nohighlight">\(n &gt; 1\)</span> حداقل دو راس نابرشی دارد.</p>
<p>کافیست روی گراف dfs بزنید. سپس هر کدام از برگ های درخت dfs یک راس نابرشی خواهند بود (همچنین اگر این دو راس را با هم نیز حذف کنیم گراف ناهمبند نمی شود). زیرا که یال های درخت dfs بقیه گراف را همبند نگه می دارد (و حذف برگ از یک درخت همبندی آن را خراب نمی کند). همچنین هر درخت با <span class="math notranslate nohighlight">\(n&gt;1\)</span> حداقل دو برگ دارد که حکم ما را ثابت می کند. البته در این مسئله نیازی به استفاده از درخت dfs نبود و هر درخت فراگیر دلخواهی مسئله را برای ما حل می کرد.</p>
</section>
</section>
<section id="id7">
<h2>پیمایش درخت<a class="headerlink" href="#id7" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>یکی از حالات خاص مسئله پیمایش گراف، پیمایش درخت ها است. در این قسمت می بینیم که پیمایش درخت ها می تواند با الگوریتم dfs به صورت ساده تر انجام شود. مثلا دیگر به آرایه mark نیازی نداریم. زیرا تنها مجاور یک راس که قبلا دیده شده است پدر این راس می باشد.</p>
<p>همچنین می توان همزمان به اجرای dfs اطلاعات دیگری نیز درباره درخت به دست آورد. به عنوان مثال در کد زیر بعد از اجرای dfs روی درخت تعداد راس های زیردرخت هر راس در آرایه sz، و ارتفاع هر راس در آرایه h ذخیره سازی می شوند.</p>
<p>توجه کنید که فرض کردیم اندیس راس های درخت از 1 شروع می شوند و راس با اندیس 0 نداریم.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">par</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">   </span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span><span class="w"></span>
<span class="w">       </span><span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">par</span><span class="p">){</span><span class="w"></span>
<span class="w">           </span><span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sz</span><span class="p">[</span><span class="n">y</span><span class="p">];</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="3.html" style="float:right;" title="شمردن تعداد درخت ها" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="5.html" style="float:left;" title="BFS" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        پروانه cc-by-sa
                    </a>
                    در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>