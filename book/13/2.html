

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    
         <title>تطابق در گراف دوبخشی &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">

    <link rel="stylesheet" type=text/css href="../../_static/pygments.css">

    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="تطابق" href="index.html" />
        <link rel="next" title="قضایا ی مینماکس" href="3.html" />
        <link rel="prev" title="آشنایی" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/javascript" src="../../None"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
<style>
    * {
        border-radius: 1rem;
    }
</style>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">انواع گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیرگراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">درخت ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">DFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">BFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">DFS Start/Finish Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف‌جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس و عملیات های روی آن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">دترمینان ماتریس ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">ماتریس وقوع</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/4.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/5.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/6.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">درخت دودویی (Binary Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">درخت جست و جوی دودویی (BST یا Binary Search Tree)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">Segment Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/6.html">Trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">مسائل np و np کامل</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">تعریف np و np کامل</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">اثبات np کامل بودن مساله sat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">مسائل np کامل گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/6.html">درخت مجازی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">درخت پوشای کمینه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/6.html">تجزیه سبک سنگین(HLD)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">تطابق</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">آشنایی</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">چند ماتریس خاص</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">برگه تقلب (Cheat sheet)</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; تطابق در گراف دوبخشی</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        <script>document.getElementById('problems-link').href=`/problems/${window.location.pathname.slice(6).replace('/','.')}.html`.replace('.html.html', '.html').replace('/.html', '/').replace('.index.html', '.html');</script>
        <a style="float: left; padding-right: 20px;" href="/en/" id="lang-link"><i class="fa fa-language on fa-circle"></i>&nbsp;Change Language (English)</a>
        <script>document.getElementById('lang-link').href=`/en${window.location.pathname}`;</script>
        
            <a href="../../_sources/book/13/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <section id="id1">
<h1>تطابق در گراف دوبخشی<a class="headerlink" href="#id1" title="پیوند ثابت به این سر مقاله">¶</a></h1>
<p>در بخش قبل گفتیم که شرط لازم و کافی برای داشتن یک تطابق ماکسیمم این است که مسیر افزوده وجود نداشته باشد. این شرط در گراف دوبخشی به راحتی قابل بررسی است (چرا؟).</p>
<p>در نتیجه بررسی کردن تطابق در گراف های دوبخشی (به عنوان حالت خاصی از گراف) به علت کاربرد زیادشان سودمند است.</p>
<section id="id2">
<h2>الگوریتم<a class="headerlink" href="#id2" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>در این الگوریتم از تطابق خالی شروع می‌کنیم و تا زمانی که مسیری افزایشی در گراف وجود داشت تطابق را بزرگ‌تر می‌کنیم. به راحتی قابل مشاهده است که در این صورت ماکسیمم بودن تطابق نهایی ما بدیهی است. برای پیدا کردن مسیر افزایشیبه این صورت عمل میکنیم:</p>
<p>فرض کنید گراف ما شامل دو بخش <span class="math notranslate nohighlight">\(n_1\)</span> راسی و <span class="math notranslate nohighlight">\(n_2\)</span> راسی باشد. به ازای <span class="math notranslate nohighlight">\(v = 1 ... n_1\)</span> در گراف حال حاضرمان به دنبال مسیر افزایشی می‌گردیم. در مرحله <span class="math notranslate nohighlight">\(i\)</span> ام می‌توان ادعا کرد تطابقی که بین <span class="math notranslate nohighlight">\(i\)</span> راس بخش اول و بقیه رئوس بخش دوم است ماکسیمم است، در نتیجه در آخر نیز تطابق ما ماکسیمم خواهد بود. پیاده‌سازی آن به شکل زیر است:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">mark</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">try_kuhn</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">try_kuhn</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]))){</span><span class="w"></span>
<span class="w">            </span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">read_input</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="o">--</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="o">--</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">calc</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">match</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">mark</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">try_kuhn</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">write_output</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">read_input</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">calc</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">write_output</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>در الگوریتم ذکر شده به ازای هر راس از بخش بالا، <span class="math notranslate nohighlight">\(O(m)\)</span> گام انجام می‌شود، پس پیچیدگی زمانی آن برابر <span class="math notranslate nohighlight">\(O(nm)\)</span> است. البته یک نوع پیاده‌سازی دیگر همین الگوریتم نیز وجود دارد که سرعت آن حداقل دوبرابر سریع‌تر از الگوریتم بالا است (چرا؟):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="n">vector</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">mark</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">try_kuhn</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">try_kuhn</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">])))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">read_input</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="o">--</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="o">--</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">calc</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">match</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">mark</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="n">k</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">try_kuhn</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">write_output</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">read_input</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">calc</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">write_output</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id3">
<h2>قضیه هال<a class="headerlink" href="#id3" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>این قضیه شرط لازم و کافی دیگری برای ماکسیمم بودن یک تطابق در یک گراف دوبخشی را بیان می‌کند که اولین بار توسط فیلیپ هال مطرح شد و به قضیه ازدواج معروف است. این قضیه به شرح زیر است:</p>
<p>فرض کنید <span class="math notranslate nohighlight">\(X\)</span> مجموعه‌ای از رئوس بخش اول یک گراف دوبخشی باشد. مجموعه <span class="math notranslate nohighlight">\(X\)</span> در گراف تطابق کامل دارد، اگر و تنها اگر به ازای هر زیرمجموعه از آن مثل <span class="math notranslate nohighlight">\(S\)</span> و مجموعه همسایه‌های خارج <span class="math notranslate nohighlight">\(X\)</span> آن‌ها در گراف به نام <span class="math notranslate nohighlight">\(T\)</span>، داشته باشیم <span class="math notranslate nohighlight">\(|S| \leq |T|\)</span>.</p>
<p>لازم بودن شرط بالا بدیهی است (در غیر این صورت تعداد رئوس مجاور یک مجموعه برای تطابق دادنشان کافی نخواهد بود). برای اثبات کافی بودن نیز از برهان خلف استفاده می‌کنیم و فرض می‌کنیم گرافی با چنین خاصیتی باشد که تطابق کامل نداشته باشد؛</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/marriage_theorem.jpeg"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/marriage_theorem.jpeg" style="width: 50%;" /></a>
</figure>
<p>یک تطابق ماکسیمم را درنظر می‌گیریم و راس دلخواهی مثل <span class="math notranslate nohighlight">\(u\)</span> که غیراشباع است را درنظر می‌گیریم (حتماً وجود دارد!). از آنجا که این راس با کسی منطبق نشده، راس منطبق یک راس دلخواه مجاور آن را درنظر میگیریم. این دو راس طبق فرض مسئله یک راس مجاور دیگر دارند که یا منطبق نشده (که در این صورت مسیر افزایشی داریم) و یا منطبق شده که راس منطبق آن را نیز به این دو راس اضافه می‌کنیم. این کار را تا جای ممکن ادامه می‌دهیم و از آنجا که تعداد رئوس مجاور <span class="math notranslate nohighlight">\(X\)</span> حداقل اندازه خودشان است، در آخر به مرحله‌ای میرسیم که مجموعه حال حاضرمان یک راس مجاور دارند که اشباع نشده که در این صورت مسیر افزایشی داریم که این با ماکسیمم بودن تطابقمان در تناقض است.</p>
</section>
<section id="k">
<h2>تطابق در گراف دوبخشی k منتظم<a class="headerlink" href="#k" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>طبق قضیه هال می‌توان اثبات کرد که گراف دوبخشی k منتظم تطابق کامل دارد. برای اثبات این موضوع نیز کافیست اثبات کنیم که شرط هال برای آن برقرار است؛</p>
<p>مجموعه‌ای از رئوس بخش اول گراف مثل <span class="math notranslate nohighlight">\(S\)</span> را درنظر بگیرید و همسایه‌های آن‌ها در بخش دوم را <span class="math notranslate nohighlight">\(T\)</span> بنامید. اثبات می‌کنیم <span class="math notranslate nohighlight">\(|S| \leq |T|\)</span>. می‌دانیم مجموع یال‌های بین دو بخش برابر <span class="math notranslate nohighlight">\(x = |S| \times k\)</span> است. از این رابطه می‌توان نتیجه گرفت <span class="math notranslate nohighlight">\(|T| \geq (x \div k) = |S|\)</span>.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../../_images/K_R_Bipartite_Subgraph.svg"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/K_R_Bipartite_Subgraph.svg" width="30%" /></a>
</figure>
<p>پس حکم حال در گراف ما برقرار است و قطعاً در گراف ما تطابقی کامل یافت می‌شود.</p>
</section>
<section id="id4">
<h2>تعمیم قضیه هال<a class="headerlink" href="#id4" title="پیوند ثابت به این سر مقاله">¶</a></h2>
<p>یک گراف دوبخشی به نام <span class="math notranslate nohighlight">\(G\)</span> داریم و می‌خواهیم تعدادی از یال‌های آن را برداریم، طوری که درجه هر راس بخش اول مثل <span class="math notranslate nohighlight">\(u\)</span> برابر <span class="math notranslate nohighlight">\(a_u\)</span> و درجه هر راس بخش دوم حداکثر یک شود. برای حل این مسئله گراف <span class="math notranslate nohighlight">\(G'\)</span> را به گونه‌ای میسازیم که در آن تطابق کامل از بخش اول به دوم وجود دارد، اگر و تنها اگر در گراف <span class="math notranslate nohighlight">\(G\)</span> چنین مجموعه یال‌هایی وجود داشته باشد؛</p>
<p>گراف <span class="math notranslate nohighlight">\(G'\)</span> را بدین گونه می‌سازیم که به جای هر راس <span class="math notranslate nohighlight">\(u\)</span> در گراف از بخش اول، یک مجموعه <span class="math notranslate nohighlight">\(a_u\)</span> تایی از رئوس می‌سازیم (که کپی هایی از راس <span class="math notranslate nohighlight">\(u\)</span> هستند) و به ازای هر یال گراف مثل <span class="math notranslate nohighlight">\((u, v)\)</span>، تمام مجموعه راس <span class="math notranslate nohighlight">\(u\)</span> را به راس  <span class="math notranslate nohighlight">\(v\)</span> متصل می‌کنیم. گراف حاصل دوبخشی است (چرا؟) اگر شرط هال در آن برقرار باشد یعنی تطابق کامل دارد که در این صورت به ازای هر یال بین مجموعه رئوس راس <span class="math notranslate nohighlight">\(u\)</span> و راس <span class="math notranslate nohighlight">\(v\)</span> در گراف، یال <span class="math notranslate nohighlight">\((u, v)\)</span> را در گراف <span class="math notranslate nohighlight">\(G\)</span> برمی‌داریم که بدیهی است که در این صورت به مجموعه یال‌های دلخواهمان می‌رسیم. در صورتی هم که گراف <span class="math notranslate nohighlight">\(G'\)</span> تطابقی کامل نداشته باشد به همین شکل می‌توان نتیجه گرفت که در گراف <span class="math notranslate nohighlight">\(G\)</span> نیز چنین مجموعه‌ای وجود ندارد (به صورت برعکس عمل میکنیم).</p>
<p>فرایند چک کردن شرط هال در گراف <span class="math notranslate nohighlight">\(G^{\prime}\)</span> را در نظر بگیرید.به ازای هر زیرمجموعه <span class="math notranslate nohighlight">\(S\)</span> که از بخش اول گراف <span class="math notranslate nohighlight">\(G ^ {\prime}\)</span> و مجموعه همسایه های آن <span class="math notranslate nohighlight">\(T\)</span> است، چک می کنیم که <span class="math notranslate nohighlight">\(|S| \leq |T|\)</span> برقرار باشد. حالا می توان توجه کرد که به ازای هر راس <span class="math notranslate nohighlight">\(u\)</span> اگر تعدادی از کپی های <span class="math notranslate nohighlight">\(u\)</span> در <span class="math notranslate nohighlight">\(S\)</span> آمده باشد ولی همه آن ها نیامده باشند می توان همه را به مجموعه <span class="math notranslate nohighlight">\(S\)</span> اضافه کرد در اینصورت <span class="math notranslate nohighlight">\(T\)</span> تغییری نخواهد کرد و تنها <span class="math notranslate nohighlight">\(S\)</span> زیاد می شود. پس می توان فقط <span class="math notranslate nohighlight">\(S\)</span> هایی را چک کرد که به ازای هر <span class="math notranslate nohighlight">\(u\)</span> یا تمام کپی های <span class="math notranslate nohighlight">\(u\)</span> آمده اند یا هیچکدام نیامده اند.</p>
<p>با کمی تفکر نتیجه می گیریم که طبق حرف های بالا می توان روی گراف <span class="math notranslate nohighlight">\(G\)</span> این شرط لازم و کافی را پیدا کرد : <span class="math notranslate nohighlight">\(\forall_{S} \sum\limits_{i \in S} a_i \leq |T|\)</span></p>
<p>که <span class="math notranslate nohighlight">\(S\)</span> هر زیرمجموعه ای از راس های بخش اول گراف است و  <span class="math notranslate nohighlight">\(T\)</span> اجتماع همسایه های <span class="math notranslate nohighlight">\(S\)</span> است.</p>
</section>
</section>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:right;" title="آشنایی" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="3.html" style="float:left;" title="قضایا ی مینماکس" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/">
                    <img style="max-width: unset;"  src="/_static/shaazzz_logo.png">
                </a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت
                    <a href="https://pdcommunity.ir/license/cc-by-sa/">
                        پروانه cc-by-sa
                    </a>
                    در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در اکتبر 13, 2025.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (4.3.2) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img style="max-width: unset;" src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>